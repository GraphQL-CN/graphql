<!DOCTYPE html><html><!-- Built with spec-md --><head><meta charset="utf-8"><title>GraphQL</title><link href="spec.css" rel="stylesheet"><link href="highlight.css" rel="stylesheet"></head><body><header><h1>GraphQL</h1><section id="intro"><p><em>草案 &ndash; 2016十月</em></p><p><strong>引言</strong></p><p>这是一份GraphQL规范的征求意见稿草案，其中GraphQL是Facebook于2012年创造的一种用于描述CS应用中数据模型的能力和要求的语言。本标准的开发起始于2015年，GraphQL是一种在还在演进的未完成的新语言，其重大功能增强也会在本规范的未来版本中体现。</p><p><strong>版权须知</strong> <small>(译者案：BSD开源协议)</small></p><p>版权所有 &copy; 2015&#8208;2016，Facebook股份有限公司。</p><p>在遵守以下条件的前提下，可再发布软件或以源代码及二进制形式使用软件，包括进行修改或不进行修改：</p><ul><li>源代码的再发布必须遵守上述版权通知、本条件列表以及以下免责声明。</li><li>以二进制形式再发布软件时必须复制上述版权通知、本条件列表以及文档下文中的免责声明和/或发布代码时提供的其他信息。<small>(译者案：所以下面保留英文原版)</small></li><li>未经事先书面批准的情况下，不得将名称Facebook或贡献者名字用于支持或推广该软件的衍生产品。</li></ul><p>本软件为版权所有人和贡献者&ldquo;按现状&rdquo;为根据提供，不提供任何明确或暗示的保证，包括但不限于本软件针对特定用途的可售性及适用性的暗示保证。在任何情况下，版权所有人或其贡献者均不对因使用本软件而以任何方式产生的任何直接、间接、偶然、特殊、典型或因此而生的损失（包括但不限于采购替换产品或服务；使用价值、数据或利润的损失；或业务中断）而根据任何责任理论，包括合同、严格责任或侵权行为（包括疏忽或其他）承担任何责任，即使在已经提醒可能发生此类损失的情况下。</p><p><strong>Copyright notice</strong></p><p>Copyright (c) 2015&#8208;2016, Facebook, Inc. All rights reserved.</p><p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p><ul><li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li><li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li><li>Neither the name Facebook nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</li></ul><p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &ldquo;AS IS&rdquo; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p></section><div class="spec-toc"><div class="title">Contents</div><ol><li><a href="#sec-Overview-"><span class="spec-secid">1</span>Overview/概览</a></li><li><a href="#sec-Language-"><span class="spec-secid">2</span>Language/语言</a><input hidden class="toggle" type="checkbox" checked id="_toggle_2" /><label for="_toggle_2"></label><ol><li><a href="#sec-Source-Text-"><span class="spec-secid">2.1</span>Source Text/源文本</a><input hidden class="toggle" type="checkbox" checked id="_toggle_2.1" /><label for="_toggle_2.1"></label><ol><li><a href="#sec-Unicode-"><span class="spec-secid">2.1.1</span>Unicode/统一码</a></li><li><a href="#sec-White-Space-"><span class="spec-secid">2.1.2</span>White Space/空白符</a></li><li><a href="#sec-Line-Terminators-"><span class="spec-secid">2.1.3</span>Line Terminators/行终止符</a></li><li><a href="#sec-Comments-"><span class="spec-secid">2.1.4</span>Comments/注释</a></li><li><a href="#sec-Insignificant-Commas-"><span class="spec-secid">2.1.5</span>Insignificant Commas/无语义逗号</a></li><li><a href="#sec-Source-Text-.Lexical-Tokens-"><span class="spec-secid">2.1.6</span>Lexical Tokens/词法记号</a></li><li><a href="#sec-Source-Text-.Ignored-Tokens-"><span class="spec-secid">2.1.7</span>Ignored Tokens/无语义记号</a></li><li><a href="#sec-Punctuators-"><span class="spec-secid">2.1.8</span>Punctuators/标点</a></li><li><a href="#sec-Names-"><span class="spec-secid">2.1.9</span>Names/命名</a></li></ol></li><li><a href="#sec-Language-.Query-Document-"><span class="spec-secid">2.2</span>Query Document/查询文档</a></li><li><a href="#sec-Language-.Operations-"><span class="spec-secid">2.3</span>Operations/操作</a></li><li><a href="#sec-Selection-Sets-"><span class="spec-secid">2.4</span>Selection Sets/选择集合</a></li><li><a href="#sec-Language-.Fields-"><span class="spec-secid">2.5</span>Fields/字段</a></li><li><a href="#sec-Language-.Arguments-"><span class="spec-secid">2.6</span>Arguments/参数</a></li><li><a href="#sec-Field-Alias-"><span class="spec-secid">2.7</span>Field Alias/字段别名</a></li><li><a href="#sec-Language-.Fragments-"><span class="spec-secid">2.8</span>Fragments/片段</a><input hidden class="toggle" type="checkbox" checked id="_toggle_2.8" /><label for="_toggle_2.8"></label><ol><li><a href="#sec-Type-Conditions-"><span class="spec-secid">2.8.1</span>Type Conditions/类型条件</a></li><li><a href="#sec-Inline-Fragments-"><span class="spec-secid">2.8.2</span>Inline Fragments/内联片段</a></li></ol></li><li><a href="#sec-Input-Values-"><span class="spec-secid">2.9</span>Input Values/输入值</a><input hidden class="toggle" type="checkbox" checked id="_toggle_2.9" /><label for="_toggle_2.9"></label><ol><li><a href="#sec-Int-Value-"><span class="spec-secid">2.9.1</span>Int Value/整数值</a></li><li><a href="#sec-Float-Value-"><span class="spec-secid">2.9.2</span>Float Value/浮点值</a></li><li><a href="#sec-Boolean-Value-"><span class="spec-secid">2.9.3</span>Boolean Value/布尔值</a></li><li><a href="#sec-String-Value-"><span class="spec-secid">2.9.4</span>String Value/字符串值</a></li><li><a href="#sec-Null-Value-"><span class="spec-secid">2.9.5</span>Null Value/空值</a></li><li><a href="#sec-Enum-Value-"><span class="spec-secid">2.9.6</span>Enum Value/枚举值</a></li><li><a href="#sec-List-Value-"><span class="spec-secid">2.9.7</span>List Value/列表值</a></li><li><a href="#sec-Input-Object-Values-"><span class="spec-secid">2.9.8</span>Input Object Values/输入型对象值</a></li></ol></li><li><a href="#sec-Language-.Variables-"><span class="spec-secid">2.10</span>Variables/变量</a></li><li><a href="#sec-Input-Types-"><span class="spec-secid">2.11</span>Input Types/输入类型</a></li><li><a href="#sec-Language-.Directives-"><span class="spec-secid">2.12</span>Directives/指令</a></li></ol></li><li><a href="#sec-Type-System-"><span class="spec-secid">3</span>Type System/类型系统</a><input hidden class="toggle" type="checkbox" checked id="_toggle_3" /><label for="_toggle_3"></label><ol><li><a href="#sec-Types-"><span class="spec-secid">3.1</span>Types/类型</a><input hidden class="toggle" type="checkbox" checked id="_toggle_3.1" /><label for="_toggle_3.1"></label><ol><li><a href="#sec-Scalars-"><span class="spec-secid">3.1.1</span>Scalars/标量</a><input hidden class="toggle" type="checkbox" checked id="_toggle_3.1.1" /><label for="_toggle_3.1.1"></label><ol><li><a href="#sec-Int-"><span class="spec-secid">3.1.1.1</span>Int/整数型</a></li><li><a href="#sec-Float-"><span class="spec-secid">3.1.1.2</span>Float/浮点型</a></li><li><a href="#sec-String-"><span class="spec-secid">3.1.1.3</span>String/字符串型</a></li><li><a href="#sec-Boolean-"><span class="spec-secid">3.1.1.4</span>Boolean/布尔型</a></li><li><a href="#sec-ID"><span class="spec-secid">3.1.1.5</span>ID</a></li></ol></li><li><a href="#sec-Objects-"><span class="spec-secid">3.1.2</span>Objects/对象</a><input hidden class="toggle" type="checkbox" checked id="_toggle_3.1.2" /><label for="_toggle_3.1.2"></label><ol><li><a href="#sec-Object-Field-Arguments-"><span class="spec-secid">3.1.2.1</span>Object Field Arguments/对象字段参数</a></li><li><a href="#sec-Object-Field-deprecation-"><span class="spec-secid">3.1.2.2</span>Object Field deprecation/对象字段弃用</a></li><li><a href="#sec-Object-type-validation-"><span class="spec-secid">3.1.2.3</span>Object type validation/对象类型验证</a></li></ol></li><li><a href="#sec-Interfaces-"><span class="spec-secid">3.1.3</span>Interfaces/接口</a><input hidden class="toggle" type="checkbox" checked id="_toggle_3.1.3" /><label for="_toggle_3.1.3"></label><ol><li><a href="#sec-Interface-type-validation-"><span class="spec-secid">3.1.3.1</span>Interface type validation/接口类型验证</a></li></ol></li><li><a href="#sec-Unions-"><span class="spec-secid">3.1.4</span>Unions/联合</a><input hidden class="toggle" type="checkbox" checked id="_toggle_3.1.4" /><label for="_toggle_3.1.4"></label><ol><li><a href="#sec-Union-type-validation-"><span class="spec-secid">3.1.4.1</span>Union type validation/联合类型验证</a></li></ol></li><li><a href="#sec-Enums-"><span class="spec-secid">3.1.5</span>Enums/枚举型</a></li><li><a href="#sec-Input-Objects-"><span class="spec-secid">3.1.6</span>Input Objects/输入对象</a><input hidden class="toggle" type="checkbox" checked id="_toggle_3.1.6" /><label for="_toggle_3.1.6"></label><ol><li><a href="#sec-Input-Object-type-validation-"><span class="spec-secid">3.1.6.1</span>Input Object type validation/输入对象类型验证</a></li></ol></li><li><a href="#sec-Lists-"><span class="spec-secid">3.1.7</span>Lists/列表型</a></li><li><a href="#sec-Types-.Non-Null-"><span class="spec-secid">3.1.8</span>Non-Null/非空型</a></li></ol></li><li><a href="#sec-Type-System-.Directives-"><span class="spec-secid">3.2</span>Directives/指令</a><input hidden class="toggle" type="checkbox" checked id="_toggle_3.2" /><label for="_toggle_3.2"></label><ol><li><a href="#sec--skip"><span class="spec-secid">3.2.1</span>@skip</a></li><li><a href="#sec--include"><span class="spec-secid">3.2.2</span>@include</a></li></ol></li><li><a href="#sec-Initial-types-"><span class="spec-secid">3.3</span>Initial types/初始类型</a></li></ol></li><li><a href="#sec-Introspection-"><span class="spec-secid">4</span>Introspection/内省</a><input hidden class="toggle" type="checkbox" checked id="_toggle_4" /><label for="_toggle_4"></label><ol><li><a href="#sec-General-Principles-"><span class="spec-secid">4.1</span>General Principles/基本原则</a><input hidden class="toggle" type="checkbox" checked id="_toggle_4.1" /><label for="_toggle_4.1"></label><ol><li><a href="#sec-Naming-conventions-"><span class="spec-secid">4.1.1</span>Naming conventions/命名约定</a></li><li><a href="#sec-Documentation-"><span class="spec-secid">4.1.2</span>Documentation/文档</a></li><li><a href="#sec-Deprecation-"><span class="spec-secid">4.1.3</span>Deprecation/弃用</a></li><li><a href="#sec-Type-Name-Introspection-"><span class="spec-secid">4.1.4</span>Type Name Introspection/类型命名内省</a></li></ol></li><li><a href="#sec-Schema-Introspection-Schema-"><span class="spec-secid">4.2</span>Schema Introspection/Schema内省</a><input hidden class="toggle" type="checkbox" checked id="_toggle_4.2" /><label for="_toggle_4.2"></label><ol><li><a href="#sec-The-__Type-Type-__Type-"><span class="spec-secid">4.2.1</span>The __Type Type/__Type类型</a></li><li><a href="#sec-Type-Kinds-"><span class="spec-secid">4.2.2</span>Type Kinds/类型种类</a><input hidden class="toggle" type="checkbox" checked id="_toggle_4.2.2" /><label for="_toggle_4.2.2"></label><ol><li><a href="#sec-Scalar-"><span class="spec-secid">4.2.2.1</span>Scalar/标量</a></li><li><a href="#sec-Object-"><span class="spec-secid">4.2.2.2</span>Object/对象</a></li><li><a href="#sec-Union-"><span class="spec-secid">4.2.2.3</span>Union/联合</a></li><li><a href="#sec-Interface-"><span class="spec-secid">4.2.2.4</span>Interface/接口</a></li><li><a href="#sec-Enum-"><span class="spec-secid">4.2.2.5</span>Enum/枚举型</a></li><li><a href="#sec-Input-Object-"><span class="spec-secid">4.2.2.6</span>Input Object/输入对象</a></li><li><a href="#sec-List-"><span class="spec-secid">4.2.2.7</span>List/列表</a></li><li><a href="#sec-Type-Kinds-.Non-Null-"><span class="spec-secid">4.2.2.8</span>Non-Null/非空</a></li><li><a href="#sec-Combining-List-and-Non-Null-"><span class="spec-secid">4.2.2.9</span>Combining List and Non-Null/列表和非空的组合</a></li></ol></li><li><a href="#sec-The-__Field-Type-__Field-"><span class="spec-secid">4.2.3</span>The __Field Type/__Field类型</a></li><li><a href="#sec-The-__InputValue-Type-__InputValue-"><span class="spec-secid">4.2.4</span>The __InputValue Type/__InputValue类型</a></li><li><a href="#sec-The-__EnumValue-Type-__EnumValue-"><span class="spec-secid">4.2.5</span>The __EnumValue Type/__EnumValue类型</a></li><li><a href="#sec-The-__Directive-Type-__Directive-"><span class="spec-secid">4.2.6</span>The __Directive Type/__Directive类型</a></li></ol></li></ol></li><li><a href="#sec-Validation-"><span class="spec-secid">5</span>Validation/验证</a><input hidden class="toggle" type="checkbox" checked id="_toggle_5" /><label for="_toggle_5"></label><ol><li><a href="#sec-Validation-.Operations-"><span class="spec-secid">5.1</span>Operations/操作</a><input hidden class="toggle" type="checkbox" checked id="_toggle_5.1" /><label for="_toggle_5.1"></label><ol><li><a href="#sec-Named-Operation-Definitions-"><span class="spec-secid">5.1.1</span>Named Operation Definitions/具名操作定义</a><input hidden class="toggle" type="checkbox" checked id="_toggle_5.1.1" /><label for="_toggle_5.1.1"></label><ol><li><a href="#sec-Operation-Name-Uniqueness-"><span class="spec-secid">5.1.1.1</span>Operation Name Uniqueness/操作名唯一性</a></li></ol></li><li><a href="#sec-Anonymous-Operation-Definitions-"><span class="spec-secid">5.1.2</span>Anonymous Operation Definitions/匿名操作定义</a><input hidden class="toggle" type="checkbox" checked id="_toggle_5.1.2" /><label for="_toggle_5.1.2"></label><ol><li><a href="#sec-Lone-Anonymous-Operation-"><span class="spec-secid">5.1.2.1</span>Lone Anonymous Operation/单独匿名操作</a></li></ol></li><li><a href="#sec-Subscription-Operation-Definitions-"><span class="spec-secid">5.1.3</span>Subscription Operation Definitions/订阅操作定义</a><input hidden class="toggle" type="checkbox" checked id="_toggle_5.1.3" /><label for="_toggle_5.1.3"></label><ol><li><a href="#sec-Single-root-field-"><span class="spec-secid">5.1.3.1</span>Single root field/单个根级字段</a></li></ol></li></ol></li><li><a href="#sec-Validation-.Fields-"><span class="spec-secid">5.2</span>Fields/字段</a><input hidden class="toggle" type="checkbox" checked id="_toggle_5.2" /><label for="_toggle_5.2"></label><ol><li><a href="#sec-Field-Selections-on-Objects-Interfaces-and-Unions-Types-"><span class="spec-secid">5.2.1</span>Field Selections on Objects, Interfaces, and Unions Types/对象、接口和联合上的字段选择</a></li><li><a href="#sec-Field-Selection-Merging-"><span class="spec-secid">5.2.2</span>Field Selection Merging/字段选择合并</a></li><li><a href="#sec-Leaf-Field-Selections-"><span class="spec-secid">5.2.3</span>Leaf Field Selections/叶子节点选择</a></li></ol></li><li><a href="#sec-Validation-.Arguments-"><span class="spec-secid">5.3</span>Arguments/参数</a><input hidden class="toggle" type="checkbox" checked id="_toggle_5.3" /><label for="_toggle_5.3"></label><ol><li><a href="#sec-Argument-Names-"><span class="spec-secid">5.3.1</span>Argument Names/参数名</a></li><li><a href="#sec-Argument-Uniqueness-"><span class="spec-secid">5.3.2</span>Argument Uniqueness/参数唯一性</a></li><li><a href="#sec-Argument-Values-Type-Correctness-"><span class="spec-secid">5.3.3</span>Argument Values Type Correctness/参数值类型正确性</a><input hidden class="toggle" type="checkbox" checked id="_toggle_5.3.3" /><label for="_toggle_5.3.3"></label><ol><li><a href="#sec-Compatible-Values-"><span class="spec-secid">5.3.3.1</span>Compatible Values/兼容值</a></li><li><a href="#sec-Required-Non-Null-Arguments-"><span class="spec-secid">5.3.3.2</span>Required Non-Null Arguments/必要非空参数</a></li></ol></li></ol></li><li><a href="#sec-Validation-.Fragments-"><span class="spec-secid">5.4</span>Fragments/片段</a><input hidden class="toggle" type="checkbox" checked id="_toggle_5.4" /><label for="_toggle_5.4"></label><ol><li><a href="#sec-Fragment-Declarations-"><span class="spec-secid">5.4.1</span>Fragment Declarations/片段声明</a><input hidden class="toggle" type="checkbox" checked id="_toggle_5.4.1" /><label for="_toggle_5.4.1"></label><ol><li><a href="#sec-Fragment-Name-Uniqueness-"><span class="spec-secid">5.4.1.1</span>Fragment Name Uniqueness/片段名唯一性</a></li><li><a href="#sec-Fragment-Spread-Type-Existence-"><span class="spec-secid">5.4.1.2</span>Fragment Spread Type Existence/片段解构类型存在性</a></li><li><a href="#sec-Fragments-On-Composite-Types-"><span class="spec-secid">5.4.1.3</span>Fragments On Composite Types/组合类型上的片段</a></li><li><a href="#sec-Fragments-Must-Be-Used-"><span class="spec-secid">5.4.1.4</span>Fragments Must Be Used/必须使用的片段</a></li></ol></li><li><a href="#sec-Fragment-Spreads-"><span class="spec-secid">5.4.2</span>Fragment Spreads/片段解构</a><input hidden class="toggle" type="checkbox" checked id="_toggle_5.4.2" /><label for="_toggle_5.4.2"></label><ol><li><a href="#sec-Fragment-spread-target-defined-"><span class="spec-secid">5.4.2.1</span>Fragment spread target defined/片段解构目标必须预先定义</a></li><li><a href="#sec-Fragment-spreads-must-not-form-cycles-"><span class="spec-secid">5.4.2.2</span>Fragment spreads must not form cycles/片段解构不可造成循环</a></li><li><a href="#sec-Fragment-spread-is-possible-"><span class="spec-secid">5.4.2.3</span>Fragment spread is possible/片段结构必须可行</a><input hidden class="toggle" type="checkbox" checked id="_toggle_5.4.2.3" /><label for="_toggle_5.4.2.3"></label><ol><li><a href="#sec-Object-Spreads-In-Object-Scope-"><span class="spec-secid">5.4.2.3.1</span>Object Spreads In Object Scope/对象范围内的对象解构</a></li><li><a href="#sec-Abstract-Spreads-in-Object-Scope-"><span class="spec-secid">5.4.2.3.2</span>Abstract Spreads in Object Scope/对象范围内的抽象解构</a></li><li><a href="#sec-Object-Spreads-In-Abstract-Scope-"><span class="spec-secid">5.4.2.3.3</span>Object Spreads In Abstract Scope/抽象范围内的对象解构</a></li><li><a href="#sec-Abstract-Spreads-in-Abstract-Scope-"><span class="spec-secid">5.4.2.3.4</span>Abstract Spreads in Abstract Scope/抽象范围内的抽象解构</a></li></ol></li></ol></li></ol></li><li><a href="#sec-Values-"><span class="spec-secid">5.5</span>Values/值</a><input hidden class="toggle" type="checkbox" checked id="_toggle_5.5" /><label for="_toggle_5.5"></label><ol><li><a href="#sec-Input-Object-Field-Uniqueness-"><span class="spec-secid">5.5.1</span>Input Object Field Uniqueness/输入对象字段唯一性</a></li></ol></li><li><a href="#sec-Validation-.Directives-"><span class="spec-secid">5.6</span>Directives/指令</a><input hidden class="toggle" type="checkbox" checked id="_toggle_5.6" /><label for="_toggle_5.6"></label><ol><li><a href="#sec-Directives-Are-Defined-"><span class="spec-secid">5.6.1</span>Directives Are Defined/指令必须预先定义</a></li><li><a href="#sec-Directives-Are-In-Valid-Locations-"><span class="spec-secid">5.6.2</span>Directives Are In Valid Locations/指令必须在有效位置</a></li><li><a href="#sec-Directives-Are-Unique-Per-Location-"><span class="spec-secid">5.6.3</span>Directives Are Unique Per Location/每个位置的指令都必须唯一</a></li></ol></li><li><a href="#sec-Validation-.Variables-"><span class="spec-secid">5.7</span>Variables/变量</a><input hidden class="toggle" type="checkbox" checked id="_toggle_5.7" /><label for="_toggle_5.7"></label><ol><li><a href="#sec-Variable-Uniqueness-"><span class="spec-secid">5.7.1</span>Variable Uniqueness/变量唯一性</a></li><li><a href="#sec-Variable-Default-Values-Are-Correctly-Typed-"><span class="spec-secid">5.7.2</span>Variable Default Values Are Correctly Typed/变量默认值必须是正确的类型</a></li><li><a href="#sec-Variables-Are-Input-Types-"><span class="spec-secid">5.7.3</span>Variables Are Input Types/变量必须是输入类型</a></li><li><a href="#sec-All-Variable-Uses-Defined-"><span class="spec-secid">5.7.4</span>All Variable Uses Defined/所有变量的使用必须预先定义</a></li><li><a href="#sec-All-Variables-Used-"><span class="spec-secid">5.7.5</span>All Variables Used/所有变量都必须被使用</a></li><li><a href="#sec-All-Variable-Usages-are-Allowed-"><span class="spec-secid">5.7.6</span>All Variable Usages are Allowed/所有变量都允许使用</a></li></ol></li></ol></li><li><a href="#sec-Execution-"><span class="spec-secid">6</span>Execution/执行</a><input hidden class="toggle" type="checkbox" checked id="_toggle_6" /><label for="_toggle_6"></label><ol><li><a href="#sec-Executing-Requests-"><span class="spec-secid">6.1</span>Executing Requests/执行请求</a><input hidden class="toggle" type="checkbox" checked id="_toggle_6.1" /><label for="_toggle_6.1"></label><ol><li><a href="#sec-Validating-Requests-"><span class="spec-secid">6.1.1</span>Validating Requests/验证请求</a></li><li><a href="#sec-Coercing-Variable-Values-"><span class="spec-secid">6.1.2</span>Coercing Variable Values/转换变量值</a></li></ol></li><li><a href="#sec-Executing-Operations-"><span class="spec-secid">6.2</span>Executing Operations/执行操作</a><input hidden class="toggle" type="checkbox" checked id="_toggle_6.2" /><label for="_toggle_6.2"></label><ol><li><a href="#sec-Query-"><span class="spec-secid">6.2.1</span>Query/查询</a></li><li><a href="#sec-Mutation-"><span class="spec-secid">6.2.2</span>Mutation/更改</a></li><li><a href="#sec-Subscription-"><span class="spec-secid">6.2.3</span>Subscription/订阅</a><input hidden class="toggle" type="checkbox" checked id="_toggle_6.2.3" /><label for="_toggle_6.2.3"></label><ol><li><a href="#sec-Source-Stream-"><span class="spec-secid">6.2.3.1</span>Source Stream/源流</a></li><li><a href="#sec-Response-Stream-"><span class="spec-secid">6.2.3.2</span>Response Stream/响应流</a></li><li><a href="#sec-Unsubscribe-"><span class="spec-secid">6.2.3.3</span>Unsubscribe/退订</a></li></ol></li></ol></li><li><a href="#sec-Executing-Selection-Sets-"><span class="spec-secid">6.3</span>Executing Selection Sets/执行选择集</a><input hidden class="toggle" type="checkbox" checked id="_toggle_6.3" /><label for="_toggle_6.3"></label><ol><li><a href="#sec-Normal-and-Serial-Execution-"><span class="spec-secid">6.3.1</span>Normal and Serial Execution/正常序列执行</a></li><li><a href="#sec-Field-Collection-"><span class="spec-secid">6.3.2</span>Field Collection/字段集合</a></li></ol></li><li><a href="#sec-Executing-Fields-"><span class="spec-secid">6.4</span>Executing Fields/执行字段</a><input hidden class="toggle" type="checkbox" checked id="_toggle_6.4" /><label for="_toggle_6.4"></label><ol><li><a href="#sec-Coercing-Field-Arguments-"><span class="spec-secid">6.4.1</span>Coercing Field Arguments/转换字段参数</a></li><li><a href="#sec-Value-Resolution-"><span class="spec-secid">6.4.2</span>Value Resolution/值解析</a></li><li><a href="#sec-Value-Completion-"><span class="spec-secid">6.4.3</span>Value Completion/值完成</a></li><li><a href="#sec-Errors-and-Non-Nullability-"><span class="spec-secid">6.4.4</span>Errors and Non-Nullability/错误与非空</a></li></ol></li></ol></li><li><a href="#sec-Response-"><span class="spec-secid">7</span>Response/响应</a><input hidden class="toggle" type="checkbox" checked id="_toggle_7" /><label for="_toggle_7"></label><ol><li><a href="#sec-Serialization-Format-"><span class="spec-secid">7.1</span>Serialization Format/序列化格式</a><input hidden class="toggle" type="checkbox" checked id="_toggle_7.1" /><label for="_toggle_7.1"></label><ol><li><a href="#sec-JSON-Serialization-JSON-"><span class="spec-secid">7.1.1</span>JSON Serialization/JSON序列化</a></li></ol></li><li><a href="#sec-Response-Format-"><span class="spec-secid">7.2</span>Response Format/响应格式</a><input hidden class="toggle" type="checkbox" checked id="_toggle_7.2" /><label for="_toggle_7.2"></label><ol><li><a href="#sec-Data-"><span class="spec-secid">7.2.1</span>Data/数据</a></li><li><a href="#sec-Errors-"><span class="spec-secid">7.2.2</span>Errors/错误</a></li></ol></li></ol></li><li><a href="#sec-Appendix-Notation-Conventions-A-"><span class="spec-secid">A</span>Appendix: Notation Conventions/A.附录：符号约定</a><input hidden class="toggle" type="checkbox" checked id="_toggle_A" /><label for="_toggle_A"></label><ol><li><a href="#sec-Context-Free-Grammar-"><span class="spec-secid">A.1</span>Context-Free Grammar/无上下文的语法</a></li><li><a href="#sec-Lexical-and-Syntactical-Grammar-"><span class="spec-secid">A.2</span>Lexical and Syntactical Grammar/词句上的语法</a></li><li><a href="#sec-Grammar-Notation-"><span class="spec-secid">A.3</span>Grammar Notation/语法符号</a></li><li><a href="#sec-Grammar-Semantics-"><span class="spec-secid">A.4</span>Grammar Semantics/语法语义</a></li><li><a href="#sec-Algorithms-"><span class="spec-secid">A.5</span>Algorithms/算法</a></li></ol></li><li><a href="#sec-Appendix-Grammar-Summary-A-"><span class="spec-secid">B</span>Appendix: Grammar Summary/A.附录：语法总结</a><input hidden class="toggle" type="checkbox" checked id="_toggle_B" /><label for="_toggle_B"></label><ol><li><a href="#sec-Appendix-Grammar-Summary-A-.Ignored-Tokens-"><span class="spec-secid">B.1</span>Ignored Tokens/忽略符号</a></li><li><a href="#sec-Appendix-Grammar-Summary-A-.Lexical-Tokens-"><span class="spec-secid">B.2</span>Lexical Tokens/词法符号</a></li><li><a href="#sec-Appendix-Grammar-Summary-A-.Query-Document-"><span class="spec-secid">B.3</span>Query Document/查询文档</a></li></ol></li></ol></div></header><section id="sec-Overview-" secid="1"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Overview-">1</a></span>Overview/概览</h2><p>GraphQL语言致力于提供一种直观的弹性语法系统，用以描述客户端程序设计时的数据需求以及数据交互行为。</p><p>例如，下面这个GraphQL请求将会从Facebook的GraphQL实现中获取id为4的用户的名字。</p><pre><code>{
  user(id: 4) {
    name
  }
}
</code></pre><p>将会产生如下JSON数据：</p><pre><code>{
  <span class="hljs-attr">"user"</span>: {
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Mark Zuckerberg"</span>
  }
}
</code></pre><p>GraphQL并不能像编程语言一样执行任意计算，但能针对具有本规范所述能力的应用服务器进行查询。GraphQL的实现并不要求应用服务器使用特定的编程语言或者存储系统，而是只需要应用服务器将他们的能力映射为符合GraphQL编码原理的统一语言和类型系统。这样既为产品开发提供了友好的统一接口，又为工具建设提供了强大平台。</p><p>GraphQL有若干设计原则：</p><ul><li><strong>层次分明</strong>：今时今日的大部分产品开发都涉及到创建和操作视图层次。为了满足应用结构的层次性，每个GraphQL查询也是层次构建的，每个查询和其数据共用了相同的形状，这样的方式在描述数据需求上更为直观。</li><li><strong>以产品为中心</strong>：不可置辩的说，GraphQL是一种视图需求驱动的语言，因为主要是前端工程师书写它。GraphQL从前端工程师的思想和需求出发，再开发了语言和运行时库以满足这些需求。 </li><li><strong>强类型</strong>：每个GraphQL服务器都会构建一个针对应用的类型系统，查询语句就在这个类型系统上下文中执行。对于一个查询语句，GraphQL工具可以在执行以前通过类型系统检查这个查询语句的语法正确性和查询有效性，譬如在开发期，服务器就能保证返回值的形状和特性。</li><li><strong>客户端定制</strong>：通过类型系统，GraphQL向客户端通告了自己那些可以被消费的能力。而客户端则专注于如何消费这些能力，其查询语句的粒度是字段级的。在大多数没有GraphQL的CS模型应用中，不同的服务端用不同的脚本和入口决定了返回的数据。而GraphQL查询则会返回客户端要求的数据，不多不少。</li><li><strong>内省</strong>：GraphQL是内省的，一个GraphQL服务器的类型系统必须能用GraphQL语言自身来查询，本规范将后文描述此特性。GraphQL的内省特性使之能成为建造通用工具和客户端库的强大平台。</li></ul><p>基于这些原则，GraphQL在建造客户端应用的时候就成了强大的生产环境。产品开发者和设计师在高质量工具的支撑下，无需阅读大量文档，只需一点或者无需正式训练就能根据GraphQL服务器建造客户端。当然为了完成这个目的，这些服务器和工具的建造者也必不可少。</p><p>下文的正式规范即作为这些建造者的参考指南，其描述了语言以及语法，接受查询的类型系统以及内省系统，执行引擎以及验证引擎的算法。本规范的目标是为GraphQL工具、客户端库、服务端实现提供了生态所需的基础和框架，无论组织还是平台，我们都希望和社区通力合作以完成上述目标。 </p></section><section id="sec-Language-" secid="2"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Language-">2</a></span>Language/语言</h2><p>客户端使用GraphQL查询语言来请求GraphQL服务，我们称这些请求为文档，文档包含操作（queries/查询，mutations/更改，和subscriptions订阅）和片段（用于组合重用的共有单元）。</p><p>GraphQL文档的语法中，将终端符号视为记号，即独立词法单元。这些记号以词法方式定义，满足源字符模式（用<code>::</code>定义）。<small>译者案：翻译中使用&rarr;表示</small></p><section id="sec-Source-Text-" secid="2.1"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Source-Text-">2.1</a></span>Source Text/源文本</h3><div class="spec-production d2" id="SourceCharacter"><span class="spec-nt"><a href="#SourceCharacter">SourceCharacter</a></span><div class="spec-rhs"><span class="spec-rx">/[\u0009\u000A\u000D\u0020-\uFFFF]/</span></div></div><p>源字符 &rarr; /[\u0009\u000A\u000D\u0020-\uFFFF]/</p><p>GraphQL文档可表示为一序列的<a href="http://unicode.org/standard/standard.html">Unicode</a>（统一码）字符，然而，除了少许例外，大部分GraphQL文档都是用ASCII非控制字符来表示，以便于尽量兼容已有工具、语言和序列化格式，并尽可能避免在编辑器和源代码管理的显示问题。</p><section id="sec-Unicode-" secid="2.1.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Unicode-">2.1.1</a></span>Unicode/统一码</h4><div class="spec-production d2" id="UnicodeBOM"><span class="spec-nt"><a href="#UnicodeBOM">UnicodeBOM</a></span><div class="spec-rhs"><span class="spec-prose">Byte Order Mark (U+FEFF)</span></div></div><p>UnicodeBOM &rarr; &ldquo;字节顺序标记(U+FEFF)&rdquo;</p><p>GraphQL的<span class="spec-nt"><a href="#StringValue">StringValue</a></span>（字符串值）和<span class="spec-nt"><a href="#Comment">Comment</a></span>（备注）中可以使用非ASCII的Unicode字符。</p><p>BOM，又称字节顺序标记，是一个特殊的Unicode字符，它出现在文件的头部，以便程序用以确认当前文本流是Unicode编码，使用了大端还是小端，该用哪一种Unicode编码来转义。</p></section><section id="sec-White-Space-" secid="2.1.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-White-Space-">2.1.2</a></span>White Space/空白符</h4><div class="spec-production d2" id="WhiteSpace"><span class="spec-nt"><a href="#WhiteSpace">WhiteSpace</a></span><div class="spec-rhs"><span class="spec-prose">Horizontal Tab (U+0009)</span></div><div class="spec-rhs"><span class="spec-prose">Space (U+0020)</span></div></div><p>空白符 &rarr;</p><ul><li>&rdquo;水平制表符(U+0009)&rdquo;</li><li>&rdquo;空格(U+0020)&rdquo;</li></ul><p>空白符出现在记号的前后，作为记号分隔使用，用于提升源文本的易读性。GraphQL查询文档的空白符可能出现在<span class="spec-nt">String</span>或<span class="spec-nt"><a href="#Comment">Comment</a></span>记号中，但并不会显著影响其语义。</p><div class="spec-note">GraphQL不采用Unicode的Zs类别字符作为空白符，以避免编辑器和源代码管理工具的误读。</div></section><section id="sec-Line-Terminators-" secid="2.1.3"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Line-Terminators-">2.1.3</a></span>Line Terminators/行终止符</h4><div class="spec-production d2" id="LineTerminator"><span class="spec-nt"><a href="#LineTerminator">LineTerminator</a></span><div class="spec-rhs"><span class="spec-prose">New Line (U+000A)</span></div><div class="spec-rhs"><span class="spec-prose">Carriage Return (U+000D)</span><span class="spec-lookahead not"><span class="spec-prose">New Line (U+000A)</span></span></div><div class="spec-rhs"><span class="spec-prose">Carriage Return (U+000D)</span><span class="spec-prose">New Line (U+000A)</span></div></div><p>行终止符 &rarr;</p><ul><li>&rdquo;新行 (U+000A)&rdquo;</li><li>&rdquo;回车 (U+000D)&rdquo;</li><li>&rdquo;回车 (U+000D)&rdquo; &ldquo;新行 (U+000A)&rdquo;</li></ul><p>跟空白符类似，行终止符也是用于提升源文本的易读性，可出现在记号的前后，对GraphQL查询文档的语义无显著影响。行终止符不应该出现在其他记号之间。</p><div class="spec-note">语法报错时的行号应该由之前<span class="spec-nt"><a href="#LineTerminator">LineTerminator</a></span>（行终止符）的总数来生成。</div></section><section id="sec-Comments-" secid="2.1.4"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Comments-">2.1.4</a></span>Comments/注释</h4><div class="spec-production d2" id="Comment"><span class="spec-nt"><a href="#Comment">Comment</a></span><div class="spec-rhs"><span class="spec-t">#</span><span class="spec-nt list optional"><a href="#CommentChar">CommentChar</a><span class="spec-mods"><span class="spec-mod list">list</span><span class="spec-mod optional">opt</span></span></span></div></div><div class="spec-production d2" id="CommentChar"><span class="spec-nt"><a href="#CommentChar">CommentChar</a></span><div class="spec-rhs"><span class="spec-constrained"><span class="spec-nt"><a href="#SourceCharacter">SourceCharacter</a></span><span class="spec-butnot"><span class="spec-nt"><a href="#LineTerminator">LineTerminator</a></span></span></span></div></div><p>注释 &rarr; <code>#</code> 注释字符</p><p>注释字符 &rarr; 源字符，非行终止符</p><p>GraphQL查询文档可以包含以<span class="spec-t">#</span>开头的单行注释。</p><p>注释可使用除了<span class="spec-nt"><a href="#LineTerminator">LineTerminator</a></span>（行终止符）以外的任意Unicode字符（码点）。所以可以说，注释包含了以<span class="spec-t">#</span>开头的除行终止符以外的所有字符。</p><p>注释与空白符类似，出现在任意记号后面、行终止符前面，对GraphQL查询文档的语义无显著影响。</p></section><section id="sec-Insignificant-Commas-" secid="2.1.5"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Insignificant-Commas-">2.1.5</a></span>Insignificant Commas/无语义逗号</h4><div class="spec-production d2" id="Comma"><span class="spec-nt"><a href="#Comma">Comma</a></span><div class="spec-rhs"><span class="spec-t">,</span></div></div><p>逗号 &rarr; ,</p><p>与空白符和行终止符类似，逗号(<span class="spec-t">,</span>)也是提升源文本的易读性、分隔词法记号，对GraphQL查询文档的语法语义上也无显著影响.</p><p>无语义逗号保证了无论有误逗号，都不影响文档的解读，在其他语言中这就可能是一个用户错误。为了源代码易读性和可维护性，列表会使用行终止符和末尾逗号作为分隔符，无语义逗号也有这个样式上的用途。</p></section><section id="sec-Source-Text-.Lexical-Tokens-" secid="2.1.6"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Source-Text-.Lexical-Tokens-">2.1.6</a></span>Lexical Tokens/词法记号</h4><div class="spec-production d2" id="Token"><span class="spec-nt"><a href="#Token">Token</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Punctuator">Punctuator</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#Name">Name</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#IntValue">IntValue</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#FloatValue">FloatValue</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#StringValue">StringValue</a></span></div></div><p>记号 &rarr;</p><ul><li>标点</li><li>命名</li><li>整数值</li><li>浮点值</li><li>字符串型值</li></ul><p>一个GraphQL文档由多种独立记号组成，本规范中使用源文本Unicode字符模式来定义这些记号。</p><p>在后文GraphQL查询文档句法中，记号将作为终结符使用。</p></section><section id="sec-Source-Text-.Ignored-Tokens-" secid="2.1.7"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Source-Text-.Ignored-Tokens-">2.1.7</a></span>Ignored Tokens/无语义记号</h4><div class="spec-production d2" id="Ignored"><span class="spec-nt"><a href="#Ignored">Ignored</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#UnicodeBOM">UnicodeBOM</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#WhiteSpace">WhiteSpace</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#LineTerminator">LineTerminator</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#Comment">Comment</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#Comma">Comma</a></span></div></div><p>无语义记号 &rarr;</p><ul><li>Unicode字节顺序标记</li><li>空白符</li><li>行终止符</li><li>注释</li><li>逗号</li></ul><p>在词法记号的前后可能会出现不定量的无语义记号，包括<span class="spec-nt"><a href="#WhiteSpace">WhiteSpace</a></span>（空白符）和<span class="spec-nt"><a href="#Comment">Comment</a></span>备注。源文档的无语义区域都是无语义影响的，但是无语义字符可能以一种有影响的方式出现在源字符词法记号之间，譬如<span class="spec-nt">String</span>（字符串）可能包含空白字符。</p><p>在解析给定记号时，所有字符都不能被忽略，譬如<span class="spec-nt"><a href="#FloatValue">FloatValue</a></span>（浮点值）的字符中不允许出现空白符。 <small>(译者案：本段无力，求大神指点)</small></p></section><section id="sec-Punctuators-" secid="2.1.8"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Punctuators-">2.1.8</a></span>Punctuators/标点</h4><div class="spec-production d2" id="Punctuator"><span class="spec-nt"><a href="#Punctuator">Punctuator</a></span><div class="spec-oneof"><table><tr><td class="spec-rhs"><span class="spec-t">!</span></td><td class="spec-rhs"><span class="spec-t">$</span></td><td class="spec-rhs"><span class="spec-t">(</span></td><td class="spec-rhs"><span class="spec-t">)</span></td><td class="spec-rhs"><span class="spec-t">...</span></td><td class="spec-rhs"><span class="spec-t">:</span></td><td class="spec-rhs"><span class="spec-t">=</span></td><td class="spec-rhs"><span class="spec-t">@</span></td><td class="spec-rhs"><span class="spec-t">[</span></td><td class="spec-rhs"><span class="spec-t">]</span></td><td class="spec-rhs"><span class="spec-t">{</span></td><td class="spec-rhs"><span class="spec-t">|</span></td><td class="spec-rhs"><span class="spec-t">}</span></td></tr></table></div></div><p>标点 &rarr; ! $ ( ) ... : = @ [ ] { | } 之一</p><p>GraphQL文档使用了标点符号以描述结构，GraphQL是一种数据描述语言，而非编程语言，因此GraphQL缺乏用于描述数学表达式的标点符号。</p></section><section id="sec-Names-" secid="2.1.9"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Names-">2.1.9</a></span>Names/命名</h4><div class="spec-production d2" id="Name"><span class="spec-nt"><a href="#Name">Name</a></span><div class="spec-rhs"><span class="spec-rx">/[_A-Za-z][_0-9A-Za-z]*/</span></div></div><p>命名 &rarr; /[_A&#8208;Za&#8208;z][_0&#8208;9A&#8208;Za&#8208;z]/*</p><p>GraphQL查询文档全是命名的产物：operations（操作），fields（字段），arguments（参数），directives（指令）， fragments（片段）和variables（变量）。所有命名必须遵循以下格式：</p><p>GraphQL的命名是大小写敏感的，也就是说<code>name</code>，<code>Name</code>，和<code>NAME</code>是不同的名字，下划线也具有影响，<code>other_name</code>和<code>othername</code>也是两个不同的名字。</p><p>GraphQL的命名限制在上述<acronym>ASCII</acronym>子集内，以便支持尽可能多的其他系统。</p></section></section><section id="sec-Language-.Query-Document-" secid="2.2"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Language-.Query-Document-">2.2</a></span>Query Document/查询文档</h3><div class="spec-production" id="Document"><span class="spec-nt"><a href="#Document">Document</a></span><div class="spec-rhs"><span class="spec-nt list"><a href="#Definition">Definition</a><span class="spec-mods"><span class="spec-mod list">list</span></span></span></div></div><div class="spec-production" id="Definition"><span class="spec-nt"><a href="#Definition">Definition</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#OperationDefinition">OperationDefinition</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#FragmentDefinition">FragmentDefinition</a></span></div></div><p>文档 &rarr; 定义</p><p>定义 &rarr;</p><ul><li>操作定义</li><li>片段定义</li></ul><p>GraphQL查询文档描述了GraphQL服务收到的完整文件或者请求字符串。一个文档可以包含多个操作和片段的定义。一个查询文档只有包含操作时，服务器才能执行。但是无操作的文档也能被解析和验证，以让客户端提供单个跨文档请求。</p><p>如果一个文档只有一个操作，那这个操作可以不带命名或者以简写，省略掉query关键字和操作名。否则当一个查询文档包含多个操作时，每个操作都必须命名，并且在提交给服务器的时候，也要指明需要执行的目标操作。</p></section><section id="sec-Language-.Operations-" secid="2.3"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Language-.Operations-">2.3</a></span>Operations/操作</h3><div class="spec-production" id="OperationDefinition"><span class="spec-nt"><a href="#OperationDefinition">OperationDefinition</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#OperationType">OperationType</a></span><span class="spec-nt optional"><a href="#Name">Name</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span></span><span class="spec-nt optional"><a href="#VariableDefinitions">VariableDefinitions</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span></span><span class="spec-nt optional"><a href="#Directives">Directives</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span></span><span class="spec-nt"><a href="#SelectionSet">SelectionSet</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#SelectionSet">SelectionSet</a></span></div></div><div class="spec-production" id="OperationType"><span class="spec-nt"><a href="#OperationType">OperationType</a></span><div class="spec-oneof"><table><tr><td class="spec-rhs"><span class="spec-t">query</span></td><td class="spec-rhs"><span class="spec-t">mutation</span></td><td class="spec-rhs"><span class="spec-t">subscription</span></td></tr></table></div></div><p>操作定义 &rarr;</p><ul><li>操作类型命名？变量定义？指令？选择集合</li><li>选择集合</li></ul><p>操作类型 &rarr;</p><ul><li><code>query</code> <code>mutation</code> <code>subscription</code>之一 GraphQL做了三类操作模型：</li><li>query/查询 &ndash; 只读获取</li><li>mutation/更改 &ndash; 先写入再获取</li><li>subscription/订阅 &ndash; 一个长期请求，根据源事件获取数据</li></ul><p>每一个操作都以一个可选操作名和选择集合表示，例如这个mutation（更改）操作，对一个story点赞（like），然后获取了被点赞次数：</p><pre><code>mutation {
  likeStory(storyID: 12345) {
    story {
      likeCount
    }
  }
}
</code></pre><p><strong>Query shorthand/查询简写</strong></p><p>如果一个文档只包含一个查询操作，也不包含变量和指令，那么这个操作可以省略query关键字和操作名。例如，下面这个无名查询操作就写成了查询简写形式：</p><pre><code>{
  field
}
</code></pre><div class="spec-note">注意，后文中很多案例都会使用查询简写格式。</div></section><section id="sec-Selection-Sets-" secid="2.4"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Selection-Sets-">2.4</a></span>Selection Sets/选择集合</h3><div class="spec-production" id="SelectionSet"><span class="spec-nt"><a href="#SelectionSet">SelectionSet</a></span><div class="spec-rhs"><span class="spec-t">{</span><span class="spec-nt list"><a href="#Selection">Selection</a><span class="spec-mods"><span class="spec-mod list">list</span></span></span><span class="spec-t">}</span></div></div><div class="spec-production" id="Selection"><span class="spec-nt"><a href="#Selection">Selection</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Field">Field</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#FragmentSpread">FragmentSpread</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#InlineFragment">InlineFragment</a></span></div></div><p>选择集合 &rarr; {选择}</p><p>选择 &rarr;</p><ul><li>字段</li><li>片段解构</li><li>内联片段</li></ul><p>一个操作选择了他所需要的信息的集合，然后就会精确地得到他所要的信息，没有一点多余，避免了数据的多取或少取。</p><pre><code>{
  id
  firstName
  lastName
}
</code></pre><p>这个query/查询中，<code>id</code>，<code>firstName</code>和<code>lastName</code>字段构成了选择集合，选择集合也能包含fragment/片段的引用。</p></section><section id="sec-Language-.Fields-" secid="2.5"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Language-.Fields-">2.5</a></span>Fields/字段</h3><div class="spec-production" id="Field"><span class="spec-nt"><a href="#Field">Field</a></span><div class="spec-rhs"><span class="spec-nt optional"><a href="#Alias">Alias</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span></span><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-nt optional"><a href="#Arguments">Arguments</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span></span><span class="spec-nt optional"><a href="#Directives">Directives</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span></span><span class="spec-nt optional"><a href="#SelectionSet">SelectionSet</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span></span></div></div><p>字段 &rarr; 别名？具名参数？指令？选择集合？</p><p>一个选择集合主要由字段组成，一个字段描述了选择集合中对请求可用的一个离散信息片段。</p><p>有些字段描述了复杂的数据或者与其他数据的关联，为了进一步解明这种数据，一个字段可能包含一个选择集合，从而使能将请求嵌套起来。所有的GraphQL操作都必须依次深入嵌套，指明所有标量值字段，以保证响应数据的形态上没有歧义。</p><p>例如，这个操作选择了复杂数据和关联数据，并深入到嵌套内部，直到标量值字段。</p><pre><code>{
  me {
    id
    firstName
    lastName
    birthday {
      month
      day
    }
    friends {
      name
    }
  }
}
</code></pre><p>一个操作中，顶层选择集合的字段通常表示对应用和观察者而言全局可见的信息。典型的案例有顶层字段指向当前登录的观察者，或者引用唯一id来取特定类型数据：</p><pre><code># `me` could represent the currently logged in viewer.`me`指代当前登录的观察者
{
  me {
    name
  }
}

# `user` represents one of many users in a graph of data, referred to by a
# unique identifier.
# `user`表示一个通过id来从图数据中取出来的用户
{
  user(id: 4) {
    name
  }
}
</code></pre></section><section id="sec-Language-.Arguments-" secid="2.6"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Language-.Arguments-">2.6</a></span>Arguments/参数</h3><div class="spec-production" id="Arguments"><span class="spec-nt"><a href="#Arguments">Arguments</a></span><div class="spec-rhs"><span class="spec-t">(</span><span class="spec-nt list"><a href="#Argument">Argument</a><span class="spec-mods"><span class="spec-mod list">list</span></span></span><span class="spec-t">)</span></div></div><div class="spec-production" id="Argument"><span class="spec-nt"><a href="#Argument">Argument</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-t">:</span><span class="spec-nt"><a href="#Value">Value</a></span></div></div><p>参数 &rarr; 命名: 值</p><p>字段在概念上是会返回值的函数，偶尔接受参数以改变其行为。通常这些参数和GraphQL服务器实现的函数参数直接映射。</p><p>这个案例中，我们向查询特定用户（通过<code>id</code>参数请求）的特定尺寸档案照片（通过<code>size</code>参数）：</p><pre><code>{
  user(id: 4) {
    id
    name
    profilePic(size: 100)
  }
}
</code></pre><p>许多参数也能存在于给定字段：</p><pre><code>{
  user(id: 4) {
    id
    name
    profilePic(width: 100, height: 50)
  }
}
</code></pre><p><strong>Arguments are unordered/参数无需顺序</strong></p><p>参数可以以任意句法顺序排列，都表示同一种语义。</p><p>下列两个查询语义上都是一样的：</p><pre><code>{
  picture(width: 200, height: 100)
}
</code></pre><pre><code>{
  picture(height: 100, width: 200)
}
</code></pre></section><section id="sec-Field-Alias-" secid="2.7"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Field-Alias-">2.7</a></span>Field Alias/字段别名</h3><div class="spec-production" id="Alias"><span class="spec-nt"><a href="#Alias">Alias</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-t">:</span></div></div><p>别名 &rarr; 命名</p><p>默认情况下，返回对象的键名会采用查询的字段名，然后你可以定义不同的键名，亦即别名。</p><p>案例中，我们获取了两个不同尺寸的档案照片，并保证了返回对象没有重复键名：</p><pre><code>{
  user(id: 4) {
    id
    name
    smallPic: profilePic(size: 64)
    bigPic: profilePic(size: 1024)
  }
}
</code></pre><p>然后得到结果：</p><pre><code>{
  <span class="hljs-attr">"user"</span>: {
    <span class="hljs-attr">"id"</span>: <span class="hljs-number">4</span>,
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Mark Zuckerberg"</span>,
    <span class="hljs-attr">"smallPic"</span>: <span class="hljs-string">"https://cdn.site.io/pic-4-64.jpg"</span>,
    <span class="hljs-attr">"bigPic"</span>: <span class="hljs-string">"https://cdn.site.io/pic-4-1024.jpg"</span>
  }
}
</code></pre><p>顶级query/查询也是一个字段，所以它也可以使用别名：</p><pre><code>{
  zuck: user(id: 4) {
    id
    name
  }
}
</code></pre><p>得到这个结果：</p><pre><code>{
  <span class="hljs-attr">"zuck"</span>: {
    <span class="hljs-attr">"id"</span>: <span class="hljs-number">4</span>,
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Mark Zuckerberg"</span>
  }
}
</code></pre><p>如果使用了别名，那么返回对象的中字段的键名就是别名，否则就是字段名。</p></section><section id="sec-Language-.Fragments-" secid="2.8"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Language-.Fragments-">2.8</a></span>Fragments/片段</h3><div class="spec-production" id="FragmentSpread"><span class="spec-nt"><a href="#FragmentSpread">FragmentSpread</a></span><div class="spec-rhs"><span class="spec-t">...</span><span class="spec-nt"><a href="#FragmentName">FragmentName</a></span><span class="spec-nt optional"><a href="#Directives">Directives</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span></span></div></div><div class="spec-production" id="FragmentDefinition"><span class="spec-nt"><a href="#FragmentDefinition">FragmentDefinition</a></span><div class="spec-rhs"><span class="spec-t">fragment</span><span class="spec-nt"><a href="#FragmentName">FragmentName</a></span><span class="spec-nt"><a href="#TypeCondition">TypeCondition</a></span><span class="spec-nt optional"><a href="#Directives">Directives</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span></span><span class="spec-nt"><a href="#SelectionSet">SelectionSet</a></span></div></div><div class="spec-production" id="FragmentName"><span class="spec-nt"><a href="#FragmentName">FragmentName</a></span><div class="spec-rhs"><span class="spec-constrained"><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-butnot"><span class="spec-t">on</span></span></span></div></div><p>片段解构/展开 &rarr; ... 片段名 指令？</p><p>片段定义 &rarr; fragment 片段名 类型条件 指令？ 选择集</p><p>片段名 &rarr; 除了<code>on</code>以外的命名</p><p>片段是GraphQL组合拼装的基本单元，它通用选择集字段的重用得以实现，减少了文档中的重复文本。内联片段可以直接在选择集合内使用，通常用于interface（接口）或者union（联合）这种存在类型条件的场合。</p><p>例如，我们想要获取某个用户的朋友以及和他互为朋友的人的共通信息：</p><pre><code>query noFragments {
  user(id: 4) {
    friends(first: 10) {
      id
      name
      profilePic(size: 50)
    }
    mutualFriends(first: 10) {
      id
      name
      profilePic(size: 50)
    }
  }
}
</code></pre><p>这些重复的字段可以提取进一个fragment（片段）中，然后被父级fragment（片段）或者query（查询）组合：</p><pre><code>query withFragments {
  user(id: 4) {
    friends(first: 10) {
      ...friendFields
    }
    mutualFriends(first: 10) {
      ...friendFields
    }
  }
}

fragment friendFields on User {
  id
  name
  profilePic(size: 50)
}
</code></pre><p>片段可以通过解构操作符(<code>...</code>)被消费掉，片段内的字段将会被添加到片段被调用的同层级选择集合，这一过程也会在多级别片段中解构发生。</p><p>例如:</p><pre><code>query withNestedFragments {
  user(id: 4) {
    friends(first: 10) {
      ...friendFields
    }
    mutualFriends(first: 10) {
      ...friendFields
    }
  }
}

fragment friendFields on User {
  id
  name
  ...standardProfilePic
}

fragment standardProfilePic on User {
  profilePic(size: 50)
}
</code></pre><p><code>noFragments</code>，<code>withFragments</code>和<code>withNestedFragments</code>三个查询都会产生相同的返回对象。</p><section id="sec-Type-Conditions-" secid="2.8.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Type-Conditions-">2.8.1</a></span>Type Conditions/类型条件</h4><div class="spec-production" id="TypeCondition"><span class="spec-nt"><a href="#TypeCondition">TypeCondition</a></span><div class="spec-rhs"><span class="spec-t">on</span><span class="spec-nt"><a href="#NamedType">NamedType</a></span></div></div><p>类型条件 &rarr; on 具名类型</p><p>片段需要指定应用于的目标类型，在上述案例中，<code>friendFields</code>在查询<code>User</code>的上下文中使用。</p><p>片段不能应用于任何输入值（标量值，枚举型或者输入型对象）。</p><p>片段可应用与对象型，接口和联合。</p><p>只有在对象的具体类型和片段的应用目标类型匹配的时候，片段内的选择集合才会返回值。</p><p>譬如，下列Facebook数据模型查询：</p><pre><code>query FragmentTyping {
  profiles(handles: [&quot;zuck&quot;, &quot;cocacola&quot;]) {
    handle
    ...userFragment
    ...pageFragment
  }
}

fragment userFragment on User {
  friends {
    count
  }
}

fragment pageFragment on Page {
  likers {
    count
  }
}
</code></pre><p><code>profiles</code>根字段将会返回一个列表，其中的元素可能是<code>Page</code>或者<code>User</code>类型。当<code>profiles</code>内的对象是<code>User</code>类型时，<code>friends</code>会出现，而<code>likers</code>不会。反之当结果内的对象是<code>Page</code>时，<code>likers</code>会出现，<code>friends</code>则不会。</p><pre><code>{
  <span class="hljs-attr">"profiles"</span>: [
    {
      <span class="hljs-attr">"handle"</span>: <span class="hljs-string">"zuck"</span>,
      <span class="hljs-attr">"friends"</span>: { <span class="hljs-attr">"count"</span> : <span class="hljs-number">1234</span> }
    },
    {
      <span class="hljs-attr">"handle"</span>: <span class="hljs-string">"cocacola"</span>,
      <span class="hljs-attr">"likers"</span>: { <span class="hljs-attr">"count"</span> : <span class="hljs-number">90234512</span> }
    }
  ]
}
</code></pre></section><section id="sec-Inline-Fragments-" secid="2.8.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Inline-Fragments-">2.8.2</a></span>Inline Fragments/内联片段</h4><div class="spec-production" id="InlineFragment"><span class="spec-nt"><a href="#InlineFragment">InlineFragment</a></span><div class="spec-rhs"><span class="spec-t">...</span><span class="spec-nt optional"><a href="#TypeCondition">TypeCondition</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span></span><span class="spec-nt optional"><a href="#Directives">Directives</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span></span><span class="spec-nt"><a href="#SelectionSet">SelectionSet</a></span></div></div><p>内联/行内片段 &rarr; ... 类型条件？ 指令？ 选择集合？</p><p>片段可以在选择集合内以内联格式定义，这用于根据运行时类型条件式地引入字段。这个特性的标准片段引入版本在<code>query FragmentTyping</code>中已经演示，我们也可以使用内联片段的方式来实现：</p><pre><code>query inlineFragmentTyping {
  profiles(handles: [&quot;zuck&quot;, &quot;cocacola&quot;]) {
    handle
    ... on User {
      friends {
        count
      }
    }
    ... on Page {
      likers {
        count
      }
    }
  }
}
</code></pre><p>内联片段也用于将指令应用于一群字段的场景。如果省略了类型条件，片段则被视为等同于封装所在的上下文。</p><pre><code>query inlineFragmentNoType($expandedInfo: Boolean) {
  user(handle: &quot;zuck&quot;) {
    id
    name
    ... @include(if: $expandedInfo) {
      firstName
      lastName
      birthday
    }
  }
}
</code></pre></section></section><section id="sec-Input-Values-" secid="2.9"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Input-Values-">2.9</a></span>Input Values/输入值</h3><div class="spec-production" id="Value"><span class="spec-nt"><a href="#Value">Value</a><span class="spec-mods"><span class="spec-params"><span class="spec-param">Const</span></span></span></span><div class="spec-rhs"><span class="spec-condition not">Const</span><span class="spec-nt"><a href="#Variable">Variable</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#IntValue">IntValue</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#FloatValue">FloatValue</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#StringValue">StringValue</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#BooleanValue">BooleanValue</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#NullValue">NullValue</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#EnumValue">EnumValue</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#ListValue">ListValue</a><span class="spec-mods"><span class="spec-params"><span class="spec-param conditional">Const</span></span></span></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#ObjectValue">ObjectValue</a><span class="spec-mods"><span class="spec-params"><span class="spec-param conditional">Const</span></span></span></span></div></div><p>值 &rarr;</p><ul><li>变量</li><li>整数值</li><li>浮点值</li><li>字符串值</li><li>布尔值</li><li>空值</li><li>枚举值</li><li>列表值</li><li>对象值 字段和指令的参数接受各种原始类型的输入值，输入值可以是标量值、枚举值、列表值或者输入型对象。 如果没有定义为常量（例如，<span class="spec-nt"><a href="#DefaultValue">DefaultValue</a></span>（默认值）），输入值就可以被指定为变量，列表和输入对象也可以包含变量（除非被定义为常量）。</li></ul><section id="sec-Int-Value-" secid="2.9.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Int-Value-">2.9.1</a></span>Int Value/整数值</h4><div class="spec-production d2" id="IntValue"><span class="spec-nt"><a href="#IntValue">IntValue</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#IntegerPart">IntegerPart</a></span></div></div><div class="spec-production d2" id="IntegerPart"><span class="spec-nt"><a href="#IntegerPart">IntegerPart</a></span><div class="spec-rhs"><span class="spec-nt optional"><a href="#NegativeSign">NegativeSign</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span></span><span class="spec-t">0</span></div><div class="spec-rhs"><span class="spec-nt optional"><a href="#NegativeSign">NegativeSign</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span></span><span class="spec-nt"><a href="#NonZeroDigit">NonZeroDigit</a></span><span class="spec-nt list optional"><a href="#Digit">Digit</a><span class="spec-mods"><span class="spec-mod list">list</span><span class="spec-mod optional">opt</span></span></span></div></div><div class="spec-production d2" id="NegativeSign"><span class="spec-nt"><a href="#NegativeSign">NegativeSign</a></span><div class="spec-rhs"><span class="spec-t">-</span></div></div><div class="spec-production d2" id="Digit"><span class="spec-nt"><a href="#Digit">Digit</a></span><div class="spec-oneof"><table><tr><td class="spec-rhs"><span class="spec-t">0</span></td><td class="spec-rhs"><span class="spec-t">1</span></td><td class="spec-rhs"><span class="spec-t">2</span></td><td class="spec-rhs"><span class="spec-t">3</span></td><td class="spec-rhs"><span class="spec-t">4</span></td><td class="spec-rhs"><span class="spec-t">5</span></td><td class="spec-rhs"><span class="spec-t">6</span></td><td class="spec-rhs"><span class="spec-t">7</span></td><td class="spec-rhs"><span class="spec-t">8</span></td><td class="spec-rhs"><span class="spec-t">9</span></td></tr></table></div></div><div class="spec-production d2" id="NonZeroDigit"><span class="spec-nt"><a href="#NonZeroDigit">NonZeroDigit</a></span><div class="spec-rhs"><span class="spec-constrained"><span class="spec-nt"><a href="#Digit">Digit</a></span><span class="spec-butnot"><span class="spec-t">0</span></span></span></div></div><p>指定整数不应该使用小数点或指数符号。(譬如：<code>1</code>)</p></section><section id="sec-Float-Value-" secid="2.9.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Float-Value-">2.9.2</a></span>Float Value/浮点值</h4><div class="spec-production d2" id="FloatValue"><span class="spec-nt"><a href="#FloatValue">FloatValue</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#IntegerPart">IntegerPart</a></span><span class="spec-nt"><a href="#FractionalPart">FractionalPart</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#IntegerPart">IntegerPart</a></span><span class="spec-nt"><a href="#ExponentPart">ExponentPart</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#IntegerPart">IntegerPart</a></span><span class="spec-nt"><a href="#FractionalPart">FractionalPart</a></span><span class="spec-nt"><a href="#ExponentPart">ExponentPart</a></span></div></div><div class="spec-production d2" id="FractionalPart"><span class="spec-nt"><a href="#FractionalPart">FractionalPart</a></span><div class="spec-rhs"><span class="spec-t">.</span><span class="spec-nt list"><a href="#Digit">Digit</a><span class="spec-mods"><span class="spec-mod list">list</span></span></span></div></div><div class="spec-production d2" id="ExponentPart"><span class="spec-nt"><a href="#ExponentPart">ExponentPart</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#ExponentIndicator">ExponentIndicator</a></span><span class="spec-nt optional"><a href="#Sign">Sign</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span></span><span class="spec-nt list"><a href="#Digit">Digit</a><span class="spec-mods"><span class="spec-mod list">list</span></span></span></div></div><div class="spec-production d2" id="ExponentIndicator"><span class="spec-nt"><a href="#ExponentIndicator">ExponentIndicator</a></span><div class="spec-oneof"><table><tr><td class="spec-rhs"><span class="spec-t">e</span></td><td class="spec-rhs"><span class="spec-t">E</span></td></tr></table></div></div><div class="spec-production d2" id="Sign"><span class="spec-nt"><a href="#Sign">Sign</a></span><div class="spec-oneof"><table><tr><td class="spec-rhs"><span class="spec-t">+</span></td><td class="spec-rhs"><span class="spec-t">-</span></td></tr></table></div></div><p>指定浮点数需要包含小数点(例如：<code>1.0</code>)或者指数符号(例如：<code>1e50</code>)或者两者(例如：<code>6.0221413e23</code>)。</p></section><section id="sec-Boolean-Value-" secid="2.9.3"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Boolean-Value-">2.9.3</a></span>Boolean Value/布尔值</h4><div class="spec-production" id="BooleanValue"><span class="spec-nt"><a href="#BooleanValue">BooleanValue</a></span><div class="spec-oneof"><table><tr><td class="spec-rhs"><span class="spec-t">true</span></td><td class="spec-rhs"><span class="spec-t">false</span></td></tr></table></div></div><p><code>true</code>和<code>false</code>两个关键字表示布尔型的两个值。</p></section><section id="sec-String-Value-" secid="2.9.4"><h4><span class="spec-secid" title="link to this section"><a href="#sec-String-Value-">2.9.4</a></span>String Value/字符串值</h4><div class="spec-production d2" id="StringValue"><span class="spec-nt"><a href="#StringValue">StringValue</a></span><div class="spec-rhs"><span class="spec-t">&quot;&quot;</span></div><div class="spec-rhs"><span class="spec-t">&quot;</span><span class="spec-nt list"><a href="#StringCharacter">StringCharacter</a><span class="spec-mods"><span class="spec-mod list">list</span></span></span><span class="spec-t">&quot;</span></div></div><div class="spec-production d2" id="StringCharacter"><span class="spec-nt"><a href="#StringCharacter">StringCharacter</a></span><div class="spec-rhs"><span class="spec-constrained"><span class="spec-nt"><a href="#SourceCharacter">SourceCharacter</a></span><span class="spec-butnot"><span class="spec-t">&quot;</span><span class="spec-t">\</span><span class="spec-nt"><a href="#LineTerminator">LineTerminator</a></span></span></span></div><div class="spec-rhs"><span class="spec-t">\u</span><span class="spec-nt"><a href="#EscapedUnicode">EscapedUnicode</a></span></div><div class="spec-rhs"><span class="spec-t">\</span><span class="spec-nt"><a href="#EscapedCharacter">EscapedCharacter</a></span></div></div><div class="spec-production d2" id="EscapedUnicode"><span class="spec-nt"><a href="#EscapedUnicode">EscapedUnicode</a></span><div class="spec-rhs"><span class="spec-rx">/[0-9A-Fa-f]{4}/</span></div></div><div class="spec-production d2" id="EscapedCharacter"><span class="spec-nt"><a href="#EscapedCharacter">EscapedCharacter</a></span><div class="spec-oneof"><table><tr><td class="spec-rhs"><span class="spec-t">&quot;</span></td><td class="spec-rhs"><span class="spec-t">\</span></td><td class="spec-rhs"><span class="spec-t">/</span></td><td class="spec-rhs"><span class="spec-t">b</span></td><td class="spec-rhs"><span class="spec-t">f</span></td><td class="spec-rhs"><span class="spec-t">n</span></td><td class="spec-rhs"><span class="spec-t">r</span></td><td class="spec-rhs"><span class="spec-t">t</span></td></tr></table></div></div><p>字符串是一系列由双引号(<code>&quot;</code>)包起来的字符，譬如<code>&quot;Hello World&quot;</code>。字符串内的空白符和其他无语义字符都对字符串有影响。</p><div class="spec-note">字符串值字面量内是允许Unicode字符的，但是GraphQL源文本不允许ASCII控制符，因此如要使用这些字符，则需对其进行转义。</div><p><strong>Semantics/语义</strong></p><div class="spec-semantic d2"><span class="spec-nt"><a href="#StringValue">StringValue</a></span><div class="spec-rhs"><span class="spec-t">&quot;&quot;</span></div><ol><li>返回空Unicode字符序列。</li></ol></div><div class="spec-semantic d2"><span class="spec-nt"><a href="#StringValue">StringValue</a></span><div class="spec-rhs"><span class="spec-t">&quot;</span><span class="spec-nt list"><a href="#StringCharacter">StringCharacter</a><span class="spec-mods"><span class="spec-mod list">list</span></span></span><span class="spec-t">&quot;</span></div><ol><li>返回<span class="spec-nt"><a href="#StringCharacter">StringCharacter</a></span>的Unicode字符序列。</li></ol></div><div class="spec-semantic d2"><span class="spec-nt"><a href="#StringCharacter">StringCharacter</a></span><div class="spec-rhs"><span class="spec-constrained"><span class="spec-nt"><a href="#SourceCharacter">SourceCharacter</a></span><span class="spec-butnot"><span class="spec-t">&quot;</span><span class="spec-t">\</span><span class="spec-nt"><a href="#LineTerminator">LineTerminator</a></span></span></span></div><ol><li>返回<span class="spec-nt"><a href="#SourceCharacter">SourceCharacter</a></span>的字符值。</li></ol></div><div class="spec-semantic d2"><span class="spec-nt"><a href="#StringCharacter">StringCharacter</a></span><div class="spec-rhs"><span class="spec-t">\u</span><span class="spec-nt"><a href="#EscapedUnicode">EscapedUnicode</a></span></div><ol><li>返回<span class="spec-nt"><a href="#EscapedUnicode">EscapedUnicode</a></span>在Unicode基本多文种平面内的16进制对应代码单元。<small>译者案：详情查询Unicode字符平面映射</small></li></ol></div><div class="spec-semantic d2"><span class="spec-nt"><a href="#StringCharacter">StringCharacter</a></span><div class="spec-rhs"><span class="spec-t">\</span><span class="spec-nt"><a href="#EscapedCharacter">EscapedCharacter</a></span></div><ol><li>返回<span class="spec-nt"><a href="#EscapedCharacter">EscapedCharacter</a></span>在此对照表中的值。</li></ol></div><table><thead><tr><th>转义后字符 </th><th>字符单元值 </th><th>字符名称 </th></tr></thead><tbody><tr><td><code>&quot;</code> </td><td>U+0022 </td><td>双引号 </td></tr><tr><td><code>\</code> </td><td>U+005C </td><td>反斜线 </td></tr><tr><td><code>/</code> </td><td>U+002F </td><td>正斜线 </td></tr><tr><td><code>b</code> </td><td>U+0008 </td><td>退格 </td></tr><tr><td><code>f</code> </td><td>U+000C </td><td>换页符 </td></tr><tr><td><code>n</code> </td><td>U+000A </td><td>换行符 </td></tr><tr><td><code>r</code> </td><td>U+000D </td><td>回车符 </td></tr><tr><td><code>t</code> </td><td>U+0009 </td><td>水平制表符</td></tr></tbody></table></section><section id="sec-Null-Value-" secid="2.9.5"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Null-Value-">2.9.5</a></span>Null Value/空值</h4><div class="spec-production" id="NullValue"><span class="spec-nt"><a href="#NullValue">NullValue</a></span><div class="spec-rhs"><span class="spec-t">null</span></div></div><p><span class="spec-keyword">null</span>代表空值。</p><p>GraphQL在语义上有两种方式来表示一个缺值：</p><ul><li>显式，使用字面量值：<span class="spec-keyword">null</span>。</li><li>隐式，不使用任何值。</li></ul><p>例如：下列两个相似的字段查询并不是一样的：</p><pre><code>{
  field(arg: null)
  field
}
</code></pre><p>前者显式使用了<span class="spec-keyword">null</span>给arg参数，后者隐式，没有给arg参数以值。两个形式会被不同解读，譬如一个mutation操作中，会表示成删除一个字段或者不改变一个字段。两者都不能用于非空输入类型参数。</p><div class="spec-note">在使用变量表示一个缺值的时候，也可以使用这两种方法，亦即显式提供<span class="spec-keyword">null</span>，或者隐式，不提供任何值。</div></section><section id="sec-Enum-Value-" secid="2.9.6"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Enum-Value-">2.9.6</a></span>Enum Value/枚举值</h4><div class="spec-production" id="EnumValue"><span class="spec-nt"><a href="#EnumValue">EnumValue</a></span><div class="spec-rhs"><span class="spec-constrained"><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-butnot"><span class="spec-t">true</span><span class="spec-t">false</span><span class="spec-t">null</span></span></span></div></div><p>枚举值表现为没有引号包裹的名称，规范建议使用全大写字母表示枚举值，枚举值仅用于准确枚举类型可用的上下文中，因此枚举类型命名上不必使用字面量。</p></section><section id="sec-List-Value-" secid="2.9.7"><h4><span class="spec-secid" title="link to this section"><a href="#sec-List-Value-">2.9.7</a></span>List Value/列表值</h4><div class="spec-production" id="ListValue"><span class="spec-nt"><a href="#ListValue">ListValue</a><span class="spec-mods"><span class="spec-params"><span class="spec-param">Const</span></span></span></span><div class="spec-rhs"><span class="spec-t">[</span><span class="spec-t">]</span></div><div class="spec-rhs"><span class="spec-t">[</span><span class="spec-nt list"><a href="#Value">Value</a><span class="spec-mods"><span class="spec-params"><span class="spec-param conditional">Const</span></span><span class="spec-mod list">list</span></span></span><span class="spec-t">]</span></div></div><p>列表是包在方括号<code>[ ]</code>中的有序值序列，列表值可以是任意字面量值或者变量，譬如<code>[1, 2, 3]</code>。</p><p>因为GraphQL中逗号是可选的，因此末尾逗号和重复逗号都是允许的，而不会代表空缺值。</p><p><strong>Semantics/语义</strong></p><div class="spec-semantic"><span class="spec-nt"><a href="#ListValue">ListValue</a></span><div class="spec-rhs"><span class="spec-t">[</span><span class="spec-t">]</span></div><ol><li>返回空列表值。</li></ol></div><div class="spec-semantic"><span class="spec-nt"><a href="#ListValue">ListValue</a></span><div class="spec-rhs"><span class="spec-t">[</span><span class="spec-nt list"><a href="#Value">Value</a><span class="spec-mods"><span class="spec-mod list">list</span></span></span><span class="spec-t">]</span></div><ol><li>使<var>inputList</var>为空.</li><li>对于每一个<span class="spec-nt list"><a href="#Value">Value</a><span class="spec-mods"><span class="spec-mod list">list</span></span></span><ol><li>让<var>value</var>变成<span class="spec-nt"><a href="#Value">Value</a></span>求值后的值。</li><li>将<var>value</var>添加到<var>inputList</var>尾部。</li></ol></li><li>返回<var>inputList</var>。</li></ol></div></section><section id="sec-Input-Object-Values-" secid="2.9.8"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Input-Object-Values-">2.9.8</a></span>Input Object Values/输入型对象值</h4><div class="spec-production" id="ObjectValue"><span class="spec-nt"><a href="#ObjectValue">ObjectValue</a><span class="spec-mods"><span class="spec-params"><span class="spec-param">Const</span></span></span></span><div class="spec-rhs"><span class="spec-t">{</span><span class="spec-t">}</span></div><div class="spec-rhs"><span class="spec-t">{</span><span class="spec-nt list"><a href="#ObjectField">ObjectField</a><span class="spec-mods"><span class="spec-params"><span class="spec-param conditional">Const</span></span><span class="spec-mod list">list</span></span></span><span class="spec-t">}</span></div></div><div class="spec-production" id="ObjectField"><span class="spec-nt"><a href="#ObjectField">ObjectField</a><span class="spec-mods"><span class="spec-params"><span class="spec-param">Const</span></span></span></span><div class="spec-rhs"><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-t">:</span><span class="spec-nt"><a href="#Value">Value</a><span class="spec-mods"><span class="spec-params"><span class="spec-param conditional">Const</span></span></span></span></div></div><p>输入型对象是无需键值列表，使用花括号<code>{ }</code>包起来。对象的值可以是输入字面量值或者变量值(例如：<code>{ name: &quot;Hello world&quot;, score: 1.0 }</code>)。我们将输入型对象的字面量表示法称作&ldquo;对象字面量&rdquo;。</p><p><strong>Input object fields are unordered/输入型对象的字段是无序的</strong></p><p>输入型字段能以各种句法顺位排列，而表示相同的语义。</p><p>下面两个查询在语义上是一样的：</p><pre><code>{
  nearestThing(location: { lon: 12.43, lat: -53.211 })
}
</code></pre><pre><code>{
  nearestThing(location: { lat: -53.211, lon: 12.43 })
}
</code></pre><p><strong>Semantics/语义</strong></p><div class="spec-semantic"><span class="spec-nt"><a href="#ObjectValue">ObjectValue</a></span><div class="spec-rhs"><span class="spec-t">{</span><span class="spec-t">}</span></div><ol><li>返回一个无字段的输入型对象。</li></ol></div><div class="spec-semantic"><span class="spec-nt"><a href="#ObjectValue">ObjectValue</a></span><div class="spec-rhs"><span class="spec-t">{</span><span class="spec-nt list"><a href="#ObjectField">ObjectField</a><span class="spec-mods"><span class="spec-mod list">list</span></span></span><span class="spec-t">}</span></div><ol><li>使<var>inputObject</var>为一个无字段的输入型对象。</li><li>对于<var>inputObject</var>中的每一个<var>field</var>。<ol><li>使<var>field</var>的<span class="spec-nt"><a href="#Name">Name</a></span>为<var>name</var>。</li><li>使<var>field</var>的<span class="spec-nt"><a href="#Value">Value</a></span>为<var>value</var>求值后的值。</li><li>给<var>inputObject</var>添加一个字段，键为<var>name</var>，值为<var>value</var>。</li></ol></li><li>返回<var>inputObject</var></li></ol></div></section></section><section id="sec-Language-.Variables-" secid="2.10"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Language-.Variables-">2.10</a></span>Variables/变量</h3><div class="spec-production" id="Variable"><span class="spec-nt"><a href="#Variable">Variable</a></span><div class="spec-rhs"><span class="spec-t">$</span><span class="spec-nt"><a href="#Name">Name</a></span></div></div><div class="spec-production" id="VariableDefinitions"><span class="spec-nt"><a href="#VariableDefinitions">VariableDefinitions</a></span><div class="spec-rhs"><span class="spec-t">(</span><span class="spec-nt list"><a href="#VariableDefinition">VariableDefinition</a><span class="spec-mods"><span class="spec-mod list">list</span></span></span><span class="spec-t">)</span></div></div><div class="spec-production" id="VariableDefinition"><span class="spec-nt"><a href="#VariableDefinition">VariableDefinition</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Variable">Variable</a></span><span class="spec-t">:</span><span class="spec-nt"><a href="#Type">Type</a></span><span class="spec-nt optional"><a href="#DefaultValue">DefaultValue</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span></span></div></div><div class="spec-production" id="DefaultValue"><span class="spec-nt"><a href="#DefaultValue">DefaultValue</a></span><div class="spec-rhs"><span class="spec-t">=</span><span class="spec-nt"><a href="#Value">Value</a><span class="spec-mods"><span class="spec-params"><span class="spec-param">Const</span></span></span></span></div></div><p>变量 &rarr; $ 名称</p><p>变量定义 &rarr; 变量：类型 默认值？</p><p>默认值 &rarr; 值<small>常量</small></p><p>GraphQL查询可以使用变量作为参数，已最大化查询重用，避免客户端运行时耗费巨大的字符串重建。</p><p>如果没有被定义为常量（例如<span class="spec-nt"><a href="#DefaultValue">DefaultValue</a></span>），<span class="spec-nt"><a href="#Variable">Variable</a></span>就能被赋予一个输入类型。</p><p>变量必须在查询的顶部定义，并在整个操作的执行周期范围内可用。</p><p>下面例子中，我们想要根据特定设备大小获取一个对应大小的档案图片：</p><pre><code>query getZuckProfile($devicePicSize: Int) {
  user(id: 4) {
    id
    name
    profilePic(size: $devicePicSize)
  }
}
</code></pre><p>在向GraphQL请求的时候，这些参数的值也需要一并发送，以便执行期间用以替换。假设以JSON发送参数，我们请求大小为<code>60</code>宽度的档案照片：</p><pre><code>{
  <span class="hljs-attr">"devicePicSize"</span>: <span class="hljs-number">60</span>
}
</code></pre><p><strong>Variable use within Fragments/片段内的参数</strong></p><p>片段内也可以使用查询变量，变量在整个操作中拥有全局作用域，所以片段内变量也需要在顶部操作上定义，以便传递到片段上消费。如果一个参数被片段所引用，包含这个片段的操作并没有定义这个变量，那么这个操作将不会被执行。</p></section><section id="sec-Input-Types-" secid="2.11"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Input-Types-">2.11</a></span>Input Types/输入类型</h3><div class="spec-production" id="Type"><span class="spec-nt"><a href="#Type">Type</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#NamedType">NamedType</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#ListType">ListType</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#NonNullType">NonNullType</a></span></div></div><div class="spec-production" id="NamedType"><span class="spec-nt"><a href="#NamedType">NamedType</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Name">Name</a></span></div></div><div class="spec-production" id="ListType"><span class="spec-nt"><a href="#ListType">ListType</a></span><div class="spec-rhs"><span class="spec-t">[</span><span class="spec-nt"><a href="#Type">Type</a></span><span class="spec-t">]</span></div></div><div class="spec-production" id="NonNullType"><span class="spec-nt"><a href="#NonNullType">NonNullType</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#NamedType">NamedType</a></span><span class="spec-t">!</span></div><div class="spec-rhs"><span class="spec-nt"><a href="#ListType">ListType</a></span><span class="spec-t">!</span></div></div><p>类型 &rarr;</p><ul><li>具名类型</li><li>列表类型</li><li>非空类型 具名类型 &rarr; 命名</li></ul><p>列表类型 &rarr; [ 类型 ]</p><p>非空类型 &rarr;</p><ul><li>具名类型! </li><li>列表类型!</li></ul><p>GraphQL描述查询参数需要的类型为输入类型，可以是某种其他输入类型的列表或者其他输入类型的非空变体。</p><p><strong>Semantics/语义</strong></p><div class="spec-semantic"><span class="spec-nt"><a href="#Type">Type</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Name">Name</a></span></div><ol><li>使<var>name</var>为<span class="spec-nt"><a href="#Name">Name</a></span>的值。</li><li>使<var>type</var>为Schema中定义的类型的<var>name</var></li><li><var>type</var>不可为<span class="spec-keyword">null</span></li><li>返回<var>type</var></li></ol></div><div class="spec-semantic"><span class="spec-nt"><a href="#Type">Type</a></span><div class="spec-rhs"><span class="spec-t">[</span><span class="spec-nt"><a href="#Type">Type</a></span><span class="spec-t">]</span></div><ol><li>使<var>itemType</var>为<span class="spec-nt"><a href="#Type">Type</a></span>求值后的值。</li><li>使<var>type</var>为一个列表类型，其中内部类型为<var>itemType</var>。</li><li>返回<var>type</var>。</li></ol></div><div class="spec-semantic"><span class="spec-nt"><a href="#Type">Type</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Type">Type</a></span><span class="spec-t">!</span></div><ol><li>使<var>nullableType</var>为<span class="spec-nt"><a href="#Type">Type</a></span>计算后的值。</li><li>使<span class="spec-nt"><a href="#Type">Type</a></span>为非空类型，其中内部类型为<var>nullableType</var>。</li><li>返回<var>type</var>。</li></ol></div></section><section id="sec-Language-.Directives-" secid="2.12"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Language-.Directives-">2.12</a></span>Directives/指令</h3><div class="spec-production" id="Directives"><span class="spec-nt"><a href="#Directives">Directives</a></span><div class="spec-rhs"><span class="spec-nt list"><a href="#Directive">Directive</a><span class="spec-mods"><span class="spec-mod list">list</span></span></span></div></div><div class="spec-production" id="Directive"><span class="spec-nt"><a href="#Directive">Directive</a></span><div class="spec-rhs"><span class="spec-t">@</span><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-nt optional"><a href="#Arguments">Arguments</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span></span></div></div><p>指令 &rarr; @名称 参数? 指令为GraphQL文档提供了另一种运行时执行行为和类型验证行为。</p><p>有时候，你需要改变GraphQL的执行行为，而参数并不满足要求，譬如条件性的包含或者跳过一个字段。指令通过向执行器描述附加信息来完成这种需求。</p><p>指令需要一个名字和一组参数，可以接受任意输入类型。</p><p>指令可以用于描述类型、字段、片段、操作的附加信息。</p><p>将来版本的GraphQL会加入可配置的执行能力，他们则可能表现为指令。 </p></section></section><section id="sec-Type-System-" secid="3"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Type-System-">3</a></span>Type System/类型系统</h2><p>GraphQL的类型系统用于描述服务器的能力以及判断一个查询是否有效。类系统也描述了查询参数的输入类型，用于运行时检查有效性。</p><p>GraphQL服务器的能力是同schema来描述，schema使用其支持的类型和指令来定义。</p><p>一个给定GraphQL schema其自身首先必须要通过内部有效性验证，本章节将会讲述这个验证过程的相关规则。</p><p>一个GraphQL schema使用每种操作的根级类型表示：query/查询、mutation/更改和subscription/订阅，这表示schema是这三种操作开始的地方。</p><p>所有GraphQL schema内的类型都必须要有唯一的名字，任意两个类型都不应该有相同的名字，任意类型也不应该有和内建类型冲突的名字（包含Scalar/标量和Introspection/内省类型）。</p><p>所有GraphQL schema内的指令也必须拥有唯一的名字，指令和类型可以拥有相同的名字，因为两者之间并没有歧义。</p><p>所有schema内定义的类型和指令都不能以<span class="spec-string">"__"</span>（双下划线）开头命名，因为这是GraphQL内省系统专用。</p><section id="sec-Types-" secid="3.1"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Types-">3.1</a></span>Types/类型</h3><p>任何GraphQL Schema的最基本单元都是类型，GraphQL中有8种类型。</p><p>最基本的类型是<code>Scalar</code>/标量，一个标量代表一个原始值，例如字符串或者整数。有时候，一个标量字段的返回值可能是可枚举的，对应这种场景，GraphQL提速了<code>Enum</code>/枚举类型，其指定了响应结果的有效范围。</p><p>标量和枚举型组成了响应结果树的叶子节点，而中间的分支节点则是<code>Object</code>/对象类型，其定义了一套字段，每个字段是系统中的另一个类型，从而能够定义任意层次的类型层级。</p><p>GraphQL支持两种抽象类型：interface/接口和union/联合。</p><p><code>Interface</code>定义了一系列字段，<code>Object</code>类型通过实现了其中的字段来实现它。当类型系统表明要返回一个接口时，其返回的都是一个实现这个接口的类型。</p><p><code>Union</code>定义了一个可能类型的列表，与接口相似，当系统表明要返回一个联合时，其返回的是联合中的一个类型。</p><p>这些类型都是可为空且为单数，譬如，一个标量字符串会返回一个null或者一个字符串。通常有需要表示某个类型的列表，于是GraphQL中提供了<code>List</code>类型，将其他类型封装在其中。类似的<code>Non-Null</code>类型也是封装其他类型，用以标注返回结果不可为空。这两种类型称为&ldquo;封装类型&rdquo;，非封装类型称为基础类型，每个封装类型里面都有一个基础类型，通过不断解封装来找到基础类型。</p><p>向GraphQL提供复杂结构作为输入参数是十分有用的，GraphQL为此提供了<code>Input Object</code>类型，让客户端从schema中获知服务端具体需要什么样的数据。</p><section id="sec-Scalars-" secid="3.1.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Scalars-">3.1.1</a></span>Scalars/标量</h4><p>如名字所示，GraphQL中一个标量代表这一个原始值，GraphQL的响应采用的是树形层级结构，其叶子节点即是标量。</p><p>所有GraphQL标量都能以字符串形式表示，虽然取决于所用的返回格式，可能有准确的原始类型来表示指定标量，服务器在适当的时候也应采取这种类型。</p><p>GraphQL提供了一些内建标量，类型系统也允许根据语义添加其他标量。假设GraphQL中要定义一个标量<code>Time</code>/时间，可将字符串转换成ISO&#8208;8601的格式，当查询一个<code>Time</code>字段时，客户端可以使用ISO&#8208;8601解析器，将这个字段类型转换成客户端特有的原始类型。另一个有潜在用途的标量是<code>Url</code>，通常会序列化成字符串，但是会由服务器保证是有效的URL。</p><p>服务器可能会在schema中省略内建标量，譬如，服务器并未使用浮点数，那么它可能并不会包含<code>Float</code>类型。 但是一旦schema包含了本规范所述的类型，那么一定会遵守本规范描述的对应行为，譬如，服务器一定不会使用名为<code>Int</code>的类型去表示128&#8208;bit的数字，或者国际化信息。</p><p><strong>Result Coercion/结果类型转换</strong></p><p>当GraphQL服务器准备一个标量字段的时候，必须遵守此标量的描述协议，或者强制转换原始值，或者抛出错误。</p><p>例如：当服务器在准备一个<code>Int</code>型标量时，收到的是一个浮点数，如果服务器直接输出这个值，那势必会打破协定，所以服务器可以剔除小数部分，只保留整数部分，然后返回整数值，如果服务器收到的是布尔型值<code>true</code>，那么就可以返回<code>1</code>，如果服务器收到的是字符串型，那么就尝试以10为底，解析字符串为整数，如果服务器没法将某些值转换成<code>Int</code>，那么就只能抛出错误。</p><p>因为这个转换行为对于客户端是不可见的，所以准确的转换规则全由实现指定，规范对其的唯一要求就是输出值需遵守标量协议。</p><p><strong>Input Coercion/输入类型转换</strong></p><p>如果GraphQL的某个参数要求标量作为输入，其类型转换显而易见地必须良好定义。如果输入值无法满足转换规则，则必须抛出错误、</p><p>GraphQL对于整数和浮点数输入值有不同的字面量表示方式，其类型转换也对应输入类型做转换。GraphQL可以使用变量作为参数，这些变量的值像是在HTTP的传输中通常会被序列化，由于有些序列化方法并不区分整数和浮点数（譬如JSON），可能因为一个数没有有效小数值而被当作整数而不是浮点数。</p><p>下列所有类型中，除了Non&#8208;Null之外，如果显式提供了<span class="spec-keyword">null</span>，那么其输入结果就会被转换成<span class="spec-keyword">null</span>。</p><p><strong>Built&#8208;in Scalars/内建标量</strong></p><p>GraphQL提供一套基本的定义良好的标量类型，每个GraphQL服务器都应该支持这些类型，并且使用这些名字的类型必须遵守下文描述的行为、</p><section id="sec-Int-" secid="3.1.1.1"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Int-">3.1.1.1</a></span>Int/整数型</h5><p>整数型标量类型表示一个32位有符号的无小数部分的数值。响应格式应该使用一个支持32位的整数型或者数值类型来表示这个标量类型、</p><p><strong>Result Coercion/结果类型转换</strong></p><p>GraphQL服务器应该转换非整数型原始数据为整数型，如若不能，则必须抛出字段错误。例如，从浮点型<code>1.0</code>转换成<code>1</code>，或者从字符串型<code>&quot;2&quot;</code>转换成<code>2</code>。</p><p><strong>Input Coercion/输入类型转换</strong></p><p>当需要作为输入类型时，只接受整数型输入值。其它类型，包含字符串型数值内容，都要抛出类型不正确的查询错误。如果整数型输入值小于-2<sup>31</sup>或者大于2<sup>31</sup>，也要抛出查询错误。</p><div class="spec-note">超过32位的整数建议使用字符串或者自定义的标量类型，因为不是所有平台和传输协议都支持超过32位精度编码额整数型数值。</div></section><section id="sec-Float-" secid="3.1.1.2"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Float-">3.1.1.2</a></span>Float/浮点型</h5><p>浮点型标量类型表示一个有符号的双精度小数，见<a href="http://en.wikipedia.org/wiki/IEEE_floating_point">IEEE 754</a>。响应格式应该使用一个合适的双精度数值类型来表示这个标量类型。</p><p><strong>Result Coercion/结果类型转换</strong></p><p>GraphQL服务器应该转换非浮点型原始数据为型，如若不能，则必须抛出字段错误。例如，从整数型<code>1</code>转换成<code>1.0</code>，或者是字符串型<code>&quot;2&quot;</code>转换成<code>2.0</code>。</p><p><strong>Input Coercion/输入类型转换</strong></p><p>当需要作为输入类型时，接受整数型和浮点型输入值。整数型会被转换成小数部分为空的浮点数，譬如整数型输入值<code>1</code>转换成<code>1.0</code>，其他类型，包含字符串型数值类型，都要抛出类型不正确的查询错误。如果整型输入值无法使用IEEE 754方式表示，也要抛出查询错误。</p></section><section id="sec-String-" secid="3.1.1.3"><h5><span class="spec-secid" title="link to this section"><a href="#sec-String-">3.1.1.3</a></span>String/字符串型</h5><p>字符串型标量表示UTF&#8208;8字符序列组成的文本数据。GraphQL一般使用字符串型来表示任意格式人类可读的文本。所有响应格式都必须支持字符串型表示，字符串型如下所述。</p><p><strong>Result Coercion/结果类型转换</strong></p><p>GraphQL服务器应该转换非字符串型原始数据为字符串型，如若不能，则必须抛出字段错误。例如，从布尔型true转换成<code>&quot;true&quot;</code>，从整型<code>1</code>转换成<code>&quot;1&quot;</code>。</p><p><strong>Input Coercion/输入类型转换</strong></p><p>当需要作为输入类型时，只接受有效的UTF&#8208;8字符串型输入值。其它类型都要抛出类型不正确的查询错误。</p></section><section id="sec-Boolean-" secid="3.1.1.4"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Boolean-">3.1.1.4</a></span>Boolean/布尔型</h5><p>布尔型标量表示<code>true</code>或者<code>false</code>两个值。响应格式应该使用内建的布尔型，如不支持，则使用另外的表示法，整数型<code>1</code> 和<code>0</code>。</p><p><strong>Result Coercion/结果类型转换</strong></p><p>GraphQL服务器应该转换非布尔型原始数据为布尔型，如若不能，则必须抛出字段错误。例如，将任意不为零数值转换成<code>true</code>。</p><p><strong>Input Coercion/输入类型转换</strong></p><p>当需要作为输入类型时，只接受布尔型输入值。其它类型都要抛出类型不正确的查询错误。</p></section><section id="sec-ID" secid="3.1.1.5"><h5><span class="spec-secid" title="link to this section"><a href="#sec-ID">3.1.1.5</a></span>ID</h5><p>ID型标量表示一个唯一标识符，通常用于重取一个对象或者作为缓存的键。ID型使用<code>String</code>相同方式来序列化，但是它并不是为了人类可读，虽然它通常可能是数值型，但也总是序列化成<code>String</code>。</p><p><strong>Result Coercion/结果类型转换</strong></p><p>GraphQL对ID的格式是不干预的，将其序列化成字符串以保证ID的多种格式之间的相容性，可以是自增数值，可以是128位大数，也可是base64编码后的值和<a href="http://en.wikipedia.org/wiki/Globally_unique_identifier">GUID</a>等格式的字符串值。</p><p>GraphQL服务器应该将给定ID格式转换成字符串，如若不能，则必须抛出字段错误。</p><p><strong>Input Coercion/输入类型转换</strong></p><p>当需要作为输入类型时，任意字符串（譬如<code>&quot;4&quot;</code>）或者整数（譬如<code>4</code>）都应该被转换成给定服务器支持的ID格式。其他的输入类型，包括浮点型（譬如<code>4.0</code>）都必须抛出类型不正确的查询错误。</p></section></section><section id="sec-Objects-" secid="3.1.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Objects-">3.1.2</a></span>Objects/对象</h4><p>GraphQL查询是层级式的可组装的，以树的形式描述了信息。其中标量类型描述了层级查询中叶子节点的值，对象则描述了中间层。</p><p>GraphQL对象表示一个具名字段列表，每个字段会产出一个特定类型的值。对象的值应该向有序映射集（ordered maps），其中查询字段名（或者别名）作为键，字段的结果作为值，以出现在查询中的顺序来排序。</p><p>对象中的所有字段都不应以<span class="spec-string">"__"</span>（双下划线）起头命名，因为这GraphQL内省系统专用的命名方式。</p><p>例如，<code>Person</code>类型可以如下描述：</p><pre><code>type Person {
  name: String
  age: Int
  picture: Url
}
</code></pre><p>其中<code>name</code>产生一个<code>String</code>值，<code>age</code>产生一个<code>Int</code>值，<code>picture</code>产生一个<code>Url</code>值。</p><p>对一个对象的查询必须至少指定一个字段，字段的选择集会产生一个有序映射集，其中包含被查询对象准确的子集，这个子集将以查询的顺序排序。只有在对象中声明过的字段才能被有效查询。</p><p>譬如，查询<code>Person</code>的所有字段：</p><pre><code>{
  name
  age
  picture
}
</code></pre><p>会产生如下对象：</p><pre><code>{
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Mark Zuckerberg"</span>,
  <span class="hljs-attr">"age"</span>: <span class="hljs-number">30</span>,
  <span class="hljs-attr">"picture"</span>: <span class="hljs-string">"http://some.cdn/picture.jpg"</span>
}
</code></pre><p>当选择字段的子集：</p><pre><code>{
  age
  name
}
</code></pre><p>一定会产生准确的子集：</p><pre><code>{
  <span class="hljs-attr">"age"</span>: <span class="hljs-number">30</span>,
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Mark Zuckerberg"</span>
}
</code></pre><p>对象的字段可能是标量、枚举型、其他对象类型、接口、或者联合。也可能是其它封装类型，其内部类型是这五个之一。</p><p>例如：<code>Person</code>类型可能包含<code>relationship</code>：</p><pre><code>type Person {
  name: String
  age: Int
  picture: Url
  relationship: Person
}
</code></pre><p>对于字段对象的查询必须嵌套其字段集合，譬如下列查询就不是有效的：</p><pre class="spec-counter-example"><code>{
  name
  relationship
}
</code></pre><p>然而，这个案例是有效的：</p><pre><code>{
  name
  relationship {
    name
  }
}
</code></pre><p>并会产生被查询的每个对象的子集：</p><pre><code>{
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Mark Zuckerberg"</span>,
  <span class="hljs-attr">"relationship"</span>: {
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Priscilla Chan"</span>
  }
}
</code></pre><p><strong>Field Ordering/字段排序</strong></p><p>当查询一个对象时，字段的结果映射在概念上的排序顺序应该是跟查询执行期间字段被执行的顺序一致，除了片段上并不适用于当前字段的类型和被<code>@skip</code>或<code>@include</code>指令跳过的字段。这个排序由<span class="spec-call">CollectFields()</span>算法正确完成。</p><p>表示有序映射集的响应序列化格式也应该采用同样的排序。只能表示无序映射集的序列化格式（譬如JSON）应该保证这个语法上的顺序。</p><p>响应中字段排序和请求中一致的表示方式，提升了调试过程中对人而言的可读性，也保证了响应属性顺序相关的解析效率。</p><p>如果一个片段在其他字段之前展开，那么片段的字段的顺位则在片段后续字段之前。</p><pre><code>{
  foo
  ...Frag
  qux
}

fragment Frag on Query {
  bar
  baz
}
</code></pre><p>产生下面排序结果：</p><pre><code>{
  <span class="hljs-attr">"foo"</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">"bar"</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">"baz"</span>: <span class="hljs-number">3</span>,
  <span class="hljs-attr">"qux"</span>: <span class="hljs-number">4</span>
}
</code></pre><p>如果一个字段在一个选择集中被多次查询，则以第一次被执行的顺序排序，片段中不适用的字段不会影响排序。</p><pre><code>{
  foo
  ...Ignored
  ...Matching
  bar
}

fragment Ignored on UnknownType {
  qux
  baz
}

fragment Matching on Query {
  bar
  qux
  foo
}
</code></pre><p>产生下面排序结果：</p><pre><code>{
  <span class="hljs-attr">"foo"</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">"bar"</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">"qux"</span>: <span class="hljs-number">3</span>
}
</code></pre><p>如果一个字段被指令排除，那它也不会被纳入字段排序的考量之中。</p><pre><code>{
  foo @skip(if: true)
  bar
  foo
}
</code></pre><p>产生下面排序结果：</p><pre><code>{
  <span class="hljs-attr">"bar"</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">"foo"</span>: <span class="hljs-number">2</span>
}
</code></pre><p><strong>Result Coercion/结果类型转换</strong></p><p>对象类型的结果类型转换判定机制是GraphQL执行器的核心，因此将在本规范的执行器那一章节覆盖这个内容。</p><p><strong>Input Coercion/输入类型转换</strong></p><p>对象类型不可作为有效输入类型。</p><section id="sec-Object-Field-Arguments-" secid="3.1.2.1"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Object-Field-Arguments-">3.1.2.1</a></span>Object Field Arguments/对象字段参数</h5><p>概念上的对象字段是会产生值的函数，有时候对象字段能够接受参数来进一步指定返回值。对象字段参数在定义上是一个所有可能参数和参数输入类型的列表。</p><p>一个字段内的所有参数都不能以<span class="spec-string">"__"</span>（双下划线）起头命名，因为这GraphQL内省系统专用的命名方式。</p><p>例如，<code>Person</code>拥有一个<code>picture</code>字段，接受一个参数以返回特定大小的图片链接。</p><pre><code>type Person {
  name: String
  picture(size: Int): Url
}
</code></pre><p>GraphQL查询可选择性地指定参数，以让字段返回指定参数的结果。</p><p>譬如这个案例查询：</p><pre><code>{
  name
  picture(size: 600)
}
</code></pre><p>可能产生这个结果：</p><pre><code>{
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Mark Zuckerberg"</span>,
  <span class="hljs-attr">"picture"</span>: <span class="hljs-string">"http://some.cdn/picture_600.jpg"</span>
}
</code></pre><p>对象字段的参数可以是任何输入类型。</p></section><section id="sec-Object-Field-deprecation-" secid="3.1.2.2"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Object-Field-deprecation-">3.1.2.2</a></span>Object Field deprecation/对象字段弃用</h5><p>应用在必要情况下会将对象字段标注为弃用。这样之后，查询弃用字段依然有效（为了保证既有客户端不被这个变更导致异常），但是这种字段应该在文档和工具中正确对待。</p></section><section id="sec-Object-type-validation-" secid="3.1.2.3"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Object-type-validation-">3.1.2.3</a></span>Object type validation/对象类型验证</h5><p>对象类型可能因为定义的不严谨而导致潜在的无效性。GraphQL Schema中，以下规则必须被所有对象遵守。</p><ol><li>一个对象类型必须定义一个或多个字段。</li><li>一个对象类型内的字段必须拥有这个对象类型内唯一的命名；任何两个字段都不可同名。</li><li>一个对象类型的每个字段都不能以<span class="spec-string">"__"</span>（双下划线）起头命名。</li><li>一个对象类型可以声明实现了一个或多个不同接口。</li><li>一个对象类型必须是所有它所实现的接口的超集：<ol><li>对象类型必须包含其接口内所有字段同名的字段。<small>译者案：此句翻译准确性待定</small><ol><li>这个对象字段类型必须是接口字段类型等价的类型或者其子类型（协变性）。<ol><li>一个对象字段类型如果是这个接口字段类型等价（相同）的类型，那么它是一个有效子类型。</li><li>一个对象字段类型如果是一个对象类型，且其接口字段类型是一个接口类型或者联合类型，且这个对象字段类型是这个接口字段类型的可能类型，那么它是一个有效子类型。</li><li>一个对象字段类型如果是一个列表类型，且其接口字段类型也是一个列表类型，且这个对象字段类型的列表元素类型是接口字段类型的列表元素类型的子类型，那么它是一个有效子类型。</li><li>一个对象字段类型如果是其接口字段类型的子类型的Non&#8208;Null（非空）变体，那么它是一个有效子类型。</li></ol></li><li>这个对象字段必须包含其接口字段上定一个所有参数的同名参数。<ol><li>这个对象字段的参数必须接受其接口字段上参数同类型的参数（逆变性）。</li></ol></li><li>这个对象字段可以包含其接口字段上未定义的附加参数，但附加参数并不是必须。</li></ol></li></ol></li></ol></section></section><section id="sec-Interfaces-" secid="3.1.3"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Interfaces-">3.1.3</a></span>Interfaces/接口</h4><p>GraphQL接口表示一个具名字段列表以及其参数，GraphQL对象可以实现接口，并保证包含接口中的字段。</p><p>GraphQL接口上的字段拥有和GraphQL对象上相同的规则；字段类型可以是标量、对象、枚举型、接口或者联合，或者这五个类型作为基本类型的封装类型。</p><p>例如，一个接口可以描述某个必要字段的类型，譬如<code>Person</code>或者<code>Business</code>，随后实现这个接口。</p><pre><code>interface NamedEntity {
  name: String
}

type Person implements NamedEntity {
  name: String
  age: Int
}

type Business implements NamedEntity {
  name: String
  employeeCount: Int
}
</code></pre><p>产生接口额字段使用的场景为需要从多个对象找返回一个的情况，其中需要保证一定会有部分字段。</p><p>继续上述案例，<code>Contact</code>可能指代<code>NamedEntity</code>。</p><pre><code>type Contact {
  entity: NamedEntity
  phoneNumber: String
  address: String
}
</code></pre><p>这将使我们能够编写查询<code>Contact</code>中通用字段的语句。</p><pre><code>{
  entity {
    name
  }
  phoneNumber
}
</code></pre><p>当查询一个接口类型上的字段时，只有在接口上声明的字段可是被查询。上述案例中，<code>entity</code>返回<code>NamedEntity</code>，其中<code>NamedEntity</code>中定义了<code>name</code>，所以这个查询是有效的。所以，下面这个查询是无效的：</p><pre class="spec-counter-example"><code>{
  entity {
    name
    age
  }
  phoneNumber
}
</code></pre><p>因为<code>entity</code>指代<code>NamedEntity</code>，这个接口中并没有定义<code>age</code>，所以只有在<code>entity</code>的结果为<code>Person</code>，查询<code>age</code>才有效。查询语句可以通过片段或者内联片段来表述这种情况：</p><pre><code>{
  entity {
    name
    ... on Person {
      age
    }
  },
  phoneNumber
}
</code></pre><p><strong>Result Coercion/结果类型转换</strong></p><p>接口类型应该能够判定给定结果对应哪一个对象类型，一旦确定，接口的结果类型转换和对象的接口转换采用一样的方法。</p><p><strong>Input Coercion/输入类型转换</strong></p><p>接口类型不可作为有效输入类型。</p><section id="sec-Interface-type-validation-" secid="3.1.3.1"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Interface-type-validation-">3.1.3.1</a></span>Interface type validation/接口类型验证</h5><p>接口类型可能因为定义的不严谨而导致潜在的无效性。</p><ol><li>一个接口类型必须定义一个或多个字段。</li><li>一个接口类型内的字段必须拥有这个接口类型内唯一的命名；任何两个字段都不可同名。</li><li>一个对象类型的每个字段都不能以<span class="spec-string">"__"</span>（双下划线）起头命名。</li></ol></section></section><section id="sec-Unions-" secid="3.1.4"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Unions-">3.1.4</a></span>Unions/联合</h4><p>GraphQL联合表示一个对象的类型是对象类型列表中之一，但不保证这些类型之间的字段。另一个区别于接口的方面是，对象会声明其实现的接口，而不知道它被包含的联合。</p><p>对于接口和对象，只可以直接查询在其中被定义的字段，如果要查询接口的其他字段，必须使用类型片段。对于联合也是一样，但是联合不定义任何字段，所以联合上<strong>不</strong>允许查询任何字段，除非使用类型片段。</p><p>例如，我们有以下类型系统：</p><pre><code>union SearchResult = Photo | Person

type Person {
  name: String
  age: Int
}

type Photo {
  height: Int
  width: Int
}

type SearchQuery {
  firstSearchResult: SearchResult
}
</code></pre><p>当查询<code>SearchQuery</code>类型的<code>firstSearchResult</code>字段时，查询可能需要片段的所有字段来判断类型。如果结果是<code>Person</code>，那请求其<code>name</code>，如果是<code>photo</code>，那请求<code>height</code>。下列案例是错的，因为联合上不定义任何字段：</p><pre class="spec-counter-example"><code>{
  firstSearchResult {
    name
    height
  }
}
</code></pre><p>而正确的查询应该是：</p><pre><code>{
  firstSearchResult {
    ... on Person {
      name
    }
    ... on Photo {
      height
    }
  }
}
</code></pre><p><strong>Result Coercion/结果类型转换</strong></p><p>联合类型应该能够判定给定结果对应哪一个对象类型，一旦确定，联合的结果类型转换和对象的接口转换采用一样的方法。</p><p><strong>Input Coercion/输入类型转换</strong></p><p>联合类型不可作为有效输入类型。</p><section id="sec-Union-type-validation-" secid="3.1.4.1"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Union-type-validation-">3.1.4.1</a></span>Union type validation/联合类型验证</h5><p>联合类型可能因为定义的不严谨而导致潜在的无效性。</p><ol><li>联合的成员类型必须是对象基础类型；标量、接口和联合都不能作为联合的成员类型。同样的，封装类型也不能是联合的成员类型。</li><li>一个联合类型必须定义一个或者多个不同的成员类型。</li></ol></section></section><section id="sec-Enums-" secid="3.1.5"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Enums-">3.1.5</a></span>Enums/枚举型</h4><p>GraphQL枚举型是基于标量类型的变体，其表示可能值的一个有限集。</p><p>GraphQL枚举型并不指代数值，而是正确的唯一值。他们序列化成字符串，字符串中用名来表示值。</p><p><strong>Result Coercion/结果类型转换</strong></p><p>GraphQL服务器必须返回定义中可能结果集的一个值。如果无法达成合理的类型转换，则抛出字段错误。</p><p><strong>Input Coercion/输入类型转换</strong></p><p>GraphQL用常量字面量表示枚举型输入值，GraphQL字符串型字面量不可作为枚举型输入值，否则将抛出查询错误。</p><p>查询变量的序列化传输方式中，如果对于非字符串符号值有区别于字符串的表示方法（譬如<a href="https://github.com/edn-format/edn">EDN</a>），那么就应该采用那种方法。否则就像没有这个能力的大多数序列化传输方法一样，字符串型将被转义成同名的枚举型值。</p></section><section id="sec-Input-Objects-" secid="3.1.6"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Input-Objects-">3.1.6</a></span>Input Objects/输入对象</h4><p>字段上可能会定义参数，客户端将参数合在查询中传输，从而改变字段的行为。这些输入可能是字符串型或者枚举型，但是有时候需要比这个更复杂的类型结构。</p><p>上文中定义的<code>Object</code>并不适合在这儿重用，因为<code>Object</code>可能包含循环引用或者指代了接口类型或联合类型，这俩都不适合作为输入参数。因此，输入对象才成为了这个系统中单独的类型。</p><p><code>Input Object</code>定义了输入字段的一个集合，输入字段并不是标量、枚举型或者其他输入对象，这使参数可以接受任意的复杂结构。</p><p><strong>Result Coercion/结果类型转换</strong></p><p>输入对象类型不可作为有效结果类型。</p><p><strong>Input Coercion/输入类型转换</strong></p><p>输入对象类型的值应该是输入对象的字面量或者无序映射集，否则将抛出错误。这个无序映射集不应该包含这个输入对象类型中未定义的字段，否则将抛出错误。</p><p>如果输入对象上定一个非空字段没有从原始值收到对应条目（譬如变量未赋值，或者赋予了<span class="spec-keyword">null</span>（空）值），则抛出错误。</p><p>类型转换的结果是环境特定的无序映射集，其定义了由输入对象类型和原始值构成的字段。</p><p>对于输入对象类型中的字段，如果原始值中有条目拥有相同的名字，条目的值是一个字面量或者变量（运行时值），这个条目就被添加到结果中同名的字段上。</p><p>结果中条目的值是原始值类型转换之后的结果，类型转换的规则由输入字段的类型决定。</p><p>下列是输入对象类型转换的案例：</p><pre><code>input ExampleInputObject {
  a: String
  b: Int!
}
</code></pre><table><thead><tr><th>原始值 </th><th>变量 </th><th>转换后的值</th></tr></thead><tbody><tr><td><code>{ a: &quot;abc&quot;, b: 123 }</code> </td><td><span class="spec-keyword">null</span> </td><td><code>{ a: &quot;abc&quot;, b: 123 }</code></td></tr><tr><td><code>{ a: 123, b: &quot;123&quot; }</code> </td><td><span class="spec-keyword">null</span> </td><td><code>{ a: &quot;123&quot;, b: 123 }</code></td></tr><tr><td><code>{ a: &quot;abc&quot; }</code> </td><td><span class="spec-keyword">null</span> </td><td>Error: Missing required field <var>b</var></td></tr><tr><td><code>{ a: &quot;abc&quot;, b: null }</code> </td><td><span class="spec-keyword">null</span> </td><td>Error: <var>b</var> must be non&#8208;null.</td></tr><tr><td><code>{ a: null, b: 1 }</code> </td><td><span class="spec-keyword">null</span> </td><td><code>{ a: null, b: 1 }</code></td></tr><tr><td><code>{ b: $var }</code> </td><td><code>{ var: 123 }</code> </td><td><code>{ b: 123 }</code></td></tr><tr><td><code>{ b: $var }</code> </td><td><code>{}</code> </td><td>Error: Missing required field <var>b</var>.</td></tr><tr><td><code>{ b: $var }</code> </td><td><code>{ var: null }</code> </td><td>Error: <var>b</var> must be non&#8208;null.</td></tr><tr><td><code>{ a: $var, b: 1 }</code> </td><td><code>{ var: null }</code> </td><td><code>{ a: null, b: 1 }</code></td></tr><tr><td><code>{ a: $var, b: 1 }</code> </td><td><code>{}</code> </td><td><code>{ b: 1 }</code></td></tr></tbody></table><div class="spec-note">输入值显式声明一个输入字段额度值为<span class="spec-keyword">null</span>和连输入字段都没声明两种情况存在语义差异。</div><section id="sec-Input-Object-type-validation-" secid="3.1.6.1"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Input-Object-type-validation-">3.1.6.1</a></span>Input Object type validation/输入对象类型验证</h5><ol><li>一个输入对象类型必须定义一个或多个字段。</li><li>一个输入对象类型内的字段必须拥有这个接口类型内唯一的命名；任何两个字段都不可同名。</li><li>每个字段的返回类型必须是输入类型。</li></ol></section></section><section id="sec-Lists-" secid="3.1.7"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Lists-">3.1.7</a></span>Lists/列表型</h4><p>GraphQL列表市一个特殊的集合类型，它声明了列表中元素的类型（下文指代为<em>元素类型</em>）。列表值的序列化结果是一个有序列表，列表中的元素根据元素类型序列化。一个字段使用了一个列表类型，其中封装了元素类型，其标注形式为：<code>pets: [Pet]</code>。</p><p><strong>Result Coercion/结果类型转换</strong></p><p>GraphQL服务器必须返回有序列表作为一个列表类型的结果，列表中的每一个元素都是其元素类型的结果类型转换的结果，如果无法达成合理的类型转换，则抛出字段错误。其中，如果返回的是非列表类型，类型转换也会失败，这是要抛出一个类型系统和实现不匹配的异常。</p><p><strong>Input Coercion/输入类型转换</strong></p><p>当作为输入类型的时候，要求所有列表值都符合列表元素类型。</p><p>如果作为输入类型传递给列表类型的值，既<em>不</em>是列表型也不是<span class="spec-keyword">null</span>空值，那么它将作为列表中的唯一元素作类型转换，这使输入能够在即便声明为&ldquo;var args&rdquo;类型参数数组，但只有一个参数被传入（常见场景），客户端可以直接传递值而不用封装成列表。</p><div class="spec-note">如果通过运行时变量传入给一个列表型的值是<span class="spec-keyword">null</span>，那么这个值会被解读为未传输任何列表，而不是一个长度为1的值为<span class="spec-keyword">null</span>的列表。</div></section><section id="sec-Types-.Non-Null-" secid="3.1.8"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Types-.Non-Null-">3.1.8</a></span>Non-Null/非空型</h4><p>默认情况下，GraphQL的所有类型都是可空的；<span class="spec-keyword">null</span>可作为上述所有类型的有效响应。如果要声明一个值不可为空，可以使用GraphQL的非空类型。这个类型封装一个内部类型，并表现为和被封装类型一样的行为，除了<span class="spec-keyword">null</span>不可作为其有效响应。非空类型使用一个感叹号跟着封装类型的方式来标注：<code>name: String!</code>。</p><p><strong>Nullable vs. Optional/可空 vs 可选</strong></p><p>查询上下文中的字段<em>总是</em>可选的，某个字段可以被省略而查询依然有效。然后，非空类型的字段绝不能对查询返回<span class="spec-keyword">null</span>。</p><p>输入（譬如字段参数）默认情况下总是可选的，然而如果一个参数是非空输入类型，那么它将不接受<span class="spec-keyword">null</span>也不能被省略。为了简明,(nullable)可空类型总是(optional)可选的，(non&#8208;null)非空类型总是(required)必须的。</p><p><strong>Result Coercion/结果类型转换</strong></p><p>上述所有结果类型转换中，<span class="spec-keyword">null</span>都被视为有效值，如果转换一个非空类型，那么会使用被封装类型的转换规则。如果非空类型的转换结果不为<span class="spec-keyword">null</span>空，那么就取这个结果。否则如果结果为<span class="spec-keyword">null</span>空，那么则抛出字段错误。</p><p><strong>Input Coercion/输入类型转换</strong></p><p>如果未提供非空类型的输入对象字段或者参数，则被认为是提供了字面量<span class="spec-keyword">null</span>，或者认为是提供了一个未赋值或者为<span class="spec-keyword">null</span>空值的运行时变量，然后抛出查询错误。</p><p>如果给非空类型提供的值是字面量而非<span class="spec-keyword">null</span>，或者一个非空变量值，则其会按照被封装类型的输入类型转换规则来转换。</p><p>案例：非空参数不可省略。</p><pre class="spec-counter-example"><code>{
  fieldWithNonNullArg
}
</code></pre><p>案例：<span class="spec-keyword">null</span>空值不可作为非空参数的值。</p><pre class="spec-counter-example"><code>{
  fieldWithNonNullArg(nonNullArg: null)
}
</code></pre><p>案例：一个可空的变量不能作为非空参数的值。</p><pre><code>query withNullableVariable($var: String) {
  fieldWithNonNullArg(nonNullArg: $var)
}
</code></pre><div class="spec-note">在验证章节的定义中，向可空类型提供非空的输入值是无效。</div><p><strong>Non&#8208;Null type validation/非空类型验证</strong></p><ol><li>一个非空类型不可封装另一个非空类型。</li></ol></section></section><section id="sec-Type-System-.Directives-" secid="3.2"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Type-System-.Directives-">3.2</a></span>Directives/指令</h3><p>一个GraphQL Schema包含了执行引擎支持的指令表。</p><p>GraphQL的实现需要提供<code>@skip</code>和<code>@include</code>指令。</p><section id="sec--skip" secid="3.2.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec--skip">3.2.1</a></span>@skip</h4><p><code>@skip</code>指令可用于字段、片段展开以及内联片段，从而能够在执行期间通过if参数完成条件性排除。</p><p>下列案例中，<code>experimentalField</code>只有在<code>$someTest</code>为<code>false</code>的时候才会被查询。</p><pre><code>query myQuery($someTest: Boolean) {
  experimentalField @skip(if: $someTest)
}
</code></pre></section><section id="sec--include" secid="3.2.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec--include">3.2.2</a></span>@include</h4><p><code>@include</code>指令可用于字段、片段展开以及内联片段，从而能够在执行期间通过if参数完成条件性包含。</p><p>下列案例中，<code>experimentalField</code>只有在<code>$someTest</code>为<code>true</code>的时候才会被查询。</p><pre><code>query myQuery($someTest: Boolean) {
  experimentalField @include(if: $someTest)
}
</code></pre><div class="spec-note"><code>@skip</code>和<code>@include</code>没有优先级差别，当<code>@skip</code>和<code>@include</code>同时应用于一个字段时，<em>当且仅当</em><code>@skip</code>为<code>false</code>，<code>@include</code>为<code>true</code>的时候它才会被查询。相反的，在<em>仅有</em><code>@skip</code>为<code>true</code>或者<em>仅有</em><code>@include</code>为<code>false</code>的时候它<em>不会</em>被查询。</div></section></section><section id="sec-Initial-types-" secid="3.3"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Initial-types-">3.3</a></span>Initial types/初始类型</h3><p>一个GraphQL Schema包含了类型，表示query/查询、mutation/更改和subscription/订阅的起点，提供了进入类型系统的最初入口。其中query类型始终是必须的，并且是一个对象基础类型。mutation类型是可选的，如果其为空，那意味着此系统不支持mutation/更改，如果不为空，它必须是一个对象基础类型。同样的，subscription类型也是可选的，如果其为空，则此系统不支持subscription/订阅，如果不为空，它必须是一个对象基础类型。</p><p>query类型的字段表示GraphQL查询中最顶层可用的字段。例如：一个基本的GraphQL查询可能像这样：</p><pre><code>query getMe {
  me
}
</code></pre><p>当query对应的类型含有一个名为&ldquo;me&rdquo;的字段时，这个查询就是有效的。类似的：</p><pre><code>mutation setName {
  setName(name: &quot;Zuck&quot;) {
    newName
  }
}
</code></pre><p>当mutation对应的类型不为空，这个类型有一个名为&ldquo;setName&rdquo;参数为&ldquo;name&rdquo;的字段时，这个更改就是有效的。</p><pre><code>subscription {
  newMessage {
    text
  }
}
</code></pre><p>当subscription对应的类型不为空，这个类型有一个名为&ldquo;newMessage&rdquo;的字段，且只有一个根字段时，这个订阅就是有效的。 </p></section></section><section id="sec-Introspection-" secid="4"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Introspection-">4</a></span>Introspection/内省</h2><p>一个GraphQL服务器支持基于它的Schema来支持内省，这个Schema可以通过GraphQL自身来查询，创建了一个强大的工具构建平台。</p><p>拿一个琐碎的app的样例查询举例。样例中有一个User类型，其中有字段：id，name和birthday。</p><p>例如，假设服务器有下列类型定义：</p><pre><code>type User {
  id: String
  name: String
  birthday: Date
}
</code></pre><p>查询为</p><pre><code>{
  __type(name: &quot;User&quot;) {
    name
    fields {
      name
      type {
        name
      }
    }
  }
}
</code></pre><p>会返回</p><pre><code>{
  <span class="hljs-attr">"__type"</span>: {
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"User"</span>,
    <span class="hljs-attr">"fields"</span>: [
      {
        <span class="hljs-attr">"name"</span>: <span class="hljs-string">"id"</span>,
        <span class="hljs-attr">"type"</span>: { <span class="hljs-attr">"name"</span>: <span class="hljs-string">"String"</span> }
      },
      {
        <span class="hljs-attr">"name"</span>: <span class="hljs-string">"name"</span>,
        <span class="hljs-attr">"type"</span>: { <span class="hljs-attr">"name"</span>: <span class="hljs-string">"String"</span> }
      },
      {
        <span class="hljs-attr">"name"</span>: <span class="hljs-string">"birthday"</span>,
        <span class="hljs-attr">"type"</span>: { <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Date"</span> }
      }
    ]
  }
}
</code></pre><section id="sec-General-Principles-" secid="4.1"><h3><span class="spec-secid" title="link to this section"><a href="#sec-General-Principles-">4.1</a></span>General Principles/基本原则</h3><section id="sec-Naming-conventions-" secid="4.1.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Naming-conventions-">4.1.1</a></span>Naming conventions/命名约定</h4><p>GraphQL内省系统要求的类型和字段与用户定义的类型和系统共享相同的上下文，其字段名以<span class="spec-string">"__"</span>双下划线开头，以避免和用户定义的GraphQL类型命名冲突。相反地，GraphQL类型系统作者不能定义任何以双下划线开头的类型、字段、参数和其他类型系统工件。<small>artifact的翻译不确定</small></p></section><section id="sec-Documentation-" secid="4.1.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Documentation-">4.1.2</a></span>Documentation/文档</h4><p>所有内省系统中的类型必须提供<code>String</code>类型的<code>description</code>字段，以便类型设计者发布文档以增强能力。GraphQL服务可以返回使用Markdown语法（<a href="http://commonmark.org/">CommonMark</a>中指定）的<code>description</code>字段。因此建议所有展示<code>description</code>字段的工具使用CommonMark兼容的Markdown渲染器。</p></section><section id="sec-Deprecation-" secid="4.1.3"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Deprecation-">4.1.3</a></span>Deprecation/弃用</h4><p>为了支持向后兼容管理，GraphQL字段和枚举值可以指出其是否弃用(<code>isDeprecated: Boolean</code>)和一个为何弃用的描述(<code>deprecationReason: String</code>)。</p><p>基于GraphQL内省系统建造的工具应该通过隐含信息或者面向开发者的警告信息来减少弃用字段的使用。</p></section><section id="sec-Type-Name-Introspection-" secid="4.1.4"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Type-Name-Introspection-">4.1.4</a></span>Type Name Introspection/类型命名内省</h4><p>GraphQL支持类型命名自行，查询任意对象/接口/联合时可以在一个查询语句的任意位置通过元字段<code>__typename: String!</code>，得到当前查询的对象类型。</p><p>这在查询接口或者联合类型的真实类型的时候用得最为频繁。</p><p>这是个隐式字段，并不会出现在定义的类型的字段列表中。</p></section></section><section id="sec-Schema-Introspection-Schema-" secid="4.2"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Schema-Introspection-Schema-">4.2</a></span>Schema Introspection/Schema内省</h3><p>Schema的内省系统可通过查询操作的根级类型上的元字段<code>__schema</code>和<code>__type</code>来接入。</p><pre><code>__schema: __Schema!
__type(name: String!): __Type
</code></pre><p>这两个字段也是隐式的，不会出现在查询操作根节点类型的字段列表中。</p><p>GraphQL Schema内省系统的Schema：</p><pre><code>type __Schema {
  types: [__Type!]!
  queryType: __Type!
  mutationType: __Type
  subscriptionType: __Type
  directives: [__Directive!]!
}

type __Type {
  kind: __TypeKind!
  name: String
  description: String

  # OBJECT and INTERFACE only
  fields(includeDeprecated: Boolean = false): [__Field!]

  # OBJECT only
  interfaces: [__Type!]

  # INTERFACE and UNION only
  possibleTypes: [__Type!]

  # ENUM only
  enumValues(includeDeprecated: Boolean = false): [__EnumValue!]

  # INPUT_OBJECT only
  inputFields: [__InputValue!]

  # NON_NULL and LIST only
  ofType: __Type
}

type __Field {
  name: String!
  description: String
  args: [__InputValue!]!
  type: __Type!
  isDeprecated: Boolean!
  deprecationReason: String
}

type __InputValue {
  name: String!
  description: String
  type: __Type!
  defaultValue: String
}

type __EnumValue {
  name: String!
  description: String
  isDeprecated: Boolean!
  deprecationReason: String
}

enum __TypeKind {
  SCALAR
  OBJECT
  INTERFACE
  UNION
  ENUM
  INPUT_OBJECT
  LIST
  NON_NULL
}

type __Directive {
  name: String!
  description: String
  locations: [__DirectiveLocation!]!
  args: [__InputValue!]!
}

enum __DirectiveLocation {
  QUERY
  MUTATION
  SUBSCRIPTION
  FIELD
  FRAGMENT_DEFINITION
  FRAGMENT_SPREAD
  INLINE_FRAGMENT
}
</code></pre><section id="sec-The-__Type-Type-__Type-" secid="4.2.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-The-__Type-Type-__Type-">4.2.1</a></span>The __Type Type/__Type类型</h4><p><code>__Type</code>是这个类型内省系统的核心，它代表了这个系统中的标量、接口、对象类型、联合、枚举型。</p><p><code>__Type</code>也表示类型修改器，其通常用于表示修改一个类型(<code>ofType: __Type</code>)，这正是我们如何表示列表类型和非空类型，以及他们的组合类型。</p></section><section id="sec-Type-Kinds-" secid="4.2.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Type-Kinds-">4.2.2</a></span>Type Kinds/类型种类</h4><p>类型系统中存在多个种类的类型，每种类型都有不同的有效字段，这些类型都被列举在<code>__TypeKind</code>枚举值中。</p><section id="sec-Scalar-" secid="4.2.2.1"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Scalar-">4.2.2.1</a></span>Scalar/标量</h5><p>标量中譬如整数型、字符串型、布尔型都不能拥有字段。</p><p>GraphQL类型设计者需要描述标量的<code>description</code>字段描述数据格式以及标量的类型转换规则。</p><p>字段</p><ul><li><code>kind</code>必须返回<code>__TypeKind.SCALAR</code>。</li><li><code>name</code>必须返回字符串。</li><li><code>description</code>必须返回字符串或者<span class="spec-keyword">null</span>空值。</li><li>其他字段必须返回<span class="spec-keyword">null</span>空值。</li></ul></section><section id="sec-Object-" secid="4.2.2.2"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Object-">4.2.2.2</a></span>Object/对象</h5><p>对象类型表示一系列字段的具体实例，内省类型（譬如<code>__Type</code>,<code>__Field</code>等）亦是典型的对象类型。</p><p>字段</p><ul><li><code>kind</code>必须返回<code>__TypeKind.OBJECT</code>。</li><li><code>name</code>必须返回字符串。</li><li><code>description</code>必须返回字符串或者<span class="spec-keyword">null</span>空值。</li><li><code>fields</code>：本类型上可被查询的字段的集合。<ul><li>接受参数<code>includeDeprecated</code>，默认为<span class="spec-keyword">false</span>。如过为<span class="spec-keyword">true</span>则弃用的字段也将返回。</li></ul></li><li><code>interfaces</code>：对象实现的接口的集合。</li><li>其他字段必须返回<span class="spec-keyword">null</span>空值。</li></ul></section><section id="sec-Union-" secid="4.2.2.3"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Union-">4.2.2.3</a></span>Union/联合</h5><p>联合是一个抽象类型，其不声明任何字段。联合的可能类型要显式的在<code>possibleTypes</code>中列出。类型可不加修改的直接作为联合的一部分。</p><p>字段</p><ul><li><code>kind</code>必须返回<code>__TypeKind.UNION</code>。</li><li><code>name</code>必须返回字符串。</li><li><code>description</code>必须返回字符串或者<span class="spec-keyword">null</span>空值。</li><li><code>possibleTypes</code>必须返回联合内可能的类型的列表，它们都必须是对象类型。</li><li>其他字段必须返回<span class="spec-keyword">null</span>空值。</li></ul></section><section id="sec-Interface-" secid="4.2.2.4"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Interface-">4.2.2.4</a></span>Interface/接口</h5><p>接口是一个抽象类型，其声明了通用字段。所有实现接口的对象必须定义完全匹配的名字和类型的字段。实现了此接口的类型都有在<code>possibleTypes</code>中列出。</p><p>字段</p><ul><li><code>__TypeKind.INTERFACE</code>。</li><li><code>name</code>必须返回字符串。</li><li><code>description</code>必须返回字符串或者<span class="spec-keyword">null</span>空值。</li><li><code>fields</code>: 接口要求的字段的集合。</li><li><code>possibleTypes</code>返回实现了此接口的类型，它们都必须是对象类型。</li><li>其他字段必须返回<span class="spec-keyword">null</span>空值。</li></ul></section><section id="sec-Enum-" secid="4.2.2.5"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Enum-">4.2.2.5</a></span>Enum/枚举型</h5><p>枚举型是特殊的标量，他只能拥有有限集合的标量。</p><p>字段</p><ul><li><code>kind</code>必须返回<code>__TypeKind.ENUM</code>。</li><li><code>name</code>必须返回字符串。</li><li><code>description</code>必须返回字符串或者<span class="spec-keyword">null</span>空值。</li><li><code>enumValues</code>：<code>EnumValue</code>的列表。必须至少有一个值，并且必须有不同的名字。<ul><li>接受参数<code>includeDeprecated</code>，默认为<span class="spec-keyword">false</span>。如过为<span class="spec-keyword">true</span>则弃用的字段也将返回。</li></ul></li></ul></section><section id="sec-Input-Object-" secid="4.2.2.6"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Input-Object-">4.2.2.6</a></span>Input Object/输入对象</h5><p>输入对象是复合类型，通常以具名输入值列表的形式作为查询的输入。</p><p>例如输入对象<code>Point</code>可以定义成：</p><pre><code>input Point {
  x: Int
  y: Int
}
</code></pre><p>字段</p><ul><li><code>kind</code>必须返回<code>__TypeKind.INPUT_OBJECT</code>。</li><li><code>name</code>必须返回字符串。</li><li><code>description</code>必须返回字符串或者<span class="spec-keyword">null</span>空值。</li><li><code>inputFields</code>：<code>InputValue</code>的列表。</li></ul></section><section id="sec-List-" secid="4.2.2.7"><h5><span class="spec-secid" title="link to this section"><a href="#sec-List-">4.2.2.7</a></span>List/列表</h5><p>列表表示一系列GraphQL值。列表类型是类型修改器：它在<code>ofType</code>中封装了另一个类型的实例，其定义了列表中的每个元素。</p><p>字段</p><ul><li><code>kind</code>必须返回<code>__TypeKind.LIST</code>。</li><li><code>ofType</code>：任意类型。</li><li>其他字段必须返回<span class="spec-keyword">null</span>空值。</li></ul></section><section id="sec-Type-Kinds-.Non-Null-" secid="4.2.2.8"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Type-Kinds-.Non-Null-">4.2.2.8</a></span>Non-Null/非空</h5><p>GraphQL类型都是可空的，<span class="spec-keyword">null</span>值是有效的字段类型返回值。</p><p>非空类型是类型修改器：它它在<code>ofType</code>中封装了另一个类型的实例。非空类型不允许<span class="spec-keyword">null</span>作为返回，也用于表示必要输入参数和必要输入对象字段。</p><ul><li><code>kind</code>必须返回<code>__TypeKind.NON_NULL</code>。</li><li><code>ofType</code>：除了Non&#8208;null外的所有类型。</li><li>其他字段必须返回<span class="spec-keyword">null</span>空值。</li></ul></section><section id="sec-Combining-List-and-Non-Null-" secid="4.2.2.9"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Combining-List-and-Non-Null-">4.2.2.9</a></span>Combining List and Non-Null/列表和非空的组合</h5><p>列表和非空可以通过组合以表示更为复杂的类型。</p><p>如果列表修改的类型是非空，那么列表不能包含任何<span class="spec-keyword">null</span>空值元素。</p><p>如果非空修改的类型是列表，那么不能接受<span class="spec-keyword">null</span>空值，但是空数组可接受。</p><p>如果列表修改的类型是列表，那么第一个列表的元素是第二个列表类型的列表。</p><p>非空类型不能修改另一个非空类型。</p></section></section><section id="sec-The-__Field-Type-__Field-" secid="4.2.3"><h4><span class="spec-secid" title="link to this section"><a href="#sec-The-__Field-Type-__Field-">4.2.3</a></span>The __Field Type/__Field类型</h4><p><code>__Field</code>类型表示对象或者接口类型的每一个字段。</p><p>字段</p><ul><li><code>name</code>必须返回字符串。</li><li><code>description</code>必须返回字符串或者<span class="spec-keyword">null</span>空值。</li><li><code>args</code>返回<code>__InputValue</code>的列表，表示这个字段接受的参数。</li><li><code>type</code>必须返回<code>__Type</code>，表示这个字段值的类型。</li><li><code>isDeprecated</code>返回<span class="spec-keyword">true</span>如果这个字段不应再被使用，否则<span class="spec-keyword">false</span>。</li><li><code>deprecationReason</code>可选，提供字段被弃用的原因。</li></ul></section><section id="sec-The-__InputValue-Type-__InputValue-" secid="4.2.4"><h4><span class="spec-secid" title="link to this section"><a href="#sec-The-__InputValue-Type-__InputValue-">4.2.4</a></span>The __InputValue Type/__InputValue类型</h4><p><code>__InputValue</code>类型表示字段和指令的参数，如同输入对象的<code>inputFields</code>字段。</p><p>字段</p><ul><li><code>name</code>必须返回字符串。</li><li><code>description</code>必须返回字符串或者<span class="spec-keyword">null</span>空值。</li><li><code>type</code>必须返回表示这个输入值期待的类型的<code>__Type</code>。</li><li><code>defaultValue</code>返回一个（使用GraphQL语言）字符串，表示这个输入值在运行时未提供值的情况下的默认值，如果这个输入值没有默认值，返回<span class="spec-keyword">null</span>空值。</li></ul></section><section id="sec-The-__EnumValue-Type-__EnumValue-" secid="4.2.5"><h4><span class="spec-secid" title="link to this section"><a href="#sec-The-__EnumValue-Type-__EnumValue-">4.2.5</a></span>The __EnumValue Type/__EnumValue类型</h4><p><code>__EnumValue</code>表示枚举型的可能值之一。</p><p>字段</p><ul><li><code>name</code>必须返回字符串。</li><li><code>description</code>必须返回字符串或者<span class="spec-keyword">null</span>空值。</li><li><code>isDeprecated</code>返回<span class="spec-keyword">true</span>如果这个字段不应再被使用，否则<span class="spec-keyword">false</span>。</li><li><code>deprecationReason</code>可选，提供字段被弃用的原因。</li></ul></section><section id="sec-The-__Directive-Type-__Directive-" secid="4.2.6"><h4><span class="spec-secid" title="link to this section"><a href="#sec-The-__Directive-Type-__Directive-">4.2.6</a></span>The __Directive Type/__Directive类型</h4><p><code>__Directive</code>类型表示服务器支持的一个指令。</p><p>字段</p><ul><li><code>name</code>必须返回字符串。</li><li><code>description</code>必须返回字符串或者<span class="spec-keyword">null</span>空值。</li><li><code>locations</code>返回<code>__DirectiveLocation</code>列表，表示指令可以放置的有效位置。</li><li><code>args</code>返回<code>__InputValue</code>的列表，表示这个字段接受的参数。 </li></ul></section></section></section><section id="sec-Validation-" secid="5"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Validation-">5</a></span>Validation/验证</h2><p>GraphQL不仅会检测一个请求是否句法上正确，还会其在给定GraphQL schema上下文内无歧义无错误。</p><p>一个无效请求依然是技术上可执行的，也能通过执行章节的步骤产生稳定的结果，但是相对于这个有验证错误的请求，其结果可能是有歧义的、意外不可预知的，所以对于无效请求，不应该予以执行。</p><p>典型的验证会在请求执行前的上下文中执行，但是如果给定请求之前已经通过验证，那么GraphQL服务在执行这个请求前可能不会显式的验证它，譬如一个请求在开发期已经通过验证，并假设他后面不会改变，或者服务器层验证了一个请求，记住了它的验证结果以避免后续再次验证同样的请求。因此任何客户端或者开发期工具，都应该汇报验证错误，并阻止构建或者执行当时已知错误的请求。</p><p><strong>Type system evolution/类型系统演变</strong></p><p>GraphQL类型系统可能会随着时间添加一些类型和字段，从而发生了演变，之前有效的请求之后可能就变得无效。任何让之前有效的请求变得无效的变化都称之为<em>破坏性变化</em>。GraphQL服务和schema维护者被鼓励要避免破坏性变化，但是为了保证面对破坏性变化的弹性，复杂的GraphQL系统可能依然允许执行<em>在某个点上</em>没有错误也未曾改变的请求。</p><p><strong>Examples/案例</strong></p><p>至于本章节的schema，我们假定有如下类型系统用于描述案例：</p><pre><code>enum DogCommand { SIT, DOWN, HEEL }

type Dog implements Pet {
  name: String!
  nickname: String
  barkVolume: Int
  doesKnowCommand(dogCommand: DogCommand!): Boolean!
  isHousetrained(atOtherHomes: Boolean): Boolean!
  owner: Human
}

interface Sentient {
  name: String!
}

interface Pet {
  name: String!
}

type Alien implements Sentient {
  name: String!
  homePlanet: String
}

type Human implements Sentient {
  name: String!
}

enum CatCommand { JUMP }

type Cat implements Pet {
  name: String!
  nickname: String
  doesKnowCommand(catCommand: CatCommand!): Boolean!
  meowVolume: Int
}

union CatOrDog = Cat | Dog
union DogOrHuman = Dog | Human
union HumanOrAlien = Human | Alien

type QueryRoot {
  dog: Dog
}
</code></pre><section id="sec-Validation-.Operations-" secid="5.1"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Validation-.Operations-">5.1</a></span>Operations/操作</h3><section id="sec-Named-Operation-Definitions-" secid="5.1.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Named-Operation-Definitions-">5.1.1</a></span>Named Operation Definitions/具名操作定义</h4><section id="sec-Operation-Name-Uniqueness-" secid="5.1.1.1"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Operation-Name-Uniqueness-">5.1.1.1</a></span>Operation Name Uniqueness/操作名唯一性</h5><p><strong>Formal Specification/形式规范</strong></p><ul><li>对于文档中的每一个操作定义<var>operation</var></li><li>使<var>operationName</var>为<var>operation</var>的名字。</li><li>如果存在<var>operationName</var><ul><li>使<var>operations</var>为文档中名为<var>operationName</var>的所有的操作定义。</li><li><var>operations</var>必然是只有一个值的集合。</li></ul></li></ul><p><strong>Explanatory Text/解释文本</strong></p><p>每一个具名操作定义必须是在其文档中唯一，以便于使用其名字指代。</p><p>例如下列文档就是有效的：</p><pre><code>query getDogName {
  dog {
    name
  }
}

query getOwnerName {
  dog {
    owner {
      name
    }
  }
}
</code></pre><p>然而这个文档是无效的：</p><pre class="spec-counter-example"><code>query getName {
  dog {
    name
  }
}

query getName {
  dog {
    owner {
      name
    }
  }
}
</code></pre><p>即便两个操作类型是不同的，它也是无效的：</p><pre class="spec-counter-example"><code>query dogOperation {
  dog {
    name
  }
}

mutation dogOperation {
  mutateDog {
    id
  }
}
</code></pre></section></section><section id="sec-Anonymous-Operation-Definitions-" secid="5.1.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Anonymous-Operation-Definitions-">5.1.2</a></span>Anonymous Operation Definitions/匿名操作定义</h4><section id="sec-Lone-Anonymous-Operation-" secid="5.1.2.1"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Lone-Anonymous-Operation-">5.1.2.1</a></span>Lone Anonymous Operation/单独匿名操作</h5><p><strong>Formal Specification/形式规范</strong></p><ul><li>使<var>operations</var>为文档中所有的操作定义。</li><li>使<var>anonymous</var>为文档中所有的匿名操作定义。</li><li>如果<var>operations</var>集合多余1个值:<ul><li><var>anonymous</var>必须为空.</li></ul></li></ul><p><strong>Explanatory Text/解释文本</strong></p><p>GraphQL允许在文档只有一个操作存在时用简写形式定义查询操作。</p><p>例如下列文档就是有效的：</p><pre><code>{
  dog {
    name
  }
}
</code></pre><p>然而这个文档是无效的：</p><pre class="spec-counter-example"><code>{
  dog {
    name
  }
}

query getName {
  dog {
    owner {
      name
    }
  }
}
</code></pre></section></section><section id="sec-Subscription-Operation-Definitions-" secid="5.1.3"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Subscription-Operation-Definitions-">5.1.3</a></span>Subscription Operation Definitions/订阅操作定义</h4><section id="sec-Single-root-field-" secid="5.1.3.1"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Single-root-field-">5.1.3.1</a></span>Single root field/单个根级字段</h5><p><strong>Formal Specification/形式规范</strong></p><ul><li>对于文档中的每一个订阅定义<var>subscription</var>。</li><li>使<var>rootFields</var>为<var>subscription</var>上的顶级选择集。<ul><li><var>rootFields</var>必然是只有一个值的集合。</li></ul></li></ul><p><strong>Explanatory Text/解释文本</strong></p><p>订阅操作必须只有一个根字段。</p><p>有效案例：</p><pre><code>subscription sub {
  newMessage {
    body
    sender
  }
}
</code></pre><pre><code>fragment newMessageFields on Message {
  body
  sender
}

subscription sub {
  newMessage {
    ... newMessageFields  
  }
}
</code></pre><p>无效案例：</p><pre class="spec-counter-example"><code>subscription sub {
  newMessage {
    body
    sender
  }
  disallowedSecondRootField
}
</code></pre><p>内省字段也是计算在内的，以下案例是无效的：</p><pre class="spec-counter-example"><code>subscription sub {
  newMessage {
    body
    sender
  }
  __typename
}
</code></pre></section></section></section><section id="sec-Validation-.Fields-" secid="5.2"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Validation-.Fields-">5.2</a></span>Fields/字段</h3><section id="sec-Field-Selections-on-Objects-Interfaces-and-Unions-Types-" secid="5.2.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Field-Selections-on-Objects-Interfaces-and-Unions-Types-">5.2.1</a></span>Field Selections on Objects, Interfaces, and Unions Types/对象、接口和联合上的字段选择</h4><p><strong>Formal Specification/形式规范</strong></p><ul><li>对于文档中的每一个<var>selection</var>。</li><li>使<var>fieldName</var>为<var>selection</var>的目标字段。</li><li><var>fieldName</var>必须定义在范围内的类型上。</li></ul><p><strong>Explanatory Text/解释文本</strong></p><p>字段选择的目标字段必须定义在选择集的范围类型上。对别名没有限制。</p><p>譬如下列片段无法通过验证：</p><pre class="spec-counter-example"><code>fragment fieldNotDefined on Dog {
  meowVolume
}

fragment aliasedLyingFieldTargetNotDefined on Dog {
  barkVolume: kawVolume
}
</code></pre><p>对于接口，直接的字段选择只能在字段上操作，（接口）具体实现（对象）的字段与给定接口类型选择集的有效性没有相关性。</p><p>例如，以下是有效的：</p><pre><code>fragment interfaceFieldSelection on Pet {
  name
}
</code></pre><p>而以下是无效的：</p><pre class="spec-counter-example"><code>fragment definedOnImplementorsButNotInterface on Pet {
  nickname
}
</code></pre><p>因为联合上并没有定义字段，字段没法直接从联合类型选择集上选出，除了元字段<var>__typename</var>这个特例。联合类型选择集上的字段必须仅通过片段查询。</p><p>例如，以下是有效的：</p><pre><code>fragment inDirectFieldSelectionOnUnion on CatOrDog {
  __typename
  ... on Pet {
    name
  }
  ... on Dog {
    barkVolume
  }
}
</code></pre><p>但是以下是无效的：</p><pre class="spec-counter-example"><code>fragment directFieldSelectionOnUnion on CatOrDog {
  name
  barkVolume
}
</code></pre></section><section id="sec-Field-Selection-Merging-" secid="5.2.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Field-Selection-Merging-">5.2.2</a></span>Field Selection Merging/字段选择合并</h4><p><strong>Formal Specification/形式规范</strong></p><ul><li>使<var>set</var>为GraphQL文档上定义的任意选择集。</li><li><span class="spec-call">FieldsInSetCanMerge(<var>set</var>)</span>必然为true。</li></ul><p>FieldsInSetCanMerge(set)：</p><ul><li>使<var>fieldsForName</var>为包含访问片段和内联片段的<var>set</var>中给定响应名的选择集。</li><li>假设<var>fieldsForName</var>有一对成员<var>fieldA</var>和<var>fieldB</var>：<ul><li><span class="spec-call">SameResponseShape(<var>fieldA</var>, <var>fieldB</var>)</span>必须为true。</li><li>如果<var>fieldA</var>和<var>fieldB</var>的父类型一样或者都不为对象类型：<ul><li><var>fieldA</var>和<var>fieldB</var>必然有相同的字段名。</li><li><var>fieldA</var>和<var>fieldB</var>必然有相同的参数集。</li><li>使<var>mergedSet</var>为选择集<var>fieldA</var>和<var>fieldB</var>相加的结果。</li><li><span class="spec-call">FieldsInSetCanMerge(<var>mergedSet</var>)</span>必然为true。</li></ul></li></ul></li></ul><p>SameResponseShape(fieldA, fieldB)：</p><ul><li>使<var>typeA</var>为<var>fieldA</var>的返回类型。</li><li>使<var>typeB</var>为<var>fieldB</var>的返回类型。</li><li>如果<var>typeA</var>或者<var>typeB</var>是Non&#8208;Null非空类型。<ul><li><var>typeA</var>和<var>typeB</var>必然两个都是Non&#8208;Null类型。</li><li>使<var>typeA</var>为<var>typeA</var>的可空类型</li><li>使<var>typeB</var>为<var>typeB</var>的可空类型</li></ul></li><li>如果<var>typeA</var>或者<var>typeB</var>是List列表类型。<ul><li><var>typeA</var>和<var>typeB</var>必然两个都是List类型</li><li>使<var>typeA</var>为<var>typeA</var>的元素类型</li><li>使<var>typeB</var>为<var>typeB</var>的元素类型</li><li>从第3步重复。</li></ul></li><li>如果<var>typeA</var>或者<var>typeB</var>是Scalar标量或者Enum枚举型。<ul><li><var>typeA</var>和<var>typeB</var>必然是相同类型。</li></ul></li><li>断言：<var>typeA</var>和<var>typeB</var>都是组合类型。</li><li>使<var>mergedSet</var>为选择集<var>fieldA</var>和<var>fieldB</var>相加的结果。</li><li>使<var>fieldsForName</var>为包含访问片段和内联片段的<var>set</var>中给定响应名的选择集。</li><li>假设<var>fieldsForName</var>有一对成员<var>subfieldA</var>和<var>subfieldB</var>：<ul><li><span class="spec-call">SameResponseShape(<var>subfieldA</var>, <var>subfieldB</var>)</span>必然为true。</li></ul></li></ul><p><strong>Explanatory Text/解释文本</strong></p><p>如果执行期间遇到了相同响应名的多个字段选择，执行的字段和参数以及结果值都应该避免歧义。然而，任意两个字段选择能在同一个对象里面遇到还是有效的，那只能是它们等价的情况。</p><p>对于简单的手写GraphQL，这个规则明显是一个开发者错误，然而对于嵌套片段，就很难手动检查到这个问题。</p><p>以下选择正确地合并：</p><pre><code>fragment mergeIdenticalFields on Dog {
  name
  name
}

fragment mergeIdenticalAliasesAndFields on Dog {
  otherName: name
  otherName: name
}
</code></pre><p>以下则无法合并：</p><pre class="spec-counter-example"><code>fragment conflictingBecauseAlias on Dog {
  name: nickname
  name
}
</code></pre><p>如果它们有相同的参数，那么这个相同的参数也会被合并。值和参数都能正确地合并。</p><p>例如以下正确地合并：</p><pre><code>fragment mergeIdenticalFieldsWithIdenticalArgs on Dog {
  doesKnowCommand(dogCommand: SIT)
  doesKnowCommand(dogCommand: SIT)
}

fragment mergeIdenticalFieldsWithIdenticalValues on Dog {
  doesKnowCommand(dogCommand: $dogCommand)
  doesKnowCommand(dogCommand: $dogCommand)
}
</code></pre><p>以下并不正确得合并：</p><pre class="spec-counter-example"><code>fragment conflictingArgsOnValues on Dog {
  doesKnowCommand(dogCommand: SIT)
  doesKnowCommand(dogCommand: HEEL)
}

fragment conflictingArgsValueAndVar on Dog {
  doesKnowCommand(dogCommand: SIT)
  doesKnowCommand(dogCommand: $dogCommand)
}

fragment conflictingArgsWithVars on Dog {
  doesKnowCommand(dogCommand: $varOne)
  doesKnowCommand(dogCommand: $varTwo)
}

fragment differingArgs on Dog {
  doesKnowCommand(dogCommand: SIT)
  doesKnowCommand
}
</code></pre><p>下面的字段不会合并在一起，然而它们也不会在同一个对象上相遇，所以它们是安全的：</p><pre><code>fragment safeDifferingFields on Pet {
  ... on Dog {
    volume: barkVolume
  }
  ... on Cat {
    volume: meowVolume
  }
}

fragment safeDifferingArgs on Pet {
  ... on Dog {
    doesKnowCommand(dogCommand: SIT)
  }
  ... on Cat {
    doesKnowCommand(catCommand: JUMP)
  }
}
</code></pre><p>然而，字段响应必须形状上能合并，譬如，标量不可变。下列例子中，<code>someValue</code>可能是<code>String</code>或者<code>Int</code>：</p><pre class="spec-counter-example"><code>fragment conflictingDifferingResponses on Pet {
  ... on Dog {
    someValue: nickname
  }
  ... on Cat {
    someValue: meowVolume
  }
}
</code></pre></section><section id="sec-Leaf-Field-Selections-" secid="5.2.3"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Leaf-Field-Selections-">5.2.3</a></span>Leaf Field Selections/叶子节点选择</h4><p><strong>Formal Specification/形式规范</strong></p><ul><li>对于文档中的每一个<var>selection</var></li><li>使<var>selectionType</var>为<var>selection</var>的结果类型</li><li>如果<var>selectionType</var>是一个标量：<ul><li>这个选择的下级选择必须为空</li></ul></li><li>如果<var>selectionType</var>是一个接口、联合或者对象<ul><li>这个选择的下级选择必<strong>不</strong>为空</li></ul></li></ul><p><strong>Explanatory Text/解释文本</strong></p><p>标量上的字段选择是不允许的，标量在任何GraphQL查询的都只是叶子节点。</p><p>下列是有效的。</p><pre><code>fragment scalarSelection on Dog {
  barkVolume
}
</code></pre><p>下列是无效的。</p><pre class="spec-counter-example"><code>fragment scalarSelectionsNotAllowedOnBoolean on Dog {
  barkVolume {
    sinceWhen
  }
}
</code></pre><p>相反的，GraphQL查询的叶子字段选择必须为标量。在接口、联合或者对象上的选择也不允许没有下级选择。</p><p>假设schema有下列查询根类型的补充内容：</p><pre><code>extend type QueryRoot {
  human: Human
  pet: Pet
  catOrDog: CatOrDog
}
</code></pre><p>以下案例是无效的</p><pre class="spec-counter-example"><code>query directQueryOnObjectWithoutSubFields {
  human
}

query directQueryOnInterfaceWithoutSubFields {
  pet
}

query directQueryOnUnionWithoutSubFields {
  catOrDog
}
</code></pre></section></section><section id="sec-Validation-.Arguments-" secid="5.3"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Validation-.Arguments-">5.3</a></span>Arguments/参数</h3><p>参数在字段和指令上都有使用，下列验证规则可应用于这两种情况。</p><section id="sec-Argument-Names-" secid="5.3.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Argument-Names-">5.3.1</a></span>Argument Names/参数名</h4><p><strong>Formal Specification/形式规范</strong></p><ul><li>对于文档中的每一个<var>argument</var>。</li><li>使<var>argumentName</var>为<var>argument</var>的名字。</li><li>使<var>argumentDefinition</var>为父字段提供的参数定义或者名为<var>argumentName</var>的的定义。</li><li><var>argumentDefinition</var>必然存在。</li></ul><p><strong>Explanatory Text/解释文本</strong></p><p>提供给字段或者指令的每一个参数，必须在字段或者指令的可能参数集合中定义。</p><p>譬如下列是有效的：</p><pre><code>fragment argOnRequiredArg on Dog {
  doesKnowCommand(dogCommand: SIT)
}

fragment argOnOptional on Dog {
  isHousetrained(atOtherHomes: true) @include(if: true)
}
</code></pre><p>下列是无效，因为<code>command</code>并没有定义在<code>DogCommand</code>上。</p><pre class="spec-counter-example"><code>fragment invalidArgName on Dog {
  doesKnowCommand(command: CLEAN_UP_HOUSE)
}
</code></pre><p>而这个也是无效，因为<code>unless</code>并没有定义在<code>@include</code>上。</p><pre class="spec-counter-example"><code>fragment invalidArgName on Dog {
  isHousetrained(atOtherHomes: true) @include(unless: false)
}
</code></pre><p>为了展示更复杂的参数案例，我们添加下列（补充内容）到我们的类型系统：</p><pre><code>type Arguments {
  multipleReqs(x: Int!, y: Int!): Int!
  booleanArgField(booleanArg: Boolean): Boolean
  floatArgField(floatArg: Float): Float
  intArgField(intArg: Int): Int
  nonNullBooleanArgField(nonNullBooleanArg: Boolean!): Boolean!
  booleanListArgField(booleanListArg: [Boolean]!): [Boolean]
}

extend type QueryRoot {
  arguments: Arguments
}
</code></pre><p>参数的顺序并不重要，因此下列两个案例对有效的：</p><pre><code>fragment multipleArgs on Arguments {
  multipleReqs(x: 1, y: 2)
}

fragment multipleArgsReverseOrder on Arguments {
  multipleReqs(y: 1, x: 2)
}
</code></pre></section><section id="sec-Argument-Uniqueness-" secid="5.3.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Argument-Uniqueness-">5.3.2</a></span>Argument Uniqueness/参数唯一性</h4><p>字段和指令将参数视作参数名到从参数值的映射，一个参数集合内有多于一个参数拥有一个样的参数名时将会产生歧义，也是无效的。</p><p><strong>Formal Specification/形式规范</strong></p><ul><li>对于文档中的每一个<var>argument</var>。</li><li>使<var>argumentName</var>为<var>argument</var>的名字。</li><li>使<var>arguments</var>为参数集合中所有具有<var>argumentName</var>的名字且包含<var>argument</var>的所有参数。</li><li><var>arguments</var>必然是只包含<var>argument</var>的集合。</li></ul></section><section id="sec-Argument-Values-Type-Correctness-" secid="5.3.3"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Argument-Values-Type-Correctness-">5.3.3</a></span>Argument Values Type Correctness/参数值类型正确性</h4><section id="sec-Compatible-Values-" secid="5.3.3.1"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Compatible-Values-">5.3.3.1</a></span>Compatible Values/兼容值</h5><p><strong>Formal Specification/形式规范</strong></p><ul><li>对于文档中的每一个<var>argument</var>。</li><li>使<var>value</var>为<var>argument</var>的值。</li><li>如果<var>value</var>不是一个变量<ul><li>使<var>argumentName</var>为<var>argument</var>的名字。</li><li>使<var>argumentDefinition</var>为父字段提供的参数定义或者名为<var>argumentName</var>的的定义。</li><li>使<var>type</var>为<var>argumentDefinition</var>所期望的类型。</li><li><var>literalArgument</var>的类型必须被转换为<var>type</var>。</li></ul></li></ul><p><strong>Explanatory Text/解释文本</strong></p><p>字面量值必须和使用它的参数的类型相兼容，兼容规则为类型系统章节所定义的转换规则。</p><p>譬如，一个Int型可以被转换为Float型。</p><pre><code>fragment goodBooleanArg on Arguments {
  booleanArgField(booleanArg: true)
}

fragment coercedIntIntoFloatArg on Arguments {
  floatArgField(floatArg: 1)
}
</code></pre><p>而String到Int则是不可转换的，因此下面的案例是无效的：</p><pre class="spec-counter-example"><code>fragment stringIntoInt on Arguments {
  intArgField(intArg: &quot;3&quot;)
}
</code></pre></section><section id="sec-Required-Non-Null-Arguments-" secid="5.3.3.2"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Required-Non-Null-Arguments-">5.3.3.2</a></span>Required Non-Null Arguments/必要非空参数</h5><ul><li>对于文档中的每一个字段或指令。</li><li>使<var>arguments</var>为字段或指令提供的参数。</li><li>使<var>argumentDefinitions</var>为字段或指令的参数定义集合。</li><li>对于<var>argumentDefinitions</var>上的每一个<var>definition</var>：<ul><li>使<var>type</var>为<var>definition</var>所需要的类型。</li><li>如果<var>type</var>是Non&#8208;Null非空：<ul><li>使<var>argumentName</var>为<var>definition</var>的名字。</li><li>使<var>argument</var>为<var>arguments</var>中名为<var>argumentName</var>的参数。</li><li><var>argument</var>必然存在。</li><li>使<var>value</var>为<var>argument</var>的值。</li><li><var>value</var>不可为<span class="spec-keyword">null</span>字面量。</li></ul></li></ul></li></ul><p><strong>Explanatory Text/解释文本</strong></p><p>参数也能是必要的，只要参数的类型是非空，那么这个参数就是必须的，且显式值<span class="spec-keyword">null</span>也不能用于此。否则参数是可选的。</p><p>例如以下是有效的：</p><pre><code>fragment goodBooleanArg on Arguments {
  booleanArgField(booleanArg: true)
}

fragment goodNonNullArg on Arguments {
  nonNullBooleanArgField(nonNullBooleanArg: true)
}
</code></pre><p>可空参数的字段，参数可以省略。</p><p>因此以下是有效的：</p><pre><code>fragment goodBooleanArgDefault on Arguments {
  booleanArgField
}
</code></pre><p>但是这对于一个非空参数就不是有效的了。</p><pre class="spec-counter-example"><code>fragment missingRequiredArg on Arguments {
  nonNullBooleanArgField
}
</code></pre><p>使用显式值<span class="spec-keyword">null</span>也是无效的。</p><pre class="spec-counter-example"><code>fragment missingRequiredArg on Arguments {
  notNullBooleanArgField(nonNullBooleanArg: null)
}
</code></pre></section></section></section><section id="sec-Validation-.Fragments-" secid="5.4"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Validation-.Fragments-">5.4</a></span>Fragments/片段</h3><section id="sec-Fragment-Declarations-" secid="5.4.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Fragment-Declarations-">5.4.1</a></span>Fragment Declarations/片段声明</h4><section id="sec-Fragment-Name-Uniqueness-" secid="5.4.1.1"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Fragment-Name-Uniqueness-">5.4.1.1</a></span>Fragment Name Uniqueness/片段名唯一性</h5><p><strong>Formal Specification/形式规范</strong></p><ul><li>对于文档中的每一个<var>fragment</var>。</li><li>使<var>fragmentName</var>为<var>fragment</var>的名字。</li><li>使<var>fragments</var>为文档中名为<var>fragmentName</var>的所有片段定义。</li><li><var>fragments</var>必然是只有一个值的集合。</li></ul><p><strong>Explanatory Text/解释文本</strong></p><p>片段定义在片段解构中使用名字引用。为避免歧义，每一个片段都必须是片段内唯一。</p><p>行内片段并不被当作片段定义，也不被这些验证规则影响。</p><p>例如以下文档是有效的：</p><pre><code>{
  dog {
    ...fragmentOne
    ...fragmentTwo
  }
}

fragment fragmentOne on Dog {
  name
}

fragment fragmentTwo on Dog {
  owner {
    name
  }
}
</code></pre><p>然而这个文档是无效的：</p><pre class="spec-counter-example"><code>{
  dog {
    ...fragmentOne
  }
}

fragment fragmentOne on Dog {
  name
}

fragment fragmentOne on Dog {
  owner {
    name
  }
}
</code></pre></section><section id="sec-Fragment-Spread-Type-Existence-" secid="5.4.1.2"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Fragment-Spread-Type-Existence-">5.4.1.2</a></span>Fragment Spread Type Existence/片段解构类型存在性</h5><p><strong>Formal Specification/形式规范</strong></p><ul><li>对于文档中的每一个文档解构<var>namedSpread</var></li><li>使<var>fragment</var>为<var>namedSpread</var>的目标</li><li><var>fragment</var>的目标类型必须在schema中定义过的。</li></ul><p><strong>Explanatory Text/解释文本</strong></p><p>片段必须在schema中存在的类型上指定，这同时适用于具名片段和内联片段。如果它们不存在于schema上，那么这个查询则无法通过验证。</p><p>譬如下列片段是有效的：</p><pre><code>fragment correctType on Dog {
  name
}

fragment inlineFragment on Dog {
  ... on Dog {
    name
  }
}

fragment inlineFragment2 on Dog {
  ... @include(if: true) {
    name
  }
}
</code></pre><p>而下列无法通过验证：</p><pre class="spec-counter-example"><code>fragment notOnExistingType on NotInSchema {
  name
}

fragment inlineNotExistingType on Dog {
  ... on NotInSchema {
    name
  }
}
</code></pre></section><section id="sec-Fragments-On-Composite-Types-" secid="5.4.1.3"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Fragments-On-Composite-Types-">5.4.1.3</a></span>Fragments On Composite Types/组合类型上的片段</h5><p><strong>Formal Specification/形式规范</strong></p><ul><li>对于定义在文档内的每一个<var>fragment</var>。</li><li>片段的目标类型必须是<span class="spec-nt">UNION</span>、<span class="spec-nt">INTERFACE</span>或者<span class="spec-nt">OBJECT</span>类型。</li></ul><p><strong>Explanatory Text/解释文本</strong></p><p>片段只能在联合、接口和对象上声明，在标量上是无效的，只能应用与非叶子节点，这个规则同时适用于具名片段和行内片段。</p><p>下列片段声明是有效的：</p><pre><code>fragment fragOnObject on Dog {
  name
}

fragment fragOnInterface on Pet {
  name
}

fragment fragOnUnion on CatOrDog {
  ... on Dog {
    name
  }
}
</code></pre><p>而下列是无效的：</p><pre class="spec-counter-example"><code>fragment fragOnScalar on Int {
  something
}

fragment inlineFragOnScalar on Dog {
  ... on Boolean {
    somethingElse
  }
}
</code></pre></section><section id="sec-Fragments-Must-Be-Used-" secid="5.4.1.4"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Fragments-Must-Be-Used-">5.4.1.4</a></span>Fragments Must Be Used/必须使用的片段</h5><p><strong>Formal Specification/形式规范</strong></p><ul><li>对于文档中的每一个<var>fragment</var>。</li><li><var>fragment</var>必然是文档中至少一个解构的目标。</li></ul><p><strong>Explanatory Text/解释文本</strong></p><p>已定义的片段必须在查询文档中使用。</p><p>例如下列是一个无效的查询文档：</p><pre class="spec-counter-example"><code>fragment nameFragment on Dog { # unused
  name
}

{
  dog {
    name
  }
}
</code></pre></section></section><section id="sec-Fragment-Spreads-" secid="5.4.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Fragment-Spreads-">5.4.2</a></span>Fragment Spreads/片段解构</h4><p>字段选择也被片段解构之间的互相调用决定。譬如目标片段的选择集和同级的引用目标片段相联合。</p><section id="sec-Fragment-spread-target-defined-" secid="5.4.2.1"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Fragment-spread-target-defined-">5.4.2.1</a></span>Fragment spread target defined/片段解构目标必须预先定义</h5><p><strong>Formal Specification/形式规范</strong></p><ul><li>对于文档中的每一个<var>namedSpread</var>。</li><li>使<var>fragment</var>为<var>namedSpread</var>的目标。</li><li><var>fragment</var>必须在文档中预先定义。</li></ul><p><strong>Explanatory Text/解释文本</strong></p><p>具名片段解构必须指定文档中已经定义的片段。如果结构的目标没有定义，则将会报错：</p><pre class="spec-counter-example"><code>{
  dog {
    ...undefinedFragment
  }
}
</code></pre></section><section id="sec-Fragment-spreads-must-not-form-cycles-" secid="5.4.2.2"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Fragment-spreads-must-not-form-cycles-">5.4.2.2</a></span>Fragment spreads must not form cycles/片段解构不可造成循环</h5><p><strong>Formal Specification/形式规范</strong></p><ul><li>对于文档中的每一个<var>fragmentDefinition</var></li><li>使<var>visited</var>为一个空集。</li><li><span class="spec-call">DetectCycles(<var>fragmentDefinition</var>, <var>visited</var>)</span></li></ul><p><span class="spec-call">DetectCycles(<var>fragmentDefinition</var>, <var>visited</var>)</span>：</p><ul><li>使<var>spreads</var>为为<var>fragmentDefinition</var>的所有片段解构后代。</li><li>对于<var>spreads</var>的每一个<var>spread</var><ul><li><var>visited</var>必不包含<var>spread</var></li><li>使<var>nextVisited</var>为包含<var>spread</var>和<var>visited</var>成员的集合</li><li>使<var>nextFragmentDefinition</var>为<var>spread</var>的目标</li><li><span class="spec-call">DetectCycles(<var>nextFragmentDefinition</var>, <var>nextVisited</var>)</span></li></ul></li></ul><p><strong>Explanatory Text/解释文本</strong></p><p>片段结构的图不可造成任何循环，即便是对自身的解构。否则一个操作会下层数据的环上无尽地结构无尽地执行。</p><p>这使可能导致无尽解构的片段失效；</p><pre class="spec-counter-example"><code>{
  dog {
    ...nameFragment
  }
}

fragment nameFragment on Dog {
  name
  ...barkVolumeFragment
}

fragment barkVolumeFragment on Dog {
  barkVolume
  ...nameFragment
}
</code></pre><p>如果上述片段被引入，则会导致结果无限大：</p><pre><code>{
  dog {
    name
    barkVolume
    name
    barkVolume
    name
    barkVolume
    name
    # forever...
  }
}
</code></pre><p>这也会使导致循环数据上结果无限递归的片段无效：</p><pre class="spec-counter-example"><code>{
  dog {
    ...dogFragment
  }
}

fragment dogFragment on Dog {
  name
  owner {
    ...ownerFragment
  }
}

fragment ownerFragment on Dog {
  name
  pets {
    ...dogFragment
  }
}
</code></pre></section><section id="sec-Fragment-spread-is-possible-" secid="5.4.2.3"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Fragment-spread-is-possible-">5.4.2.3</a></span>Fragment spread is possible/片段结构必须可行</h5><p><strong>Formal Specification/形式规范</strong></p><ul><li>对于文档中定义的每样个（具名的和内联的）<var>spread</var>。</li><li>使<var>fragment</var>为<var>spread</var>的目标。</li><li>使<var>fragmentType</var>为<var>fragment</var>的类型条件</li><li>使<var>parentType</var>为包含<var>spread</var>的类型选择集合</li><li>使<var>applicableTypes</var>为<span class="spec-call">GetPossibleTypes(<var>fragmentType</var>)</span>和<span class="spec-call">GetPossibleTypes(<var>parentType</var>)</span>的交集。</li><li><var>applicableTypes</var>必不为空。</li></ul><p>GetPossibleTypes(type)：</p><ul><li>如果<var>type</var>是一个object/对象类型非，返回包含<var>type</var>的集合</li><li>如果<var>type</var>是一个interface/接口类型非，返回实现<var>type</var>的集合</li><li>如果<var>type</var>是一个union/联合类型非，返回<var>type</var>的可能类型的集合</li></ul><p><strong>Explanatory Text/解释文本</strong></p><p>片段在一个类型上声明，并只在这个运行时对象匹配类型条件的时候应用。它们也能在父类型的上下文中解构。片段解构只有在类型条件能够应用与父类型的时候有效。</p><section id="sec-Object-Spreads-In-Object-Scope-" secid="5.4.2.3.1"><h6><span class="spec-secid" title="link to this section"><a href="#sec-Object-Spreads-In-Object-Scope-">5.4.2.3.1</a></span>Object Spreads In Object Scope/对象范围内的对象解构</h6><p>在一个对象类型范围内，唯一有效的对象类型片段解构是能够应用与范围内同一类型的（片段）。</p><p>例如：</p><pre><code>fragment dogFragment on Dog {
  ... on Dog {
    barkVolume
  }
}
</code></pre><p>而下列是无效的</p><pre class="spec-counter-example"><code>fragment catInDogFragmentInvalid on Dog {
  ... on Cat {
    meowVolume
  }
}
</code></pre></section><section id="sec-Abstract-Spreads-in-Object-Scope-" secid="5.4.2.3.2"><h6><span class="spec-secid" title="link to this section"><a href="#sec-Abstract-Spreads-in-Object-Scope-">5.4.2.3.2</a></span>Abstract Spreads in Object Scope/对象范围内的抽象解构</h6><p>在对象类型的范围，联合或者接口解构仅在对象类型实现了接口或者是联合的成员的时候可用。</p><p>例如</p><pre><code>fragment petNameFragment on Pet {
  name
}

fragment interfaceWithinObjectFragment on Dog {
  ...petNameFragment
}
</code></pre><p>是有效的，因为<span class="spec-nt">Dog</span>实现了<span class="spec-nt">Pet</span></p><p>同样</p><pre><code>fragment catOrDogNameFragment on CatOrDog {
  ... on Cat {
    meowVolume
  }
}

fragment unionWithObjectFragment on Dog {
  ...catOrDogNameFragment
}
</code></pre><p>是有效的，因为<span class="spec-nt">Dog</span>是<span class="spec-nt">CatOrDog</span>联合的成员。如果观察<span class="spec-nt">CatOrDogNameFragment</span>的内容，结果你发现没有任何有效结果可以返回，那么这个解构是没有意义的。但我们并不说这个是无效的，因为我们仅仅考虑片段声明，而非其主体。</p></section><section id="sec-Object-Spreads-In-Abstract-Scope-" secid="5.4.2.3.3"><h6><span class="spec-secid" title="link to this section"><a href="#sec-Object-Spreads-In-Abstract-Scope-">5.4.2.3.3</a></span>Object Spreads In Abstract Scope/抽象范围内的对象解构</h6><p>在对象类型片段范围内，联合或者接口解构仅在对象类型是接口或者联合的可能类型之一时可用。</p><p>例如，下列片段是有效的：</p><pre><code>fragment petFragment on Pet {
  name
  ... on Dog {
    barkVolume
  }
}

fragment catOrDogFragment on CatOrDog {
  ... on Cat {
    meowVolume
  }
}
</code></pre><p><var>petFragment</var>有效是因为<span class="spec-nt">Dog</span>实现了<span class="spec-nt">Pet</span>。 <var>catOrDogFragment</var>有效是因为<span class="spec-nt">Cat</span>是<span class="spec-nt">CatOrDog</span>联合的成员。</p><p>相反地，下列片段是无效的：</p><pre class="spec-counter-example"><code>fragment sentientFragment on Sentient {
  ... on Dog {
    barkVolume
  }
}

fragment humanOrAlienFragment on HumanOrAlien {
  ... on Cat {
    meowVolume
  }
}
</code></pre><p><span class="spec-nt">Dog</span>并没有实现<span class="spec-nt">Sentient</span>接口，因此<var>sentientFragment</var>永远不会返回有意义的结果。因此这这个片段是无效的。同样的<span class="spec-nt">Cat</span>并不是<span class="spec-nt">HumanOrAlien</span>联合的成员，它也永远不会返回有意义的结果，从而是它无效了。</p></section><section id="sec-Abstract-Spreads-in-Abstract-Scope-" secid="5.4.2.3.4"><h6><span class="spec-secid" title="link to this section"><a href="#sec-Abstract-Spreads-in-Abstract-Scope-">5.4.2.3.4</a></span>Abstract Spreads in Abstract Scope/抽象范围内的抽象解构</h6><p>联合或者接口解构能在互相内部使用。只要存在<em>一个</em>对象在可能集合的交集中，这个对象的解构就被视为有效的。</p><p>因此下例</p><pre><code>fragment unionWithInterface on Pet {
  ...dogOrHumanFragment
}

fragment dogOrHumanFragment on DogOrHuman {
  ... on Dog {
    barkVolume
  }
}
</code></pre><p>被视作有效，以内<span class="spec-nt">Dog</span>实现了<span class="spec-nt">Pet</span>并是<span class="spec-nt">DogOrHuman</span>的成员。</p><p>然而</p><pre class="spec-counter-example"><code>fragment nonIntersectingInterfaces on Pet {
  ...sentientFragment
}

fragment sentientFragment on Sentient {
  name
}
</code></pre><p>并不有效，因为不存在同时实现了<span class="spec-nt">Pet</span>和<span class="spec-nt">Sentient</span>的类型。</p></section></section></section></section><section id="sec-Values-" secid="5.5"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Values-">5.5</a></span>Values/值</h3><section id="sec-Input-Object-Field-Uniqueness-" secid="5.5.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Input-Object-Field-Uniqueness-">5.5.1</a></span>Input Object Field Uniqueness/输入对象字段唯一性</h4><p><strong>Formal Specification/形式规范</strong></p><ul><li>对于文档中的每一个输入对象值<var>inputObject</var>。</li><li>对于<var>inputObject</var>中的每一个<var>inputField</var><ul><li>使<var>name</var>为<var>inputField</var>的名字</li><li>使<var>fields</var> be all Input Object Fields named <var>name</var> in <var>inputObject</var>.</li><li><var>fields</var>必然是仅包含<var>inputField</var>的集合。</li></ul></li></ul><p><strong>Explanatory Text/解释文本</strong></p><p>输入对象不能包含多余一个同名的字段，否则存在让部分句法被忽略的歧义。</p><p>例如，下列查询并不会通过验证。</p><pre class="spec-counter-example"><code>{
  field(arg: { field: true, field: false })
}
</code></pre></section></section><section id="sec-Validation-.Directives-" secid="5.6"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Validation-.Directives-">5.6</a></span>Directives/指令</h3><section id="sec-Directives-Are-Defined-" secid="5.6.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Directives-Are-Defined-">5.6.1</a></span>Directives Are Defined/指令必须预先定义</h4><p><strong>Formal Specification/形式规范</strong></p><ul><li>对于文档中的每一个<var>directive</var>。</li><li>使<var>directiveName</var>为<var>directive</var>的名字。</li><li>使<var>directiveDefinition</var>为名为<var>directiveName</var>的指令。</li><li><var>directiveDefinition</var>必然存在。</li></ul><p><strong>Explanatory Text/解释文本</strong></p><p>GraphQL服务器定义他们支持的指令，对于每个指令的使用，必须要指令在服务器上可用。</p></section><section id="sec-Directives-Are-In-Valid-Locations-" secid="5.6.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Directives-Are-In-Valid-Locations-">5.6.2</a></span>Directives Are In Valid Locations/指令必须在有效位置</h4><p><strong>Formal Specification/形式规范</strong></p><ul><li>对于文档中的每一个<var>directive</var>。</li><li>使<var>directiveName</var>为<var>directive</var>的名字。</li><li>使<var>directiveDefinition</var>为名为<var>directiveName</var>的指令。</li><li>使<var>locations</var>为<var>directiveDefinition</var>的有效位置。</li><li>使<var>adjacent</var>为收到指令影响的AST（抽象语法树）节点。</li><li><var>adjacent</var>必须以<var>locations</var>内的元素来表示。</li></ul><p><strong>Explanatory Text/解释文本</strong></p><p>GraphQL定义了他们支持的指令，在何处支持。每一指令的使用，都必须在服务器声明支持使用的地方。</p><p>譬如，下列查询无法通过验证，因为<code>@skip</code>在<code>QUERY</code>上，并不是有效位置。</p><pre class="spec-counter-example"><code>query @skip(if: $foo) {
  field
}
</code></pre></section><section id="sec-Directives-Are-Unique-Per-Location-" secid="5.6.3"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Directives-Are-Unique-Per-Location-">5.6.3</a></span>Directives Are Unique Per Location/每个位置的指令都必须唯一</h4><p><strong>Formal Specification/形式规范</strong></p><ul><li>对于文档中指令可是应用的<var>location</var>：<ul><li>使<var>directives</var>为应用于<var>location</var>的指令集合。</li><li>对于<var>directives</var>中的每一个<var>directive</var>：<ul><li>使<var>directiveName</var>为<var>directive</var>的名字。</li><li>使<var>namedDirectives</var>为<var>directives</var>中名为<var>directiveName</var>的指令集合。</li><li><var>namedDirectives</var>必然是只有一个值的集合。</li></ul></li></ul></li></ul><p><strong>Explanatory Text/解释文本</strong></p><p>指令用于描述其应用的定义的元数据或者表现的改变。当同名的指令多次使用时，期望的源数据或者表现就会变得有歧义，因此一个位置上只允许使用一个指令。</p><p>譬如，下列查询不会通过验证，因为<code>@skip</code>在同一个字段上用了两次：</p><pre class="spec-counter-example"><code>query ($foo: Boolean = true, $bar: Boolean = false) {
  field @skip(if: $foo) @skip(if: $bar)
}
</code></pre><p>但是下面案例是有效的，因为<code>@skip</code>在每个位置只用了一次，即便在查询中同名的字段上用了两次：</p><pre><code>query ($foo: Boolean = true, $bar: Boolean = false) {
  field @skip(if: $foo) {
    subfieldA
  }
  field @skip(if: $bar) {
    subfieldB
  }
}
</code></pre></section></section><section id="sec-Validation-.Variables-" secid="5.7"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Validation-.Variables-">5.7</a></span>Variables/变量</h3><section id="sec-Variable-Uniqueness-" secid="5.7.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Variable-Uniqueness-">5.7.1</a></span>Variable Uniqueness/变量唯一性</h4><p><strong>Formal Specification/形式规范</strong></p><ul><li>对于文档中的每一个<var>operation</var><ul><li>对于<var>operation</var>中定义的每一个<var>variable</var><ul><li>使<var>variableName</var>为<var>variable</var>的名字</li><li>使<var>variables</var>为<var>operation</var>上名为<var>variableName</var>的变量集合</li><li><var>variables</var>必然是只有一个值的集合。</li></ul></li></ul></li></ul><p><strong>Explanatory Text/解释文本</strong></p><p>任意操作定了多于一个同名变量，将会变得有歧义，并是无效的。即便重复变量的值是一样的，他也是无效的。</p><pre class="spec-counter-example"><code>query houseTrainedQuery($atOtherHomes: Boolean, $atOtherHomes: Boolean) {
  dog {
    isHousetrained(atOtherHomes: $atOtherHomes)
  }
}
</code></pre><p>多个操作可以具有相同的变量名，特别是两个操作引用了同一个片段，这时候同名变量就是必要的了：</p><pre><code>query A($atOtherHomes: Boolean) {
  ...HouseTrainedFragment
}

query B($atOtherHomes: Boolean) {
  ...HouseTrainedFragment
}

fragment HouseTrainedFragment {
  dog {
    isHousetrained(atOtherHomes: $atOtherHomes)
  }
}
</code></pre></section><section id="sec-Variable-Default-Values-Are-Correctly-Typed-" secid="5.7.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Variable-Default-Values-Are-Correctly-Typed-">5.7.2</a></span>Variable Default Values Are Correctly Typed/变量默认值必须是正确的类型</h4><p><strong>Formal Specification/形式规范</strong></p><ul><li>对于文档中的每一个<var>operation</var></li><li>对于每一个<var>operation</var>上的每一个<var>variable</var><ul><li>使<var>variableType</var>为<var>variable</var>的类型</li><li>如果<var>variableType</var>是non&#8208;null非空，则不能有默认值。</li><li>如果<var>variable</var>有默认值，则其必须是同样的类型或者能转换到<var>variableType</var></li></ul></li></ul><p><strong>Explanatory Text/解释文本</strong></p><p>操作中定一个变量都是可以定义默认值的，如果对应类型不是non&#8208;null。</p><p>例如，下列查询能通过验证。</p><pre><code>query houseTrainedQuery($atOtherHomes: Boolean = true) {
  dog {
    isHousetrained(atOtherHomes: $atOtherHomes)
  }
}
</code></pre><p>但是如果变量被定义为非空类型，那么默认值是不可达的，因此下列如同这样的查询就不会通过验证</p><pre class="spec-counter-example"><code>query houseTrainedQuery($atOtherHomes: Boolean! = true) {
  dog {
    isHousetrained(atOtherHomes: $atOtherHomes)
  }
}
</code></pre><p>默认值必须和变量类型兼容，必须是匹配或者能转换到这种类型。</p><p>不匹配的类型会失败，如下例：</p><pre class="spec-counter-example"><code>query houseTrainedQuery($atOtherHomes: Boolean = &quot;true&quot;) {
  dog {
    isHousetrained(atOtherHomes: $atOtherHomes)
  }
}
</code></pre><p>然而如果类型是可转换的，查询就能通过。</p><p>例如：</p><pre><code>query intToFloatQuery($floatVar: Float = 1) {
  arguments {
    floatArgField(floatArg: $floatVar)
  }
}
</code></pre></section><section id="sec-Variables-Are-Input-Types-" secid="5.7.3"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Variables-Are-Input-Types-">5.7.3</a></span>Variables Are Input Types/变量必须是输入类型</h4><p><strong>Formal Specification/形式规范</strong></p><ul><li>对<var>document</var>中的每一个<var>operation</var></li><li>对每一个<var>operation</var>上的每一个<var>variable</var><ul><li>使<var>variableType</var>为<var>variable</var>的类型</li><li>当<var>variableType</var>是<span class="spec-nt">LIST</span>或者<span class="spec-nt">NON_NULL</span><ul><li>使<var>variableType</var>为<var>variableType</var>引用的类型</li></ul></li><li><var>variableType</var>必然是<span class="spec-nt">SCALAR</span>、<span class="spec-nt">ENUM</span>或者<span class="spec-nt">INPUT_OBJECT</span>类型</li></ul></li></ul><p><strong>Explanatory Text/解释文本</strong></p><p>变量只能是标量、枚举型和输入对象，或者这些类型的列表和非空封装变体，这些是输入类型。而对象、联合、接口不能作为输入。</p><p>对于这些的案例，假设有如下类型系统补充内容：</p><pre><code>input ComplexInput { name: String, owner: String }

extend type QueryRoot {
  findDog(complex: ComplexInput): Dog
  booleanList(booleanListArg: [Boolean!]): Boolean
}
</code></pre><p>下列查询是有效的：</p><pre><code>query takesBoolean($atOtherHomes: Boolean) {
  dog {
    isHousetrained(atOtherHomes: $atOtherHomes)
  }
}

query takesComplexInput($complexInput: ComplexInput) {
  findDog(complex: $complexInput) {
    name
  }
}

query TakesListOfBooleanBang($booleans: [Boolean!]) {
  booleanList(booleanListArg: $booleans)
}
</code></pre><p>下列查询是无效的：</p><pre class="spec-counter-example"><code>query takesCat($cat: Cat) {
  # ...
}

query takesDogBang($dog: Dog!) {
  # ...
}

query takesListOfPet($pets: [Pet]) {
  # ...
}

query takesCatOrDog($catOrDog: CatOrDog) {
  # ...
}
</code></pre></section><section id="sec-All-Variable-Uses-Defined-" secid="5.7.4"><h4><span class="spec-secid" title="link to this section"><a href="#sec-All-Variable-Uses-Defined-">5.7.4</a></span>All Variable Uses Defined/所有变量的使用必须预先定义</h4><p><strong>Formal Specification/形式规范</strong></p><ul><li>对于文档中的每一个<var>operation</var><ul><li>对于范围内的每一个<var>variableUsage</var>，变量必须在<var>operation</var>的变量列表中。</li><li>使<var>fragments</var>为<var>operation</var>传递引用的每一个片段</li><li>对于<var>fragments</var>中的每一个<var>fragment</var><ul><li>对于<var>fragment</var>范围内的每一个<var>variableUsage</var>，变量必须在<var>operation</var>的变量列表中。</li></ul></li></ul></li></ul><p><strong>Explanatory Text/解释文本</strong></p><p>变量的有效范围是在每一个操作内的，也就是说任何在操作上下文中要使用的变量，必须在那个操作的顶部预先定义。</p><p>例如：</p><pre><code>query variableIsDefined($atOtherHomes: Boolean) {
  dog {
    isHousetrained(atOtherHomes: $atOtherHomes)
  }
}
</code></pre><p>是有效的，$<var>atOtherHomes</var>由这个操作定义。</p><p>相反，下面这个操作是无效的：</p><pre class="spec-counter-example"><code>query variableIsNotDefined {
  dog {
    isHousetrained(atOtherHomes: $atOtherHomes)
  }
}
</code></pre><p>$<var>atOtherHomes</var>并没有被操作定义。</p><p>片段使这个规则复杂，被操作引入的任何片段都能接入那个操作定义的变量。片段可以出现在多个操作内，因此变量的使用必须和所有操作上的变量定义对应。</p><p>譬如，下列是有效的：</p><pre><code>query variableIsDefinedUsedInSingleFragment($atOtherHomes: Boolean) {
  dog {
    ...isHousetrainedFragment
  }
}

fragment isHousetrainedFragment on Dog {
  isHousetrained(atOtherHomes: $atOtherHomes)
}
</code></pre><p>因为<var>isHousetrainedFragment</var>在<var>variableIsDefinedUsedInSingleFragment</var>操作的上下文中使用，其参数也被也在这个操作上定义。</p><p>另一面，如果操作内引入的片段所使用的参数并没有在操作上定义，那么这个查询是无效的。</p><pre class="spec-counter-example"><code>query variableIsNotDefinedUsedInSingleFragment {
  dog {
    ...isHousetrainedFragment
  }
}

fragment isHousetrainedFragment on Dog {
  isHousetrained(atOtherHomes: $atOtherHomes)
}
</code></pre><p>这也是传递应用的，所以下列会失败：</p><pre class="spec-counter-example"><code>query variableIsNotDefinedUsedInNestedFragment {
  dog {
    ...outerHousetrainedFragment
  }
}

fragment outerHousetrainedFragment on Dog {
  ...isHousetrainedFragment
}

fragment isHousetrainedFragment on Dog {
  isHousetrained(atOtherHomes: $atOtherHomes)
}
</code></pre><p>片段使用的变量必须在所有的操作上定义。</p><pre><code>query housetrainedQueryOne($atOtherHomes: Boolean) {
  dog {
    ...isHousetrainedFragment
  }
}

query housetrainedQueryTwo($atOtherHomes: Boolean) {
  dog {
    ...isHousetrainedFragment
  }
}

fragment isHousetrainedFragment on Dog {
  isHousetrained(atOtherHomes: $atOtherHomes)
}
</code></pre><p>然而下面这个并不通过验证：</p><pre class="spec-counter-example"><code>query housetrainedQueryOne($atOtherHomes: Boolean) {
  dog {
    ...isHousetrainedFragment
  }
}

query housetrainedQueryTwoNotDefined {
  dog {
    ...isHousetrainedFragment
  }
}

fragment isHousetrainedFragment on Dog {
  isHousetrained(atOtherHomes: $atOtherHomes)
}
</code></pre><p>这是因为<var>housetrainedQueryTwoNotDefined</var>并没有定变量$<var>atOtherHomes</var>，但是这个变量被<var>isHousetrainedFragment</var>操作引入使用。</p></section><section id="sec-All-Variables-Used-" secid="5.7.5"><h4><span class="spec-secid" title="link to this section"><a href="#sec-All-Variables-Used-">5.7.5</a></span>All Variables Used/所有变量都必须被使用</h4><p><strong>Formal Specification/形式规范</strong></p><ul><li>对于文档中的每一个<var>operation</var>。</li><li>使<var>variables</var>为<var>operation</var>上定义的变量。</li><li><var>variables</var>中的每一个<var>variable</var>必须至少被使用一次，无论是操作本身使用，还是操作引入的片段通过传递引用使用。</li></ul><p><strong>Explanatory Text/解释文本</strong></p><p>操作上定义的所有变量必须至少被使用一次，无论是操作本身使用，还是操作引入的片段通过传递引用使用。未使用的变量会导致验证错误。</p><p>例如，下列是无效的：</p><pre class="spec-counter-example"><code>query variableUnused($atOtherHomes: Boolean) {
  dog {
    isHousetrained
  }
}
</code></pre><p>因为$<var>atOtherHomes</var>没有被引用过。</p><p>这个规则也适用于片段解构的传递引用：</p><pre><code>query variableUsedInFragment($atOtherHomes: Boolean) {
  dog {
    ...isHousetrainedFragment
  }
}

fragment isHousetrainedFragment on Dog {
  isHousetrained(atOtherHomes: $atOtherHomes)
}
</code></pre><p>上面是有效的，因为$<var>atOtherHomes</var>在<var>isHousetrainedFragment</var>中被使用过了，其由<var>variableUsedInFragment</var>引入。</p><p>如果那个片段没有引用$<var>atOtherHomes</var>，则是无效的：</p><pre class="spec-counter-example"><code>query variableNotUsedWithinFragment($atOtherHomes: Boolean) {
  ...isHousetrainedWithoutVariableFragment
}

fragment isHousetrainedWithoutVariableFragment on Dog {
  isHousetrained
}
</code></pre><p>一个文档中的所有操作都必须使用他们所有的变量。</p><p>从而，下列文档是无效的：</p><pre class="spec-counter-example"><code>query queryWithUsedVar($atOtherHomes: Boolean) {
  dog {
    ...isHousetrainedFragment
  }
}

query queryWithExtraVar($atOtherHomes: Boolean, $extra: Int) {
  dog {
    ...isHousetrainedFragment
  }
}

fragment isHousetrainedFragment on Dog {
  isHousetrained(atOtherHomes: $atOtherHomes)
}
</code></pre><p>这个文档是无效的，因为<var>queryWithExtraVar</var>定义了额外的一个变量。</p></section><section id="sec-All-Variable-Usages-are-Allowed-" secid="5.7.6"><h4><span class="spec-secid" title="link to this section"><a href="#sec-All-Variable-Usages-are-Allowed-">5.7.6</a></span>All Variable Usages are Allowed/所有变量都允许使用</h4><p><strong>Formal Specification/形式规范</strong></p><ul><li><var>document</var>中的每一个<var>operation</var></li><li>使<var>variableUsages</var>为<var>operation</var>引入的所有传递使用。</li><li>对于<var>variableUsages</var>中的每一个<var>variableUsage</var><ul><li>使<var>variableType</var>为<var>operation</var>上的变量定义的的类型。 </li><li>使<var>argumentType</var>为传递进去的参数的类型。</li><li>使<var>hasDefault</var>为true，如果参数定义有默认值。</li><li>AreTypesCompatible(<var>argumentType</var>, <var>variableType</var>, <var>hasDefault</var>)必然为true</li></ul></li><li>AreTypesCompatible(<var>argumentType</var>,<var>variableType</var>, <var>hasDefault</var>)：<ul><li>如果<var>hasDefault</var>为true，把<var>variableType</var>当作non&#8208;null非空。</li><li>如果<var>argumentType</var>和<var>variableType</var>的内部类型不相同，返回falae</li><li>如果<var>argumentType</var>和<var>variableType</var>的列表纬度不相同，返回falae</li><li>如果<var>variableType</var>的任意列表层级不是non&#8208;null，而<var>argument</var>对应的是non&#8208;null，则类型不兼容。</li></ul></li></ul><p><strong>Explanatory Text/解释文本</strong></p><p>变量使用必须和它们传递进去的参数兼容。</p><p>验证失败会发生在变量在类型上下文完全不匹配和传递可空类型参数给非空类型变量的时候。</p><p>类型必须匹配：</p><pre class="spec-counter-example"><code>query intCannotGoIntoBoolean($intArg: Int) {
  arguments {
    booleanArgField(booleanArg: $intArg)
  }
}
</code></pre><p>$<var>intArg</var>是<span class="spec-nt">Int</span>类型，不能作为参数传递给<span class="spec-nt">Boolean</span>类型的<var>booleanArg</var>。</p><p>列表基数也必须一样。例如，列表不能传递给单数值。</p><pre class="spec-counter-example"><code>query booleanListCannotGoIntoBoolean($booleanListArg: [Boolean]) {
  arguments {
    booleanArgField(booleanArg: $booleanListArg)
  }
}
</code></pre><p>可空性也同样重要。通常，空值变量不可传递给非空变量。</p><pre class="spec-counter-example"><code>query booleanArgQuery($booleanArg: Boolean) {
  arguments {
    nonNullBooleanArgField(nonNullBooleanArg: $booleanArg)
  }
}
</code></pre><p>主要注意的例外是有默认参数的情况，这个参数会被视作非空。</p><pre><code>query booleanArgQueryWithDefault($booleanArg: Boolean = true) {
  arguments {
    nonNullBooleanArgField(nonNullBooleanArg: $booleanArg)
  }
}
</code></pre><p>对于列表类型，跟可空性类似的规则同时应用与外部和内部类型，一个可空列表不能传入一个非空列表，一个可空值的列表不能传递给一个非空值的列表。 下列是有效的：</p><pre><code>query nonNullListToList($nonNullBooleanList: [Boolean]!) {
  arguments {
    booleanListArgField(booleanListArg: $nonNullBooleanList)
  }
}
</code></pre><p>然而，一个可空列表不能传入一个非空列表：</p><pre class="spec-counter-example"><code>query listToNonNullList($booleanList: [Boolean]) {
  arguments {
    nonNullBooleanListField(nonNullBooleanListArg: $booleanList)
  }
}
</code></pre><p>这个的验证会失败，因为<code>[T]</code>不能传递给<code>[T]!</code>。</p><p>类似的，<code>[T]</code>也不能传递给<code>[T!]</code>。 </p></section></section></section><section id="sec-Execution-" secid="6"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Execution-">6</a></span>Execution/执行</h2><p>GraphQL通过执行来从请求生成响应。</p><p>一个用于执行的请求包含以信息的一部分：</p><ul><li>要用的schema，典型情况下由GraphQL服务单独提供。</li><li>包含操作和片段的文档。</li><li>可选：要执行的操作名。</li><li>可选：操作定义的变量所需的值。</li><li>一个执行期对应于根级类型的初始值。 概念上而言，初始值代表GraphQL服务下可用的数据的&ldquo;宇宙&rdquo;。对于一个GraphQL服务而言，通常执行每个请求都会使用相同初始值。</li></ul><p>有了这些信息，<span class="spec-call">ExecuteRequest()</span>的结果就能生成响应，然后按照下述响应一节来格式化。</p><section id="sec-Executing-Requests-" secid="6.1"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Executing-Requests-">6.1</a></span>Executing Requests/执行请求</h3><p>要执行请求，执行器必须有一个解析过的<code>Document</code>/文档（本规范的&ldquo;Query Language&rdquo;部分有定义过），如果文档中定义了多个操作还需要有选择的操作名，不然文档将被视为只包含一个操作。请求的结果取决于其操作根据下文&ldquo;Executing Operations&rdquo;一节执行的结果。</p><p>ExecuteRequest(schema, document, operationName, variableValues, initialValue)：</p><ul><li>使<var>operation</var>为<span class="spec-call">GetOperation(<var>document</var>, <var>operationName</var>)</span>的结果。</li><li>使<var>coercedVariableValues</var>为<span class="spec-call">CoerceVariableValues(<var>schema</var>, <var>operation</var>, <var>variableValues</var>)</span>的结果。</li><li>如果<var>operation</var>是一个查询操作：<ul><li>返回<span class="spec-call">ExecuteQuery(<var>operation</var>, <var>schema</var>, <var>coercedVariableValues</var>, <var>initialValue</var>)</span>。</li></ul></li><li>或者如果<var>operation</var>是一个更改操作：<ul><li>返回<span class="spec-call">ExecuteMutation(<var>operation</var>, <var>schema</var>, <var>coercedVariableValues</var>, <var>initialValue</var>)</span>。</li></ul></li><li>或者如果<var>operation</var>是一个订阅操作：<ul><li>返回<span class="spec-call">Subscribe(<var>operation</var>, <var>schema</var>, <var>coercedVariableValues</var>, <var>initialValue</var>)</span>。</li></ul></li></ul><p>GetOperation(document, operationName)：</p><ul><li>如果<var>operationName</var>是<span class="spec-keyword">null</span>：<ul><li>如果<var>document</var>只包含一个操作。<ul><li>返回<var>document</var>中包含的操作。</li></ul></li><li>否则产生一个要求<var>operationName</var>的错误。</li></ul></li><li>否则：<ul><li>使<var>operation</var>为<var>document</var>中名为<var>operationName</var>的操作。</li><li>如果<var>operation</var>未找到，产生一个查询错误。</li><li>返回<var>operation</var>。</li></ul></li></ul><section id="sec-Validating-Requests-" secid="6.1.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Validating-Requests-">6.1.1</a></span>Validating Requests/验证请求</h4><p>如同验证章节中解释的一样，只有通过了所有验证的请求才应该被执行。如果得到了验证错误，它们将被添加到响应中的&ldquo;errors&rdquo;列表中，而这个请求也就不执行直接失败。</p><p>典型的情况下，验证将在请求执行之前的上下文内瞬间完成，但是在一个相同请求之前已经验证过的情况下，GraphQL服务可能直接执行而不验证。GraphQL服务只应该执行那些<em>某个时间点</em>上没有验证错误也没更改过的请求。</p><p>例如：一个请求在开发期已经通过验证，并假设他后面不会改变，或者服务器层验证了一个请求，记住了它的验证结果以避免后续再次验证同样的请求。</p></section><section id="sec-Coercing-Variable-Values-" secid="6.1.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Coercing-Variable-Values-">6.1.2</a></span>Coercing Variable Values/转换变量值</h4><p>如果操作定义了任何变量，然后这些变量的值需要根据变量声明的类型的输入转换规则而转换。如果变量值的输入转换中发生了查询错误，操作会不执行直接失败。</p><p>CoerceVariableValues(schema, operation, variableValues)：</p><ul><li>使<var>coercedValues</var>为一个空的无序Map/映射集。</li><li>使<var>variableDefinitions</var>为<var>operation</var>定义的变量。</li><li>对于<var>variableDefinitions</var>中的每一个<var>variableDefinition</var>：<ul><li>使<var>variableName</var>为<var>variableDefinition</var>的名字。</li><li>使<var>variableType</var>为<var>variableDefinition</var>的期望类型。</li><li>使<var>defaultValue</var>为<var>variableDefinition</var>的默认值。</li><li>使<var>value</var>为<var>variableValues</var>中给名为<var>variableName</var>的变量提供的值。</li><li>如果<var>value</var>并不存在(<var>variableValues</var>中并未提供)：<ul><li>如果<var>defaultValue</var>存在(包括<span class="spec-keyword">null</span>)：<ul><li>给<var>coercedValues</var>添加一个名为<var>variableName</var>值为<var>defaultValue</var>的条目。</li></ul></li><li>或者如果<var>variableType</var>是一个Non&#8208;Nullable/非空类型，抛出一个查询错误。</li><li>否则，继续处理下一个变量定义。</li></ul></li><li>或者, 如果<var>value</var>无法根据<var>variableType</var>的输入转换规则转换，抛出一个查询错误。</li><li>使<var>coercedValue</var>为根据<var>variableType</var>的输入转换规则转换的结果。</li><li>给<var>coercedValues</var>添加一个名为<var>variableName</var>值为<var>coercedValue</var>的条目。</li></ul></li><li>返回<var>coercedValues</var>。</li></ul><div class="spec-note">这个算法和<span class="spec-call">CoerceArgumentValues()</span>的很相似。</div></section></section><section id="sec-Executing-Operations-" secid="6.2"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Executing-Operations-">6.2</a></span>Executing Operations/执行操作</h3><p>如果本规范的&ldquo;Type System&rdquo;/类型系统一章节所描述，类型系统必须提供一个查询的根级对象类型。如果支持更改或者订阅，它也必须提供更改或者订阅对应的根级对象类型。</p><section id="sec-Query-" secid="6.2.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Query-">6.2.1</a></span>Query/查询</h4><p>如果操作是一个查询，那操作的结果就是用查询根级对象类型执行查询的顶层选择集的结果。</p><p>执行一个查询的时候可以提供一个初始值。</p><p>ExecuteQuery(query, schema, variableValues, initialValue)：</p><ul><li>使<var>queryType</var>为<var>schema</var>中的根级查询类型。</li><li>断言：<var>queryType</var>是一个对象类型。</li><li>使<var>selectionSet</var>为<var>query</var>中的顶层选择集。</li><li>使<var>data</var>为<em>正常</em>执行<span class="spec-call">ExecuteSelectionSet(<var>selectionSet</var>, <var>queryType</var>, <var>initialValue</var>, <var>variableValues</var>)</span>的结果(允许并行)。</li><li>使<var>errors</var>为执行选择集期间产生的任何<em>字段错误</em>。</li><li>返回一个包含<var>data</var>和<var>errors</var>的无序映射集。</li></ul></section><section id="sec-Mutation-" secid="6.2.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Mutation-">6.2.2</a></span>Mutation/更改</h4><p>如果操作是一个更改，那操作的结果就是用更改根级对象类型执行更改的顶层选择集的结果。这个选择集应该依次执行。</p><p>更改的顶层字段被期望用于在下层数据系统上执行副作用操作。依次执行这些更改，以保证副作用操作期间没有竞态条件。</p><p>ExecuteMutation(mutation, schema, variableValues, initialValue)：</p><ul><li>使<var>mutationType</var>为<var>schema</var>的根级更改类型。</li><li>断言：<var>mutationType</var>是一个对象类型。</li><li>使<var>selectionSet</var>为<var>mutation</var>中的顶层选择集。</li><li>使<var>data</var>为<em>依次</em>执行<span class="spec-call">ExecuteSelectionSet(<var>selectionSet</var>, <var>mutationType</var>, <var>initialValue</var>, <var>variableValues</var>)</span>的结果</li><li>使<var>errors</var>为执行选择集期间产生的任何<em>字段错误</em>。</li><li>返回一个包含<var>data</var>和<var>errors</var>的无序映射集。</li></ul></section><section id="sec-Subscription-" secid="6.2.3"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Subscription-">6.2.3</a></span>Subscription/订阅</h4><p>如果操作是一个订阅，那结果是一个事件流，称作&ldquo;Response Stream&rdquo;响应流，事件流中的每一个事件即是针对下层&ldquo;Source Stream&rdquo;源流上的新事件执行操作的结果。</p><p>执行订阅会在服务端创建一个永久的函数，用于将下层源流映射成返回的响应流。</p><p>Subscribe(subscription, schema, variableValues, initialValue)：</p><ul><li>使<var>sourceStream</var>为<span class="spec-call">CreateSourceEventStream(<var>subscription</var>, <var>schema</var>, <var>variableValues</var>, <var>initialValue</var>)</span>执行的结果。</li><li>使<var>responseStream</var>为<span class="spec-call">MapSourceToResponseEvent(<var>sourceStream</var>, <var>subscription</var>, <var>schema</var>, <var>variableValues</var>)</span>执行的结果。</li><li>返回<var>responseStream</var>。</li></ul><div class="spec-note">在大型订阅系统中，<span class="spec-call">Subscribe()</span>和<span class="spec-call">ExecuteSubscriptionEvent()</span>算法可能运行在分离的服务器上，以保持可预测的规模属性。可在下文章节中看到关于支持大规模订阅的内容。</div><p>考虑一个聊天应用案例。客户端发送一个如下请求来订阅投递到聊天室的新消息：</p><pre><code>subscription NewMessages {
  newMessage(roomId: 123) {
    sender
    text
  }
}
</code></pre><p>当客户端订阅后，任何时候有ID为&ldquo;123&rdquo;的新消息投递到聊天室后，对于&ldquo;sender&rdquo;和&ldquo;text&rdquo;的选择将会被执行然后发布到客户端。例如：</p><pre><code>{
  <span class="hljs-attr">"data"</span>: {
    <span class="hljs-attr">"newMessage"</span>: {
      <span class="hljs-attr">"sender"</span>: <span class="hljs-string">"Hagrid"</span>,
      <span class="hljs-attr">"text"</span>: <span class="hljs-string">"You're a wizard!"</span>
    }
  }
}
</code></pre><p>&rdquo;新消息投递到聊天室&rdquo;可以使用了&ldquo;Pub&#8208;Sub&rdquo;发布订阅系统，其中聊天室ID是&ldquo;topic&rdquo;，并且每一个&ldquo;publish&rdquo;都包含了&ldquo;sender&rdquo;发送者和&ldquo;text&rdquo;文本。</p><p><strong>Event Streams</strong></p><p>事件流表示一序列可观测的离散事件。例如，一个&ldquo;Pub&#8208;Sub&rdquo;系统当&ldquo;subscribing to a topic&rdquo;订阅了一个话题可能产生一个事件流，每一次&ldquo;publish&rdquo;发布到话题都会在事件流上产生一个事件。事件流可能产生一序列无尽的事件，也可能在任何时候终止。响应中的事件流可能因为发生错误而终止，也可能仅仅因为没有后续事件发生。观察者可以在任何时候取消订阅而停止观察事件流，这之后就不会从事件流中收到后续事件了。</p><p><strong>Supporting Subscriptions at Scale/支持大规模订阅</strong></p><p>支持订阅对GraphQL服务器而言是一个显著的变化。查询和更改操作是无状态的，可以通过克隆GraphQL服务器实例而扩展规模。订阅却相反，它是有状态的，要求在这个订阅的生命周期内维持文档、变量和其他上下文。</p><p>考虑下你服务中某个机器宕机状态丢失的时候，你的系统的行为。使用分离的专用服务器来处理订阅状态和客户端连接将能提升系统的持久性和可用性。</p><section id="sec-Source-Stream-" secid="6.2.3.1"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Source-Stream-">6.2.3.1</a></span>Source Stream/源流</h5><p>源流表示会触发GraphQL对应事件执行的一序列事件。就像字段值的解析一样，创建源流的逻辑也是应用特定的。</p><p>CreateSourceEventStream(subscription, schema, variableValues, initialValue)：</p><ul><li>使<var>subscriptionType</var>为<var>schema</var>的根级订阅类型。</li><li>断言：<var>subscriptionType</var>是一个对象类型。</li><li>使<var>selectionSet</var>。</li><li>使<var>rootField</var>为<var>selectionSet</var>中的第一个顶层字段。</li><li>使<var>argumentValues</var>为<span class="spec-call">CoerceArgumentValues(<var>subscriptionType</var>, <var>rootField</var>, <var>variableValues</var>)</span>的结果。</li><li>使<var>fieldStream</var>为运行<span class="spec-call">ResolveFieldEventStream(<var>subscriptionType</var>, <var>initialValue</var>, <var>rootField</var>, <var>argumentValues</var>)</span>的结果。</li><li>返回<var>fieldStream</var>。</li></ul><p>ResolveFieldEventStream(subscriptionType, rootValue, fieldName, argumentValues)：</p><ul><li>使<var>resolver</var>为<var>subscriptionType</var>提供的内部函数，用于解析名为<var>fieldName</var>的订阅字段的事件流。</li><li>返回使用<var>rootValue</var>和<var>argumentValues</var>调用<var>resolver</var>的结果。</li></ul><div class="spec-note">这个<span class="spec-call">ResolveFieldEventStream()</span>算法有意与<span class="spec-call">ResolveFieldValue()</span>相似，以保证给任何操作类型定义解析函数时的一致性。</div></section><section id="sec-Response-Stream-" secid="6.2.3.2"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Response-Stream-">6.2.3.2</a></span>Response Stream/响应流</h5><p>下层源流中的每一个事件都会触发订阅使用这个事件作为根值执行选择集。</p><p>MapSourceToResponseEvent(sourceStream, subscription, schema, variableValues)：</p><ul><li>返回产生如下事件的事件流<var>responseStream</var>：</li><li>对于<var>sourceStream</var>上的每一个<var>event</var>：<ul><li>使<var>response</var>为运行<span class="spec-call">ExecuteSubscriptionEvent(<var>subscription</var>, <var>schema</var>, <var>variableValues</var>, <var>event</var>)</span>的结果。</li><li>产生包含<var>response</var>的事件。</li></ul></li><li>当<var>responseStream</var>完成的时候：终止这个事件流。</li></ul><p>ExecuteSubscriptionEvent(subscription, schema, variableValues, initialValue)：</p><ul><li>使<var>subscriptionType</var>为为<var>schema</var>的根级订阅类型。</li><li>断言：<var>subscriptionType</var>是一个对象类型。</li><li>使<var>selectionSet</var>为<var>subscription</var>中的顶层选择集。</li><li>使<var>data</var>为<em>正常</em>执行的结果<span class="spec-call">ExecuteSelectionSet(<var>selectionSet</var>, <var>subscriptionType</var>, <var>initialValue</var>, <var>variableValues</var>)</span>（允许并行）。</li><li>使<var>errors</var>为执行选择集期间产生的任何<em>字段错误</em>。</li><li>返回一个包含<var>data</var>和<var>errors</var>的无序映射集。</li></ul><div class="spec-note">这个<span class="spec-call">ExecuteSubscriptionEvent()</span>算法有意与<span class="spec-call">ExecuteQuery()</span>相似，因为这便是每个事件结果如何产生的。</div></section><section id="sec-Unsubscribe-" secid="6.2.3.3"><h5><span class="spec-secid" title="link to this section"><a href="#sec-Unsubscribe-">6.2.3.3</a></span>Unsubscribe/退订</h5><p>当客户端不再想要收到订阅的载荷时可以通过退订来取消响应流。这可能也同时取消掉了源流。这个是一个清理被这个订阅占用的其他资源的好机会。</p><p>Unsubscribe(responseStream)</p><ul><li>取消<var>responseStream</var></li></ul></section></section></section><section id="sec-Executing-Selection-Sets-" secid="6.3"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Executing-Selection-Sets-">6.3</a></span>Executing Selection Sets/执行选择集</h3><p>要执行选择集，对象值必须得到，对象类型必须已知，同样还需要知道其需要依次执行还是并列执行。</p><p>首先，选择集被转换成分组的字段集合，然后分组字段集合内的每一个字段都会在响应映射集中产生一个条目。</p><p>ExecuteSelectionSet(selectionSet, objectType, objectValue, variableValues)：</p><ul><li>使<var>groupedFieldSet</var>为<span class="spec-call">CollectFields(<var>objectType</var>, <var>selectionSet</var>, <var>variableValues</var>)</span>的结果。</li><li>初始化<var>resultMap</var>进一个空有序映射集。</li><li>对于作为<var>responseKey</var>和<var>fields</var>的每一个<var>groupedFieldSet</var>：<ul><li>使<var>fieldName</var>为<var>fields</var>中第一个条目的名字。 Note: 值并不会因引入别名而受影响。</li><li>使<var>fieldType</var>为<var>objectType</var>的<var>fieldName</var>定义的的返回类型。</li><li>如果<var>fieldType</var>是<span class="spec-keyword">null</span>：<ul><li>继续下一轮<var>groupedFieldSet</var>的迭代。</li></ul></li><li>使<var>responseValue</var>为<span class="spec-call">ExecuteField(<var>objectType</var>, <var>objectValue</var>, <var>fields</var>, <var>fieldType</var>, <var>variableValues</var>)</span>。</li><li>将<var>responseValue</var>设为<var>responseKey</var>中<var>resultMap</var>的值。</li></ul></li><li>返回<var>resultMap</var>。</li></ul><div class="spec-note"><var>resultMap</var>依照出现在query中的顺序排序。这在下列字段集合一节中有更详细的介绍。</div><section id="sec-Normal-and-Serial-Execution-" secid="6.3.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Normal-and-Serial-Execution-">6.3.1</a></span>Normal and Serial Execution/正常序列执行</h4><p>正常情况下，不论分组字段集合中的条目顺序为何，执行器都能执行（通常是并行执行）。因为除了顶层更改必然有副作用且具有幂等性，字段解析的执行顺序必然不会影响其结果，因此服务器能够以他认为优化的方式自由地执行字段条目。</p><p>例如，有下正常执行的分组字段：</p><pre><code>{
  birthday {
    month
  }
  address {
    street
  }
}
</code></pre><p>一个有效的GraphQL执行器可以以任何他选择的顺序来解析这四个字段（然而，<code>birthday</code>必然在<code>month</code>之前，同理<code>address</code>在<code>street</code>之前）。</p><p>当执行更改时，最顶层的选择集会依序执行。</p><p>当依序执行一个分组字段集的时候，执行器必须以每个条目出现在分组字段集中的顺序来决定在结果映射集对应的条目，使得分组映射集中每一个条目完成之后才继续下一个条目。</p><p>例如，有以依序执行的选择集：</p><pre><code>{
  changeBirthday(birthday: $newBirthday) {
    month
  }
  changeAddress(address: $newAddress) {
    street
  }
}
</code></pre><p>执行器必须依序执行：</p><ul><li>执行<code>changeBirthday</code>的<span class="spec-call">ExecuteField()</span>，其中<span class="spec-call">CompleteValue()</span>期间，会正常执行<code>{ month }</code>次级选择集。</li><li>执行<code>changeAddress</code>的<span class="spec-call">ExecuteField()</span>，其中<span class="spec-call">CompleteValue()</span>期间，会正常执行<code>{ street }</code>次级选择集。</li></ul><p>举一个说明性的例子，假设我们有一个mutation字段<code>changeTheNumber</code>，其返回包含一个<code>theNumber</code>字段的对象。如果我们依序执行下列选择集：</p><pre><code>{
  first: changeTheNumber(newNumber: 1) {
    theNumber
  }
  second: changeTheNumber(newNumber: 3) {
    theNumber
  }
  third: changeTheNumber(newNumber: 2) {
    theNumber
  }
}
</code></pre><p>执行器会如下依序执行：</p><ul><li>解析<code>changeTheNumber(newNumber: 1)</code>字段</li><li>正常执行<code>first</code>次级选择集<code>{ theNumber }</code></li><li>解析<code>changeTheNumber(newNumber: 3)</code>字段</li><li>正常执行<code>second</code>次级选择集<code>{ theNumber }</code></li><li>解析<code>changeTheNumber(newNumber: 2)</code>字段</li><li>正常执行<code>third</code>次级选择集<code>{ theNumber }</code></li></ul><p>正确的执行器，对于上述选择集必然会生成如下结果：</p><pre><code>{
  <span class="hljs-attr">"first"</span>: {
    <span class="hljs-attr">"theNumber"</span>: <span class="hljs-number">1</span>
  },
  <span class="hljs-attr">"second"</span>: {
    <span class="hljs-attr">"theNumber"</span>: <span class="hljs-number">3</span>
  },
  <span class="hljs-attr">"third"</span>: {
    <span class="hljs-attr">"theNumber"</span>: <span class="hljs-number">2</span>
  }
}
</code></pre></section><section id="sec-Field-Collection-" secid="6.3.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Field-Collection-">6.3.2</a></span>Field Collection/字段集合</h4><p>执行之前，通过调用<span class="spec-call">CollectFields()</span>，选择集会被转换成分组字段集。分组字段集中的每一个条目都是共享同一个响应键的列表。这保证了同一个响应键（别名或者字段名）内所有的字段，包含通过片段引入的，都能同时执行。</p><p>如果，手机如下选择集的字段会收集到两个<code>a</code>字段的实体和一个<code>b</code>字段的实体：</p><pre><code>{
  a {
    subfield1
  }
  ...ExampleFragment
}

fragment ExampleFragment on Query {
  a {
    subfield2
  }
  b
}
</code></pre><p><span class="spec-call">CollectFields()</span>生成的字段分组的深度优先搜索通过执行来保持，保证字段在执行后响应中以稳定可预测的顺序出现。</p><p>CollectFields(objectType, selectionSet, variableValues, visitedFragments)：</p><ul><li>如果未提供<var>visitedFragments</var>，将其初始化为空集。</li><li>初始化<var>groupedFields</var>为列表的空的有序集。</li><li>对于<var>selectionSet</var>中的每一个<var>selection</var>：<ul><li>如果<var>selection</var>提供了<code>@skip</code>指令，使<var>skipDirective</var>为此指令。<ul><li>如果<var>skipDirective</var>的<var>if</var>参数是<span class="spec-keyword">true</span>或者是<var>variableValues</var>中的一个为<span class="spec-keyword">true</span>的变量，则继续<var>selectionSet</var>中的下一个<var>selection</var>。</li></ul></li><li>如果<var>selection</var>提供了<code>@include</code>指令，使<var>includeDirective</var>为此指令。<ul><li>如果<var>includeDirective</var>参数不是<span class="spec-keyword">true</span>或者不是<var>variableValues</var>中的一个为<span class="spec-keyword">true</span>的变量，则继续<var>selectionSet</var>中的下一个<var>selection</var>。</li></ul></li><li>如果<var>selection</var>是一个<span class="spec-nt"><a href="#Field">Field</a></span>：<ul><li>使<var>responseKey</var>为<var>selection</var>中的响应键。</li><li>使<var>groupForResponseKey</var>为<var>groupedFields</var>中的一个<var>responseKey</var>列表；如果不存在这么一个列表，则创建一个空列表。</li><li>附加<var>selection</var>到<var>groupForResponseKey</var>上。</li></ul></li><li>如果<var>selection</var>是一个<span class="spec-nt"><a href="#FragmentSpread">FragmentSpread</a></span>：<ul><li>使<var>fragmentSpreadName</var>为<var>selection</var>的名字。</li><li>如果<var>fragmentSpreadName</var>在<var>visitedFragments</var>中，则继续<var>selectionSet</var>中的下一个<var>selection</var>。</li><li>添加<var>fragmentSpreadName</var>到<var>visitedFragments</var>上。</li><li>使<var>fragment</var>为当前文档中名为<var>fragmentSpreadName</var>的片段。</li><li>如果不存在那样的<var>fragment</var>，则继续<var>selectionSet</var>中的下一个<var>selection</var>。</li><li>使<var>fragmentType</var>为<var>fragment</var>上的类型条件。</li><li>如果<span class="spec-call">DoesFragmentTypeApply(<var>objectType</var>, <var>fragmentType</var>)</span>为false，则继续<var>selectionSet</var>中的下一个<var>selection</var>。</li><li>使<var>fragmentSelectionSet</var>为<var>fragment</var>的顶层选择集。</li><li>使<var>fragmentGroupedFieldSet</var>为调用<span class="spec-call">CollectFields(<var>objectType</var>, <var>fragmentSelectionSet</var>, <var>visitedFragments</var>)</span>的结果。</li><li>对于<var>fragmentGroupedFieldSet</var>中的每一个<var>fragmentGroup</var>：<ul><li>使<var>responseKey</var>为<var>fragmentGroup</var>中所有字段共享的响应键。</li><li>使<var>groupForResponseKey</var>为<var>groupedFields</var>中的<var>responseKey</var>列表；如果不存在这么一个列表，则创建一个空列表。</li><li>附加<var>fragmentGroup</var>中所有的元素到<var>groupForResponseKey</var>上。</li></ul></li></ul></li><li>如果<var>selection</var>是一个<span class="spec-nt"><a href="#InlineFragment">InlineFragment</a></span>：<ul><li>使<var>fragmentType</var>为<var>selection</var>上的类型条件。</li><li>如果<var>fragmentType</var>不为<span class="spec-keyword">null</span>且<span class="spec-call">DoesFragmentTypeApply(<var>objectType</var>, <var>fragmentType</var>)</span>是false，则继续<var>selectionSet</var>中的下一个<var>selection</var>。</li><li>使<var>fragmentSelectionSet</var>为<var>selection</var>的顶层选择集。</li><li>使<var>fragmentGroupedFieldSet</var>为调用<span class="spec-call">CollectFields(<var>objectType</var>, <var>fragmentSelectionSet</var>, <var>variableValues</var>, <var>visitedFragments</var>)</span>的结果。</li><li>对于<var>fragmentGroupedFieldSet</var>中的每一个<var>fragmentGroup</var>：<ul><li>使<var>responseKey</var>为为<var>fragmentGroup</var>中所有字段共享的响应键</li><li>使<var>groupForResponseKey</var>为<var>groupedFields</var>中的<var>responseKey</var>列表；如果不存在这么一个列表，则创建一个空列表。<ul><li>附加<var>fragmentGroup</var>中所有的元素到<var>groupForResponseKey</var>上。</li></ul></li></ul></li></ul></li></ul></li><li>返回<var>groupedFields</var>。</li></ul><p>DoesFragmentTypeApply(objectType, fragmentType)：</p><ul><li>如果<var>fragmentType</var>是一个对象类型：<ul><li>如果<var>objectType</var>和<var>fragmentType</var>是同类型，返回<span class="spec-keyword">true</span>，否则返回<span class="spec-keyword">false</span>。</li></ul></li><li>如果<var>fragmentType</var>是一个接口类型：<ul><li>如果<var>objectType</var>是<var>fragmentType</var>的一个实现，返回<span class="spec-keyword">true</span>，否则返回<span class="spec-keyword">false</span>。</li></ul></li><li>如果<var>fragmentType</var>是一个联合：<ul><li>如果<var>objectType</var>是<var>fragmentType</var>的一个可能类型，返回<span class="spec-keyword">true</span>，否则返回<span class="spec-keyword">false</span>。</li></ul></li></ul></section></section><section id="sec-Executing-Fields-" secid="6.4"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Executing-Fields-">6.4</a></span>Executing Fields/执行字段</h3><p>分组字段集上的每一个请求字段（定义在被选择的对象类型上）都会得到一个响应映射集中的一个条目。字段执行首先会转换任何提供的技术值，然后解析这个字段的值，最后通过递归执行另一个选择集或者转换一个标量来完成这个字段的值。</p><p>ExecuteField(objectType, objectValue, fieldType, fields, variableValues)：</p><ul><li>使<var>field</var>为<var>fields</var>中的第一个条目。</li><li>使<var>argumentValues</var>为<span class="spec-call">CoerceArgumentValues(<var>objectType</var>, <var>field</var>, <var>variableValues</var>)</span>的结果</li><li>使<var>resolvedValue</var>为<span class="spec-call">ResolveFieldValue(<var>objectType</var>, <var>objectValue</var>, <var>fieldName</var>, <var>argumentValues</var>)</span>。</li><li>返回<span class="spec-call">CompleteValue(<var>fieldType</var>, <var>fields</var>, <var>resolvedValue</var>, <var>variableValues</var>)</span>的结果。</li></ul><section id="sec-Coercing-Field-Arguments-" secid="6.4.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Coercing-Field-Arguments-">6.4.1</a></span>Coercing Field Arguments/转换字段参数</h4><p>字段可能包含下层运行时产生正确结果的参数，这些参数定义在类型系统中的字段上，都有一个特定的输入类型：Scalars标量、Enum庙举行、Input Object输入对象，或者这三个的List列表和Non&#8208;Null非空封装。</p><p>对于查询中每个参数的位置，可能是一个字面量值，也可能是运行时提供的变量。</p><p>CoerceArgumentValues(objectType, field, variableValues)：</p><ul><li>使<var>coercedValues</var>为空的无序映射集。</li><li>使<var>argumentValues</var>为<var>field</var>提供的参数值。</li><li>使<var>fieldName</var>为<var>field</var>的名字。</li><li>使<var>argumentDefinitions</var>为<var>objectType</var>上字段名<var>fieldName</var>定义的参数。</li><li>对于<var>argumentDefinitions</var>中的每一个<var>argumentDefinition</var>：<ul><li>使<var>argumentName</var>为<var>argumentDefinition</var>的名字。</li><li>使<var>argumentType</var>为<var>argumentDefinition</var>的期待类型。</li><li>使<var>defaultValue</var>为<var>argumentDefinition</var>的默认值。</li><li>使<var>value</var>为<var>argumentValues</var>中针对<var>argumentName</var>提供的值。</li><li>如果<var>value</var>是一个变量：<ul><li>使<var>variableName</var>为<var>value</var>变量的名字。</li><li>使<var>variableValue</var>为<var>variableValues</var>中针对<var>variableName</var>提供的值。</li><li>如果<var>variableValue</var>存在(包含<span class="spec-keyword">null</span>)：<ul><li>添加名为<var>argName</var>值为<var>variableValue</var>的条目到<var>coercedValues</var>。</li></ul></li><li>否则，如果<var>defaultValue</var>存在(包含<span class="spec-keyword">null</span>)：<ul><li>添加名为<var>argName</var>值为<var>defaultValue</var>的条目到<var>coercedValues</var>。</li></ul></li><li>否则，如果<var>argumentType</var>是一个Non&#8208;Nullable非空类型，抛出字段错误。</li><li>否则，继续下一个参数定义。</li></ul></li><li>否则，如果<var>value</var>不存在(<var>argumentValues</var>中未提供)：<ul><li>如果<var>defaultValue</var>存在(包含<span class="spec-keyword">null</span>)：<ul><li>添加名为<var>argName</var>值为<var>defaultValue</var>的条目到<var>coercedValues</var>。</li></ul></li><li>否则，如果<var>argumentType</var>是一个Non&#8208;Nullable非空类型，抛出字段错误。</li><li>否则，继续下一个参数定义。</li></ul></li><li>否则, 如果<var>value</var>不能根据<var>argType</var>的输入转换规则转换，抛出字段错误。</li><li>使<var>coercedValue</var>为根据<var>argType</var>的输入转换规则转换<var>value</var>的结果。</li><li>添加名为<var>argName</var>值为<var>variableValue</var>的条目到<var>coercedValues</var>。</li></ul></li><li>返回<var>coercedValues</var>。</li></ul><div class="spec-note">变量的值并没有被转换，因为它们应该在执行<span class="spec-call">CoerceVariableValues()</span>中的操作前前就被转换，一个有效的查询必须仅允许合适类型的变量。</div></section><section id="sec-Value-Resolution-" secid="6.4.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Value-Resolution-">6.4.2</a></span>Value Resolution/值解析</h4><p>虽然几乎所有的GraphQL执行都能通用化描述，但最终内部系统暴露给GraphQL接口的时候必须提供值。这通过<span class="spec-nt">ResolveFieldValue</span>暴露，其生成真实值的类型上给定字段的值，</p><p>在案例中，这个可能接收<var>objectType</var>/对象类型<code>Person</code>，其<var>field</var>/字段为<span class="spec-string">"soulMate"</span>，这个<var>objectValue</var>/类型值表示John Lennon。它可能被期待得到值表示Yoko Ono。</p><p>ResolveFieldValue(objectType, objectValue, fieldName, argumentValues)：</p><ul><li>使<var>resolver</var>为<var>objectType</var>提供的内部函数，用以决定名为<var>fieldName</var>的字段的解析值。</li><li>返回使用<var>objectValue</var>和<var>argumentValues</var>调用<var>resolver</var>的结果。</li></ul><div class="spec-note"><var>resolver</var>通常可能是异步的，因为其依靠读取下层数据库或者网络服务来产生值。这要求其他的GraphQL执行器能够处理异步执行流。</div></section><section id="sec-Value-Completion-" secid="6.4.3"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Value-Completion-">6.4.3</a></span>Value Completion/值完成</h4><p>在解析一个字段的值后，再确认其符合期望返回类型即完成。如果返回值是另一个对象类型，然后字段执行将继续递归。</p><p>CompleteValue(fieldType, fields, result, variableValues)：</p><ul><li>如果<var>fieldType</var>是一个Non&#8208;Null非空类型：<ul><li>使<var>innerType</var>为<var>fieldType</var>的内部类型。</li><li>使<var>completedResult</var>为调用<span class="spec-call">CompleteValue(<var>innerType</var>, <var>fields</var>, <var>result</var>, <var>variableValues</var>)</span>的结果。</li><li>如果<var>completedResult</var>是<span class="spec-keyword">null</span>，抛出一个字段错误。</li><li>返回<var>completedResult</var>。</li></ul></li><li>如果<var>result</var>是<span class="spec-keyword">null</span> (或者另一种类似于的<span class="spec-keyword">null</span>内部值，譬如<span class="spec-keyword">undefined</span>或<span class="spec-nt">NaN</span>), 返回<span class="spec-keyword">null</span>。</li><li>如果<var>fieldType</var>是一个List列表类型：<ul><li>如果<var>result</var>并不是一个值的集合，抛出一个字段错误。</li><li>使<var>innerType</var>为<var>fieldType</var>的内部类型。</li><li>返回一个列表，其中每个列表元素都是调用<span class="spec-call">CompleteValue(<var>innerType</var>, <var>fields</var>, <var>resultItem</var>, <var>variableValues</var>)</span>的结果，其中<var>resultItem</var>为<var>result</var>中的每个元素。。</li></ul></li><li>如果<var>fieldType</var>是Scalar标量或者Enum枚举类型：<ul><li>返回&ldquo;转换&rdquo;<var>result</var>的结果，保证其为<var>fieldType</var>的合法值，否则为<span class="spec-keyword">null</span>。</li></ul></li><li>如果<var>fieldType</var>是Object对象，Interface接口，或者Union类型：<ul><li>如果<var>fieldType</var>是一个Object对象类型。<ul><li>使<var>objectType</var>为<var>fieldType</var>。</li></ul></li><li>Otherwise 如果<var>fieldType</var>是一个Interface接口，或者Union类型。<ul><li>使<var>objectType</var>为ResolveAbstractType(<var>fieldType</var>, <var>result</var>)。</li></ul></li><li>使<var>subSelectionSet</var>为调用<span class="spec-call">MergeSelectionSets(<var>fields</var>)</span>的结果。</li><li>返回ExecuteSelectionSet(subSelectionSet, objectType, result, variableValues)<em>正常</em>求值的结果(允许并行)。</li></ul></li></ul><p><strong>Resolving Abstract Types/解析抽象类型</strong></p><p>当完成一个具有抽象返回类型的字段时，譬如Interface接口或者Union联合返回类型，首先，抽象类型必须接地到一个相关的对象类型上去，这个由内部系统决定哪一个是合适的。</p><div class="spec-note">在面向对象的环境中，譬如Java或者C#，用以决定一个<var>objectValue</var>的对象类型的通用方法是使用这个<var>objectValue</var>的类名。</div><p>ResolveAbstractType(abstractType, objectValue)：</p><ul><li>返回调用系统提供的内部方法的结果，此方法用于决定给定值<var>objectValue</var>的<var>abstractType</var>的对象类型。</li></ul><p><strong>Merging Selection Sets/合并选择集</strong></p><p>当多余一个同名字段并行执行后，他们的选择集在完成这个值的时候被合并，以继续次级选择集的执行。</p><p>案例查询中，描述了带次级选择集的同名的并行字段。</p><pre><code>{
  me {
    firstName
  }
  me {
    lastName
  }
}
</code></pre><p>当解析了 <code>me</code>的值后，选择集将合并，所以<code>firstName</code>和<code>lastName</code>可以被解析到一个值上。</p><p>MergeSelectionSets(fields)：</p><ul><li>使<var>selectionSet</var>为一个空列表。</li><li>对于 <var>fields</var>中的每一个<var>field</var>：<ul><li>使<var>fieldSelectionSet</var>为<var>field</var>的选择集。</li><li>如果<var>fieldSelectionSet</var>是null或者empty，继续下一个字段。</li><li>将<var>fieldSelectionSet</var>中所有的选择集添加到<var>selectionSet</var>。</li></ul></li><li>返回<var>selectionSet</var>。</li></ul></section><section id="sec-Errors-and-Non-Nullability-" secid="6.4.4"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Errors-and-Non-Nullability-">6.4.4</a></span>Errors and Non-Nullability/错误与非空</h4><p>当解析一个字段时抛出了错误，它应该被当作这个字段返回了<span class="spec-keyword">null</span>，且错误必须添加到响应的<span class="spec-string">"errors"</span>列表中。</p><p>如果一个字段解析的结果就是<span class="spec-keyword">null</span>（不论是字段的解析函数返回了<span class="spec-keyword">null</span>还是发生了错误），且那个字段是<code>Non-Null</code>，那么抛出一个字段错误。这个错误必须添加到响应的<span class="spec-string">"errors"</span>列表中。</p><p>如果字段因为错误而返回了<span class="spec-keyword">null</span>，这个错误也被添加到了响应的<span class="spec-string">"errors"</span>列表中，这个<span class="spec-string">"errors"</span>列表后续就不应被影响，即是，错误列表中一个字段上只允许添加一个错误。</p><p>因为<code>Non-Null</code>类型不能为<span class="spec-keyword">null</span>，字段错误将会冒泡到父级字段并被父级字段处理。如果父级字段可能为<span class="spec-keyword">null</span>，那么它就解析为<span class="spec-keyword">null</span>，否则如果父级字段也是<code>Non-Null</code>类型，那么这个字段错误将会继续冒泡到上一级父级字段。</p><p>如果从请求的根到错误的源的所有字段都返回<code>Non-Null</code>条目，那么响应中的<span class="spec-string">"data"</span>条目应该为<span class="spec-keyword">null</span>。 </p></section></section></section><section id="sec-Response-" secid="7"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Response-">7</a></span>Response/响应</h2><p>如果一个GraphQL服务器收到一个请求，它必须返回一个良好格式化的响应。如果请求操作执行成功，服务器的响应则描述其执行结果，否则描述执行期间遇到的错误。</p><p>一个响应可能会包含部分是响应，部分是另一个字段上发生错误的时候，响应中这个字段的值被替换成了null。</p><section id="sec-Serialization-Format-" secid="7.1"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Serialization-Format-">7.1</a></span>Serialization Format/序列化格式</h3><p>GraphQL并不要求特定的序列化格式，然而客户端应该使用一种支持GraphQL响应中的主要原始类型的序列化格式。特别需要支持一下原始类型：</p><ul><li>Map</li><li>List</li><li>String</li><li>Null</li></ul><p>在执行一节中的<span class="spec-call">CollectFields()</span>的定义中，序列化格式如果支持有序映射集，那么它应该保持请求字段的顺序。只支持无序映射集的序列化格式（譬如JSON）应该保持其语法上的顺序。</p><p>产生跟请求一致的字段顺序响应有助于提过调试过程中面向人类的可读性和属性相关的响应解析效率。</p><p>系列化格式应支持下列原始类型，然而String可能用于替换下列原始类型。</p><ul><li>Boolean</li><li>Int</li><li>Float</li><li>Enum Value</li></ul><section id="sec-JSON-Serialization-JSON-" secid="7.1.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-JSON-Serialization-JSON-">7.1.1</a></span>JSON Serialization/JSON序列化</h4><p>虽然如上所述，GraphQL并不要求一种特定的序列化格式，但是还是比较偏好于JSON。为了风格统一和易于标注，本规范中响应的案例都以JSOn的格式表示，特别需要注意的是，我们的JSON案例中，原始类型都以一下JSON概念来表示：</p><table><thead><tr><th>GraphQL值 </th><th>JSON值 </th></tr></thead><tbody><tr><td>Map </td><td>Object </td></tr><tr><td>List </td><td>Array </td></tr><tr><td>Null </td><td><span class="spec-keyword">null</span> </td></tr><tr><td>String </td><td>String </td></tr><tr><td>Boolean </td><td><span class="spec-keyword">true</span> or <span class="spec-keyword">false</span> </td></tr><tr><td>Int </td><td>Number </td></tr><tr><td>Float </td><td>Number </td></tr><tr><td>Enum Value </td><td>String </td></tr></tbody></table><p><strong>Object Property Ordering/对象属性排序</strong></p><p>JSON被描述为<a href="https://tools.ietf.org/html/rfc7159#section-4">无序键值对集合</a>，而键值对在表示上确实有序的方式。换言之，即便JSON字符串<code>{ &quot;name&quot;: &quot;Mark&quot;, &quot;age&quot;: 30 }</code>和<code>{ &quot;age&quot;: 30, &quot;name&quot;: &quot;Mark&quot; }</code>编码了相同的值，但是他们却有不同的属性表示顺序。</p><p>选择集的求值结果是有序的，这个顺序来源于请求，并由查询执行器定义，因此JSON序列化可以保持这个顺序，并以这个顺序写入到对象属性中。</p><p>譬如，如果查询是<code>{ name, age }</code>，则GraphQL服务器响应的JSON会是<code>{ &quot;name&quot;: &quot;Mark&quot;, &quot;age&quot;: 30 }</code>而不是<code>{ &quot;age&quot;: 30, &quot;name&quot;: &quot;Mark&quot; }</code>。</p><div class="spec-note">这并没有破坏JSON规范，因为客户端还是会将响应转换成无序映射集的有效值。</div></section></section><section id="sec-Response-Format-" secid="7.2"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Response-Format-">7.2</a></span>Response Format/响应格式</h3><p>GraphQL的响应应该是映射集类型。</p><p>如果操作包含了执行，那其响应映射集的第一个条目的键必须是<code>data</code>，其值将在&ldquo;Data/数据&rdquo;一章节中描述。如果操作在执行之前就失败，譬如语法错误、缺失信息或者验证错误，则此条目不应显示。</p><p>如果操作遇到了错误，则响应映射集的下一个条目的键必须是<code>errors</code>，其值将在&ldquo;Errors/错误&rdquo;一章节中描述。如果操作并没遇到错误，则此条目不应显示。</p><p>响应可以包含键为<code>extensions</code>的条目，此条目必须包含值。此条目是作为协议扩展而为实现者保留的，因此并没有对其内容的附加限制要求。</p><p>为了保证本协议今后的变化不会破坏已有的服务器和客户端，顶层的响应映射集不能包含上述三个之外的条目。</p><section id="sec-Data-" secid="7.2.1"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Data-">7.2.1</a></span>Data/数据</h4><p>响应中的<code>data</code>条目是请求的操作执行的结果。如果操作是query/查询，输出则是schema查询的根级类型对象，如果操作是mutation/更改，输出则是schema更改的根级类型对象。</p><p>如果在执行前遇到错误，结果中将不应有<code>data</code>条目。</p><p>如果在执行中遇到错误，并导致不能返回有效响应，则<code>data</code>条目应该为<code>null</code>。</p></section><section id="sec-Errors-" secid="7.2.2"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Errors-">7.2.2</a></span>Errors/错误</h4><p>响应中的<code>errors</code>是一个非空错误列表，每个错误是一个映射集。</p><p>如果在执行请求的操作中未遇到错误，结果中将不应有<code>errors</code>条目。</p><p>如果响应结果中没有<code>data</code>条目，则响应中的<code>errors</code>条目不可为空，其必须包含至少一条错误，这个错误应指出为什么没有数据返回。</p><p>如果响应中包含<code>data</code>条目（包含值为<span class="spec-keyword">null</span>的情况），那么响应中的<code>errors</code>条目可以包含执行期间的任何错误。如果执行期发生了错误，那这个错误就应该被包含。</p><p><strong>Error result format/错误结果格式</strong></p><p>每个错误都必须包含键为<code>message</code>的条目，其包含了针对开发这错误描述，以便修正错误。</p><p>如果一个错误能和请求的GraphQL文档特定点所匹配，它应该包含键为<code>locations</code>的条目，其内容为一个定位列表，每个定位都是键为<code>line</code>和<code>column</code>的映射集，两者都是从<code>1</code>开始的正数，用以描述相关的语法元素的起始位置。</p><p>如果一个错误能和GraphQL结果中的特定字段关联，它必须包含键为<code>path</code>的条目，其描述了响应中哪一个字段面临了错误。这能让客户端鉴别一个<code>null</code>是正常逻辑还是运行时错误。</p><p>这个字段应该是一个路径段的列表，从响应根级开始直到关联的字段结束。用于表示字段的路径段应该是字符串类型，而表示列表索引的路径段则应该是从0开始的整数。如果错误发生在别名字段，那对应的路径应该使用别名，因为其表示的是响应中的路径而非查询中的。</p><p>例如，如果下列查询中，获取一个朋友的名字失败了：</p><pre><code>{
  hero(episode: $episode) {
    name
    heroFriends: friends {
      id
      name
    }
  }
}
</code></pre><p>响应会像这样：</p><pre><code>{
  <span class="hljs-attr">"errors"</span>: [
    {
      <span class="hljs-attr">"message"</span>: <span class="hljs-string">"Name for character with ID 1002 could not be fetched."</span>,
      <span class="hljs-attr">"locations"</span>: [ { <span class="hljs-attr">"line"</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">"column"</span>: <span class="hljs-number">7</span> } ],
      <span class="hljs-attr">"path"</span>: [ <span class="hljs-string">"hero"</span>, <span class="hljs-string">"heroFriends"</span>, <span class="hljs-number">1</span>, <span class="hljs-string">"name"</span> ]
    }
  ],
  <span class="hljs-attr">"data"</span>: {
    <span class="hljs-attr">"hero"</span>: {
      <span class="hljs-attr">"name"</span>: <span class="hljs-string">"R2-D2"</span>,
      <span class="hljs-attr">"heroFriends"</span>: [
        {
          <span class="hljs-attr">"id"</span>: <span class="hljs-string">"1000"</span>,
          <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Luke Skywalker"</span>
        },
        {
          <span class="hljs-attr">"id"</span>: <span class="hljs-string">"1002"</span>,
          <span class="hljs-attr">"name"</span>: <span class="hljs-literal">null</span>
        },
        {
          <span class="hljs-attr">"id"</span>: <span class="hljs-string">"1003"</span>,
          <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Leia Organa"</span>
        }
      ]
    }
  }
}
</code></pre><p>如果发生错误的字段声明为<code>Non-Null</code>非空，则<code>null</code>错误会冒泡到下一个可空字段，这种情况下，<code>path</code>也应该包含到发生错误的字段的完整路径，即便这个字段未出现在响应中。</p><p>譬如，如果上述的<code>name</code>字段在schema中声明为<code>Non-Null</code>非空，那么查询结果可能不同，但是错误还是一样。</p><pre><code>{
  <span class="hljs-attr">"errors"</span>: [
    {
      <span class="hljs-attr">"message"</span>: <span class="hljs-string">"Name for character with ID 1002 could not be fetched."</span>,
      <span class="hljs-attr">"locations"</span>: [ { <span class="hljs-attr">"line"</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">"column"</span>: <span class="hljs-number">7</span> } ],
      <span class="hljs-attr">"path"</span>: [ <span class="hljs-string">"hero"</span>, <span class="hljs-string">"heroFriends"</span>, <span class="hljs-number">1</span>, <span class="hljs-string">"name"</span> ]
    }
  ],
  <span class="hljs-attr">"data"</span>: {
    <span class="hljs-attr">"hero"</span>: {
      <span class="hljs-attr">"name"</span>: <span class="hljs-string">"R2-D2"</span>,
      <span class="hljs-attr">"heroFriends"</span>: [
        {
          <span class="hljs-attr">"id"</span>: <span class="hljs-string">"1000"</span>,
          <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Luke Skywalker"</span>
        },
        <span class="hljs-literal">null</span>,
        {
          <span class="hljs-attr">"id"</span>: <span class="hljs-string">"1003"</span>,
          <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Leia Organa"</span>
        }
      ]
    }
  }
}
</code></pre><p>GraphQL服务器可以给error提供附加的条目，以用来展示更为用的或者机器可读的错误，当然，今后本规范也可能为error引入附加条目。 </p></section></section></section><section id="sec-Appendix-Notation-Conventions-A-" secid="A"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Appendix-Notation-Conventions-A-">A</a></span>Appendix: Notation Conventions/A.附录：符号约定</h2><p>This specification document contains a number of notation conventions used to describe technical concepts such as language grammar and semantics as well as runtime algorithms.</p><p>This appendix seeks to explain these notations in greater detail to avoid ambiguity.</p><section id="sec-Context-Free-Grammar-" secid="A.1"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Context-Free-Grammar-">A.1</a></span>Context-Free Grammar/无上下文的语法</h3><p>A context&#8208;free grammar consists of a number of productions. Each production has an abstract symbol called a &ldquo;non&#8208;terminal&rdquo; as its left&#8208;hand side, and zero or more possible sequences of non&#8208;terminal symbols and or terminal characters as its right&#8208;hand side.</p><p>Starting from a single goal non&#8208;terminal symbol, a context&#8208;free grammar describes a language: the set of possible sequences of characters that can be described by repeatedly replacing any non&#8208;terminal in the goal sequence with one of the sequences it is defined by, until all non&#8208;terminal symbols have been replaced by terminal characters.</p><p>Terminals are represented in this document in a monospace font in two forms: a specific Unicode character or sequence of Unicode characters (ex. <span class="spec-t">=</span> or <span class="spec-t">terminal</span>), and a pattern of Unicode characters defined by a regular expression (ex <span class="spec-rx">/[0-9]+/</span>).</p><p>Non&#8208;terminal production rules are represented in this document using the following notation for a non&#8208;terminal with a single definition:</p><div class="spec-production" id="NonTerminalWithSingleDefinition"><span class="spec-nt"><a href="#NonTerminalWithSingleDefinition">NonTerminalWithSingleDefinition</a></span><div class="spec-rhs"><span class="spec-nt">NonTerminal</span><span class="spec-t">terminal</span></div></div><p>While using the following notation for a production with a list of definitions:</p><div class="spec-production" id="NonTerminalWithManyDefinitions"><span class="spec-nt"><a href="#NonTerminalWithManyDefinitions">NonTerminalWithManyDefinitions</a></span><div class="spec-rhs"><span class="spec-nt">OtherNonTerminal</span><span class="spec-t">terminal</span></div><div class="spec-rhs"><span class="spec-t">terminal</span></div></div><p>A definition may refer to itself, which describes repetitive sequences, for example:</p><div class="spec-production" id="ListOfLetterA"><span class="spec-nt"><a href="#ListOfLetterA">ListOfLetterA</a></span><div class="spec-rhs"><span class="spec-t">a</span></div><div class="spec-rhs"><span class="spec-nt"><a href="#ListOfLetterA">ListOfLetterA</a></span><span class="spec-t">a</span></div></div></section><section id="sec-Lexical-and-Syntactical-Grammar-" secid="A.2"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Lexical-and-Syntactical-Grammar-">A.2</a></span>Lexical and Syntactical Grammar/词句上的语法</h3><p>The GraphQL language is defined in a syntactic grammar where terminal symbols are tokens. Tokens are defined in a lexical grammar which matches patterns of source characters. The result of parsing a sequence of source Unicode characters produces a GraphQL AST.</p><p>A Lexical grammar production describes non&#8208;terminal &ldquo;tokens&rdquo; by patterns of terminal Unicode characters. No &ldquo;whitespace&rdquo; or other ignored characters may appear between any terminal Unicode characters in the lexical grammar production. A lexical grammar production is distinguished by a two colon <code>::</code> definition.</p><div class="spec-production d2" id="Word"><span class="spec-nt"><a href="#Word">Word</a></span><div class="spec-rhs"><span class="spec-rx">/[A-Za-z]+/</span></div></div><p>A Syntactical grammar production describes non&#8208;terminal &ldquo;rules&rdquo; by patterns of terminal Tokens. Whitespace and other ignored characters may appear before or after any terminal Token. A syntactical grammar production is distinguished by a one colon <code>:</code> definition.</p><div class="spec-production" id="Sentence"><span class="spec-nt"><a href="#Sentence">Sentence</a></span><div class="spec-rhs"><span class="spec-nt">Noun</span><span class="spec-nt">Verb</span></div></div></section><section id="sec-Grammar-Notation-" secid="A.3"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Grammar-Notation-">A.3</a></span>Grammar Notation/语法符号</h3><p>This specification uses some additional notation to describe common patterns, such as optional or repeated patterns, or parameterized alterations of the definition of a non&#8208;terminal. This section explains these short&#8208;hand notations and their expanded definitions in the context&#8208;free grammar.</p><p><strong>Constraints</strong></p><p>A grammar production may specify that certain expansions are not permitted by using the phrase &ldquo;but not&rdquo; and then indicating the expansions to be excluded.</p><p>For example, the production:</p><div class="spec-production" id="SafeName"><span class="spec-nt"><a href="#SafeName">SafeName</a></span><div class="spec-rhs"><span class="spec-constrained"><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-butnot"><span class="spec-nt">SevenCarlinWords</span></span></span></div></div><p>means that the nonterminal <span class="spec-nt"><a href="#SafeName">SafeName</a></span> may be replaced by any sequence of characters that could replace <span class="spec-nt"><a href="#Name">Name</a></span> provided that the same sequence of characters could not replace <span class="spec-nt">SevenCarlinWords</span>.</p><p>A grammar may also list a number of restrictions after &ldquo;but not&rdquo; separated by &ldquo;or&rdquo;.</p><p>For example:</p><div class="spec-production" id="NonBooleanName"><span class="spec-nt"><a href="#NonBooleanName">NonBooleanName</a></span><div class="spec-rhs"><span class="spec-constrained"><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-butnot"><span class="spec-t">true</span><span class="spec-t">false</span></span></span></div></div><p><strong>Optionality and Lists</strong></p><p>A subscript suffix &ldquo;<span class="spec-nt optional">Symbol<span class="spec-mods"><span class="spec-mod optional">opt</span></span></span>&rdquo; is shorthand for two possible sequences, one including that symbol and one excluding it.</p><p>As an example:</p><div class="spec-production" id="Sentence"><span class="spec-nt"><a href="#Sentence">Sentence</a></span><div class="spec-rhs"><span class="spec-nt">Noun</span><span class="spec-nt">Verb</span><span class="spec-nt optional">Adverb<span class="spec-mods"><span class="spec-mod optional">opt</span></span></span></div></div><p>is shorthand for</p><div class="spec-production" id="Sentence"><span class="spec-nt"><a href="#Sentence">Sentence</a></span><div class="spec-rhs"><span class="spec-nt">Noun</span><span class="spec-nt">Verb</span></div><div class="spec-rhs"><span class="spec-nt">Noun</span><span class="spec-nt">Verb</span><span class="spec-nt">Adverb</span></div></div><p>A subscript suffix &ldquo;<span class="spec-nt list">Symbol<span class="spec-mods"><span class="spec-mod list">list</span></span></span>&rdquo; is shorthand for a list of one or more of that symbol.</p><p>As an example:</p><div class="spec-production" id="Book"><span class="spec-nt"><a href="#Book">Book</a></span><div class="spec-rhs"><span class="spec-nt">Cover</span><span class="spec-nt list">Page<span class="spec-mods"><span class="spec-mod list">list</span></span></span><span class="spec-nt">Cover</span></div></div><p>is shorthand for</p><div class="spec-production" id="Book"><span class="spec-nt"><a href="#Book">Book</a></span><div class="spec-rhs"><span class="spec-nt">Cover</span><span class="spec-nt"><a href="#Page_list">Page_list</a></span><span class="spec-nt">Cover</span></div></div><div class="spec-production" id="Page_list"><span class="spec-nt"><a href="#Page_list">Page_list</a></span><div class="spec-rhs"><span class="spec-nt">Page</span></div><div class="spec-rhs"><span class="spec-nt"><a href="#Page_list">Page_list</a></span><span class="spec-nt">Page</span></div></div><p><strong>Parameterized Grammar Productions</strong></p><p>A symbol definition subscript suffix parameter in braces &ldquo;<span class="spec-nt">Symbol<span class="spec-mods"><span class="spec-params"><span class="spec-param">Param</span></span></span></span>&rdquo; is shorthand for two symbol definitions, one appended with that parameter name, the other without. The same subscript suffix on a symbol is shorthand for that variant of the definition. If the parameter starts with &ldquo;?&rdquo;, that form of the symbol is used if in a symbol definition with the same parameter. Some possible sequences can be included or excluded conditionally when respectively prefixed with &ldquo;[+Param]&rdquo; and &ldquo;[~Param]&rdquo;.</p><p>As an example:</p><div class="spec-production" id="Example"><span class="spec-nt"><a href="#Example">Example</a><span class="spec-mods"><span class="spec-params"><span class="spec-param">Param</span></span></span></span><div class="spec-rhs"><span class="spec-nt">A</span></div><div class="spec-rhs"><span class="spec-nt">B<span class="spec-mods"><span class="spec-params"><span class="spec-param">Param</span></span></span></span></div><div class="spec-rhs"><span class="spec-nt">C<span class="spec-mods"><span class="spec-params"><span class="spec-param conditional">Param</span></span></span></span></div><div class="spec-rhs"><span class="spec-condition">Param</span><span class="spec-nt">D</span></div><div class="spec-rhs"><span class="spec-condition not">Param</span><span class="spec-nt">E</span></div></div><p>is shorthand for</p><div class="spec-production" id="Example"><span class="spec-nt"><a href="#Example">Example</a></span><div class="spec-rhs"><span class="spec-nt">A</span></div><div class="spec-rhs"><span class="spec-nt">B_param</span></div><div class="spec-rhs"><span class="spec-nt">C</span></div><div class="spec-rhs"><span class="spec-nt">E</span></div></div><div class="spec-production" id="Example_param"><span class="spec-nt"><a href="#Example_param">Example_param</a></span><div class="spec-rhs"><span class="spec-nt">A</span></div><div class="spec-rhs"><span class="spec-nt">B_param</span></div><div class="spec-rhs"><span class="spec-nt">C_param</span></div><div class="spec-rhs"><span class="spec-nt">D</span></div></div></section><section id="sec-Grammar-Semantics-" secid="A.4"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Grammar-Semantics-">A.4</a></span>Grammar Semantics/语法语义</h3><p>This specification describes the semantic value of many grammar productions in the form of a list of algorithmic steps.</p><p>For example, this describes how a parser should interpret a string literal:</p><div class="spec-semantic d2"><span class="spec-nt"><a href="#StringValue">StringValue</a></span><div class="spec-rhs"><span class="spec-t">&quot;&quot;</span></div><ol><li>Return an empty Unicode character sequence.</li></ol></div><div class="spec-semantic d2"><span class="spec-nt"><a href="#StringValue">StringValue</a></span><div class="spec-rhs"><span class="spec-t">&quot;</span><span class="spec-nt list"><a href="#StringCharacter">StringCharacter</a><span class="spec-mods"><span class="spec-mod list">list</span></span></span><span class="spec-t">&quot;</span></div><ol><li>Return the Unicode character sequence of all <span class="spec-nt"><a href="#StringCharacter">StringCharacter</a></span> Unicode character values.</li></ol></div></section><section id="sec-Algorithms-" secid="A.5"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Algorithms-">A.5</a></span>Algorithms/算法</h3><p>This specification describes some algorithms used by the static and runtime semantics, they&rsquo;re defined in the form of a function&#8208;like syntax along with a list of algorithmic steps to take.</p><p>For example, this describes if a fragment should be spread into place given a runtime <var>objectType</var> and the fragment&rsquo;s <var>fragmentType</var>:</p><div class="spec-algo" id="doesFragmentTypeApply()"><span class="spec-call"><a href="#doesFragmentTypeApply()">doesFragmentTypeApply</a>(<var>objectType</var>, <var>fragmentType</var>)</span><ol><li>If <var>fragmentType</var> is an Object Type:<ol><li>if <var>objectType</var> and <var>fragmentType</var> are the same type, return <span class="spec-keyword">true</span>, otherwise return <span class="spec-keyword">false</span>.</li></ol></li><li>If <var>fragmentType</var> is an Interface Type:<ol><li>if <var>objectType</var> is an implementation of <var>fragmentType</var>, return <span class="spec-keyword">true</span> otherwise return <span class="spec-keyword">false</span>.</li></ol></li><li>If <var>fragmentType</var> is a Union:<ol><li>if <var>objectType</var> is a possible type of <var>fragmentType</var>, return <span class="spec-keyword">true</span> otherwise return <span class="spec-keyword">false</span>.</li></ol></li></ol></div></section></section><section id="sec-Appendix-Grammar-Summary-A-" secid="B"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Appendix-Grammar-Summary-A-">B</a></span>Appendix: Grammar Summary/A.附录：语法总结</h2><div class="spec-production d2" id="SourceCharacter"><span class="spec-nt"><a href="#SourceCharacter">SourceCharacter</a></span><div class="spec-rhs"><span class="spec-rx">/[\u0009\u000A\u000D\u0020-\uFFFF]/</span></div></div><section id="sec-Appendix-Grammar-Summary-A-.Ignored-Tokens-" secid="B.1"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Appendix-Grammar-Summary-A-.Ignored-Tokens-">B.1</a></span>Ignored Tokens/忽略符号</h3><div class="spec-production d2" id="Ignored"><span class="spec-nt"><a href="#Ignored">Ignored</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#UnicodeBOM">UnicodeBOM</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#WhiteSpace">WhiteSpace</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#LineTerminator">LineTerminator</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#Comment">Comment</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#Comma">Comma</a></span></div></div><div class="spec-production d2" id="UnicodeBOM"><span class="spec-nt"><a href="#UnicodeBOM">UnicodeBOM</a></span><div class="spec-rhs"><span class="spec-prose">Byte Order Mark (U+FEFF)</span></div></div><div class="spec-production d2" id="WhiteSpace"><span class="spec-nt"><a href="#WhiteSpace">WhiteSpace</a></span><div class="spec-rhs"><span class="spec-prose">Horizontal Tab (U+0009)</span></div><div class="spec-rhs"><span class="spec-prose">Space (U+0020)</span></div></div><div class="spec-production d2" id="LineTerminator"><span class="spec-nt"><a href="#LineTerminator">LineTerminator</a></span><div class="spec-rhs"><span class="spec-prose">New Line (U+000A)</span></div><div class="spec-rhs"><span class="spec-prose">Carriage Return (U+000D)</span><span class="spec-lookahead not"><span class="spec-prose">New Line (U+000A)</span></span></div><div class="spec-rhs"><span class="spec-prose">Carriage Return (U+000D)</span><span class="spec-prose">New Line (U+000A)</span></div></div><div class="spec-production d2" id="Comment"><span class="spec-nt"><a href="#Comment">Comment</a></span><div class="spec-rhs"><span class="spec-t">#</span><span class="spec-nt list optional"><a href="#CommentChar">CommentChar</a><span class="spec-mods"><span class="spec-mod list">list</span><span class="spec-mod optional">opt</span></span></span></div></div><div class="spec-production d2" id="CommentChar"><span class="spec-nt"><a href="#CommentChar">CommentChar</a></span><div class="spec-rhs"><span class="spec-constrained"><span class="spec-nt"><a href="#SourceCharacter">SourceCharacter</a></span><span class="spec-butnot"><span class="spec-nt"><a href="#LineTerminator">LineTerminator</a></span></span></span></div></div><div class="spec-production d2" id="Comma"><span class="spec-nt"><a href="#Comma">Comma</a></span><div class="spec-rhs"><span class="spec-t">,</span></div></div></section><section id="sec-Appendix-Grammar-Summary-A-.Lexical-Tokens-" secid="B.2"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Appendix-Grammar-Summary-A-.Lexical-Tokens-">B.2</a></span>Lexical Tokens/词法符号</h3><div class="spec-production d2" id="Token"><span class="spec-nt"><a href="#Token">Token</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Punctuator">Punctuator</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#Name">Name</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#IntValue">IntValue</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#FloatValue">FloatValue</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#StringValue">StringValue</a></span></div></div><div class="spec-production d2" id="Punctuator"><span class="spec-nt"><a href="#Punctuator">Punctuator</a></span><div class="spec-oneof"><table><tr><td class="spec-rhs"><span class="spec-t">!</span></td><td class="spec-rhs"><span class="spec-t">$</span></td><td class="spec-rhs"><span class="spec-t">(</span></td><td class="spec-rhs"><span class="spec-t">)</span></td><td class="spec-rhs"><span class="spec-t">...</span></td><td class="spec-rhs"><span class="spec-t">:</span></td><td class="spec-rhs"><span class="spec-t">=</span></td><td class="spec-rhs"><span class="spec-t">@</span></td><td class="spec-rhs"><span class="spec-t">[</span></td><td class="spec-rhs"><span class="spec-t">]</span></td><td class="spec-rhs"><span class="spec-t">{</span></td><td class="spec-rhs"><span class="spec-t">|</span></td><td class="spec-rhs"><span class="spec-t">}</span></td></tr></table></div></div><div class="spec-production d2" id="Name"><span class="spec-nt"><a href="#Name">Name</a></span><div class="spec-rhs"><span class="spec-rx">/[_A-Za-z][_0-9A-Za-z]*/</span></div></div><div class="spec-production d2" id="IntValue"><span class="spec-nt"><a href="#IntValue">IntValue</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#IntegerPart">IntegerPart</a></span></div></div><div class="spec-production d2" id="IntegerPart"><span class="spec-nt"><a href="#IntegerPart">IntegerPart</a></span><div class="spec-rhs"><span class="spec-nt optional"><a href="#NegativeSign">NegativeSign</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span></span><span class="spec-t">0</span></div><div class="spec-rhs"><span class="spec-nt optional"><a href="#NegativeSign">NegativeSign</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span></span><span class="spec-nt"><a href="#NonZeroDigit">NonZeroDigit</a></span><span class="spec-nt list optional"><a href="#Digit">Digit</a><span class="spec-mods"><span class="spec-mod list">list</span><span class="spec-mod optional">opt</span></span></span></div></div><div class="spec-production d2" id="NegativeSign"><span class="spec-nt"><a href="#NegativeSign">NegativeSign</a></span><div class="spec-rhs"><span class="spec-t">-</span></div></div><div class="spec-production d2" id="Digit"><span class="spec-nt"><a href="#Digit">Digit</a></span><div class="spec-oneof"><table><tr><td class="spec-rhs"><span class="spec-t">0</span></td><td class="spec-rhs"><span class="spec-t">1</span></td><td class="spec-rhs"><span class="spec-t">2</span></td><td class="spec-rhs"><span class="spec-t">3</span></td><td class="spec-rhs"><span class="spec-t">4</span></td><td class="spec-rhs"><span class="spec-t">5</span></td><td class="spec-rhs"><span class="spec-t">6</span></td><td class="spec-rhs"><span class="spec-t">7</span></td><td class="spec-rhs"><span class="spec-t">8</span></td><td class="spec-rhs"><span class="spec-t">9</span></td></tr></table></div></div><div class="spec-production d2" id="NonZeroDigit"><span class="spec-nt"><a href="#NonZeroDigit">NonZeroDigit</a></span><div class="spec-rhs"><span class="spec-constrained"><span class="spec-nt"><a href="#Digit">Digit</a></span><span class="spec-butnot"><span class="spec-t">0</span></span></span></div></div><div class="spec-production d2" id="FloatValue"><span class="spec-nt"><a href="#FloatValue">FloatValue</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#IntegerPart">IntegerPart</a></span><span class="spec-nt"><a href="#FractionalPart">FractionalPart</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#IntegerPart">IntegerPart</a></span><span class="spec-nt"><a href="#ExponentPart">ExponentPart</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#IntegerPart">IntegerPart</a></span><span class="spec-nt"><a href="#FractionalPart">FractionalPart</a></span><span class="spec-nt"><a href="#ExponentPart">ExponentPart</a></span></div></div><div class="spec-production d2" id="FractionalPart"><span class="spec-nt"><a href="#FractionalPart">FractionalPart</a></span><div class="spec-rhs"><span class="spec-t">.</span><span class="spec-nt list"><a href="#Digit">Digit</a><span class="spec-mods"><span class="spec-mod list">list</span></span></span></div></div><div class="spec-production d2" id="ExponentPart"><span class="spec-nt"><a href="#ExponentPart">ExponentPart</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#ExponentIndicator">ExponentIndicator</a></span><span class="spec-nt optional"><a href="#Sign">Sign</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span></span><span class="spec-nt list"><a href="#Digit">Digit</a><span class="spec-mods"><span class="spec-mod list">list</span></span></span></div></div><div class="spec-production d2" id="ExponentIndicator"><span class="spec-nt"><a href="#ExponentIndicator">ExponentIndicator</a></span><div class="spec-oneof"><table><tr><td class="spec-rhs"><span class="spec-t">e</span></td><td class="spec-rhs"><span class="spec-t">E</span></td></tr></table></div></div><div class="spec-production d2" id="Sign"><span class="spec-nt"><a href="#Sign">Sign</a></span><div class="spec-oneof"><table><tr><td class="spec-rhs"><span class="spec-t">+</span></td><td class="spec-rhs"><span class="spec-t">-</span></td></tr></table></div></div><div class="spec-production d2" id="StringValue"><span class="spec-nt"><a href="#StringValue">StringValue</a></span><div class="spec-rhs"><span class="spec-t">&quot;&quot;</span></div><div class="spec-rhs"><span class="spec-t">&quot;</span><span class="spec-nt list"><a href="#StringCharacter">StringCharacter</a><span class="spec-mods"><span class="spec-mod list">list</span></span></span><span class="spec-t">&quot;</span></div></div><div class="spec-production d2" id="StringCharacter"><span class="spec-nt"><a href="#StringCharacter">StringCharacter</a></span><div class="spec-rhs"><span class="spec-constrained"><span class="spec-nt"><a href="#SourceCharacter">SourceCharacter</a></span><span class="spec-butnot"><span class="spec-t">&quot;</span><span class="spec-t">\</span><span class="spec-nt"><a href="#LineTerminator">LineTerminator</a></span></span></span></div><div class="spec-rhs"><span class="spec-t">\u</span><span class="spec-nt"><a href="#EscapedUnicode">EscapedUnicode</a></span></div><div class="spec-rhs"><span class="spec-t">\</span><span class="spec-nt"><a href="#EscapedCharacter">EscapedCharacter</a></span></div></div><div class="spec-production d2" id="EscapedUnicode"><span class="spec-nt"><a href="#EscapedUnicode">EscapedUnicode</a></span><div class="spec-rhs"><span class="spec-rx">/[0-9A-Fa-f]{4}/</span></div></div><div class="spec-production d2" id="EscapedCharacter"><span class="spec-nt"><a href="#EscapedCharacter">EscapedCharacter</a></span><div class="spec-oneof"><table><tr><td class="spec-rhs"><span class="spec-t">&quot;</span></td><td class="spec-rhs"><span class="spec-t">\</span></td><td class="spec-rhs"><span class="spec-t">/</span></td><td class="spec-rhs"><span class="spec-t">b</span></td><td class="spec-rhs"><span class="spec-t">f</span></td><td class="spec-rhs"><span class="spec-t">n</span></td><td class="spec-rhs"><span class="spec-t">r</span></td><td class="spec-rhs"><span class="spec-t">t</span></td></tr></table></div></div></section><section id="sec-Appendix-Grammar-Summary-A-.Query-Document-" secid="B.3"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Appendix-Grammar-Summary-A-.Query-Document-">B.3</a></span>Query Document/查询文档</h3><div class="spec-production" id="Document"><span class="spec-nt"><a href="#Document">Document</a></span><div class="spec-rhs"><span class="spec-nt list"><a href="#Definition">Definition</a><span class="spec-mods"><span class="spec-mod list">list</span></span></span></div></div><div class="spec-production" id="Definition"><span class="spec-nt"><a href="#Definition">Definition</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#OperationDefinition">OperationDefinition</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#FragmentDefinition">FragmentDefinition</a></span></div></div><div class="spec-production" id="OperationDefinition"><span class="spec-nt"><a href="#OperationDefinition">OperationDefinition</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#SelectionSet">SelectionSet</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#OperationType">OperationType</a></span><span class="spec-nt optional"><a href="#Name">Name</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span></span><span class="spec-nt optional"><a href="#VariableDefinitions">VariableDefinitions</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span></span><span class="spec-nt optional"><a href="#Directives">Directives</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span></span><span class="spec-nt"><a href="#SelectionSet">SelectionSet</a></span></div></div><div class="spec-production" id="OperationType"><span class="spec-nt"><a href="#OperationType">OperationType</a></span><div class="spec-oneof"><table><tr><td class="spec-rhs"><span class="spec-t">query</span></td><td class="spec-rhs"><span class="spec-t">mutation</span></td><td class="spec-rhs"><span class="spec-t">subscription</span></td></tr></table></div></div><div class="spec-production" id="SelectionSet"><span class="spec-nt"><a href="#SelectionSet">SelectionSet</a></span><div class="spec-rhs"><span class="spec-t">{</span><span class="spec-nt list"><a href="#Selection">Selection</a><span class="spec-mods"><span class="spec-mod list">list</span></span></span><span class="spec-t">}</span></div></div><div class="spec-production" id="Selection"><span class="spec-nt"><a href="#Selection">Selection</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Field">Field</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#FragmentSpread">FragmentSpread</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#InlineFragment">InlineFragment</a></span></div></div><div class="spec-production" id="Field"><span class="spec-nt"><a href="#Field">Field</a></span><div class="spec-rhs"><span class="spec-nt optional"><a href="#Alias">Alias</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span></span><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-nt optional"><a href="#Arguments">Arguments</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span></span><span class="spec-nt optional"><a href="#Directives">Directives</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span></span><span class="spec-nt optional"><a href="#SelectionSet">SelectionSet</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span></span></div></div><div class="spec-production" id="Alias"><span class="spec-nt"><a href="#Alias">Alias</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-t">:</span></div></div><div class="spec-production" id="Arguments"><span class="spec-nt"><a href="#Arguments">Arguments</a></span><div class="spec-rhs"><span class="spec-t">(</span><span class="spec-nt list"><a href="#Argument">Argument</a><span class="spec-mods"><span class="spec-mod list">list</span></span></span><span class="spec-t">)</span></div></div><div class="spec-production" id="Argument"><span class="spec-nt"><a href="#Argument">Argument</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-t">:</span><span class="spec-nt"><a href="#Value">Value</a></span></div></div><div class="spec-production" id="FragmentSpread"><span class="spec-nt"><a href="#FragmentSpread">FragmentSpread</a></span><div class="spec-rhs"><span class="spec-t">...</span><span class="spec-nt"><a href="#FragmentName">FragmentName</a></span><span class="spec-nt optional"><a href="#Directives">Directives</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span></span></div></div><div class="spec-production" id="InlineFragment"><span class="spec-nt"><a href="#InlineFragment">InlineFragment</a></span><div class="spec-rhs"><span class="spec-t">...</span><span class="spec-nt optional"><a href="#TypeCondition">TypeCondition</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span></span><span class="spec-nt optional"><a href="#Directives">Directives</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span></span><span class="spec-nt"><a href="#SelectionSet">SelectionSet</a></span></div></div><div class="spec-production" id="FragmentDefinition"><span class="spec-nt"><a href="#FragmentDefinition">FragmentDefinition</a></span><div class="spec-rhs"><span class="spec-t">fragment</span><span class="spec-nt"><a href="#FragmentName">FragmentName</a></span><span class="spec-nt"><a href="#TypeCondition">TypeCondition</a></span><span class="spec-nt optional"><a href="#Directives">Directives</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span></span><span class="spec-nt"><a href="#SelectionSet">SelectionSet</a></span></div></div><div class="spec-production" id="FragmentName"><span class="spec-nt"><a href="#FragmentName">FragmentName</a></span><div class="spec-rhs"><span class="spec-constrained"><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-butnot"><span class="spec-t">on</span></span></span></div></div><div class="spec-production" id="TypeCondition"><span class="spec-nt"><a href="#TypeCondition">TypeCondition</a></span><div class="spec-rhs"><span class="spec-t">on</span><span class="spec-nt"><a href="#NamedType">NamedType</a></span></div></div><div class="spec-production" id="Value"><span class="spec-nt"><a href="#Value">Value</a><span class="spec-mods"><span class="spec-params"><span class="spec-param">Const</span></span></span></span><div class="spec-rhs"><span class="spec-condition not">Const</span><span class="spec-nt"><a href="#Variable">Variable</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#IntValue">IntValue</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#FloatValue">FloatValue</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#StringValue">StringValue</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#BooleanValue">BooleanValue</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#NullValue">NullValue</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#EnumValue">EnumValue</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#ListValue">ListValue</a><span class="spec-mods"><span class="spec-params"><span class="spec-param conditional">Const</span></span></span></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#ObjectValue">ObjectValue</a><span class="spec-mods"><span class="spec-params"><span class="spec-param conditional">Const</span></span></span></span></div></div><div class="spec-production" id="BooleanValue"><span class="spec-nt"><a href="#BooleanValue">BooleanValue</a></span><div class="spec-oneof"><table><tr><td class="spec-rhs"><span class="spec-t">true</span></td><td class="spec-rhs"><span class="spec-t">false</span></td></tr></table></div></div><div class="spec-production" id="NullValue"><span class="spec-nt"><a href="#NullValue">NullValue</a></span><div class="spec-rhs"><span class="spec-t">null</span></div></div><div class="spec-production" id="EnumValue"><span class="spec-nt"><a href="#EnumValue">EnumValue</a></span><div class="spec-rhs"><span class="spec-constrained"><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-butnot"><span class="spec-t">true</span><span class="spec-t">false</span><span class="spec-t">null</span></span></span></div></div><div class="spec-production" id="ListValue"><span class="spec-nt"><a href="#ListValue">ListValue</a><span class="spec-mods"><span class="spec-params"><span class="spec-param">Const</span></span></span></span><div class="spec-rhs"><span class="spec-t">[</span><span class="spec-t">]</span></div><div class="spec-rhs"><span class="spec-t">[</span><span class="spec-nt list"><a href="#Value">Value</a><span class="spec-mods"><span class="spec-params"><span class="spec-param conditional">Const</span></span><span class="spec-mod list">list</span></span></span><span class="spec-t">]</span></div></div><div class="spec-production" id="ObjectValue"><span class="spec-nt"><a href="#ObjectValue">ObjectValue</a><span class="spec-mods"><span class="spec-params"><span class="spec-param">Const</span></span></span></span><div class="spec-rhs"><span class="spec-t">{</span><span class="spec-t">}</span></div><div class="spec-rhs"><span class="spec-t">{</span><span class="spec-nt list"><a href="#ObjectField">ObjectField</a><span class="spec-mods"><span class="spec-params"><span class="spec-param conditional">Const</span></span><span class="spec-mod list">list</span></span></span><span class="spec-t">}</span></div></div><div class="spec-production" id="ObjectField"><span class="spec-nt"><a href="#ObjectField">ObjectField</a><span class="spec-mods"><span class="spec-params"><span class="spec-param">Const</span></span></span></span><div class="spec-rhs"><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-t">:</span><span class="spec-nt"><a href="#Value">Value</a><span class="spec-mods"><span class="spec-params"><span class="spec-param conditional">Const</span></span></span></span></div></div><div class="spec-production" id="VariableDefinitions"><span class="spec-nt"><a href="#VariableDefinitions">VariableDefinitions</a></span><div class="spec-rhs"><span class="spec-t">(</span><span class="spec-nt list"><a href="#VariableDefinition">VariableDefinition</a><span class="spec-mods"><span class="spec-mod list">list</span></span></span><span class="spec-t">)</span></div></div><div class="spec-production" id="VariableDefinition"><span class="spec-nt"><a href="#VariableDefinition">VariableDefinition</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Variable">Variable</a></span><span class="spec-t">:</span><span class="spec-nt"><a href="#Type">Type</a></span><span class="spec-nt optional"><a href="#DefaultValue">DefaultValue</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span></span></div></div><div class="spec-production" id="Variable"><span class="spec-nt"><a href="#Variable">Variable</a></span><div class="spec-rhs"><span class="spec-t">$</span><span class="spec-nt"><a href="#Name">Name</a></span></div></div><div class="spec-production" id="DefaultValue"><span class="spec-nt"><a href="#DefaultValue">DefaultValue</a></span><div class="spec-rhs"><span class="spec-t">=</span><span class="spec-nt"><a href="#Value">Value</a><span class="spec-mods"><span class="spec-params"><span class="spec-param">Const</span></span></span></span></div></div><div class="spec-production" id="Type"><span class="spec-nt"><a href="#Type">Type</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#NamedType">NamedType</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#ListType">ListType</a></span></div><div class="spec-rhs"><span class="spec-nt"><a href="#NonNullType">NonNullType</a></span></div></div><div class="spec-production" id="NamedType"><span class="spec-nt"><a href="#NamedType">NamedType</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Name">Name</a></span></div></div><div class="spec-production" id="ListType"><span class="spec-nt"><a href="#ListType">ListType</a></span><div class="spec-rhs"><span class="spec-t">[</span><span class="spec-nt"><a href="#Type">Type</a></span><span class="spec-t">]</span></div></div><div class="spec-production" id="NonNullType"><span class="spec-nt"><a href="#NonNullType">NonNullType</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#NamedType">NamedType</a></span><span class="spec-t">!</span></div><div class="spec-rhs"><span class="spec-nt"><a href="#ListType">ListType</a></span><span class="spec-t">!</span></div></div><div class="spec-production" id="Directives"><span class="spec-nt"><a href="#Directives">Directives</a></span><div class="spec-rhs"><span class="spec-nt list"><a href="#Directive">Directive</a><span class="spec-mods"><span class="spec-mod list">list</span></span></span></div></div><div class="spec-production" id="Directive"><span class="spec-nt"><a href="#Directive">Directive</a></span><div class="spec-rhs"><span class="spec-t">@</span><span class="spec-nt"><a href="#Name">Name</a></span><span class="spec-nt optional"><a href="#Arguments">Arguments</a><span class="spec-mods"><span class="spec-mod optional">opt</span></span></span></div></div></section></section><footer>Written in <a href="http://leebyron.com/spec-md/" target="_blank">Spec Markdown</a>.</footer><input hidden class="spec-sidebar-toggle" type="checkbox" id="spec-sidebar-toggle" aria-hidden /><label for="spec-sidebar-toggle" aria-hidden>&#x2630;</label><div class="spec-sidebar" aria-hidden><div class="spec-toc"><div class="title"><a href="#">GraphQL</a></div><ol><li id="_sidebar_1"><a href="#sec-Overview-"><span class="spec-secid">1</span>Overview/概览</a></li><li id="_sidebar_2"><a href="#sec-Language-"><span class="spec-secid">2</span>Language/语言</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_2" /><label for="_sidebar_toggle_2"></label><ol><li id="_sidebar_2.1"><a href="#sec-Source-Text-"><span class="spec-secid">2.1</span>Source Text/源文本</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_2.1" /><label for="_sidebar_toggle_2.1"></label><ol><li id="_sidebar_2.1.1"><a href="#sec-Unicode-"><span class="spec-secid">2.1.1</span>Unicode/统一码</a></li><li id="_sidebar_2.1.2"><a href="#sec-White-Space-"><span class="spec-secid">2.1.2</span>White Space/空白符</a></li><li id="_sidebar_2.1.3"><a href="#sec-Line-Terminators-"><span class="spec-secid">2.1.3</span>Line Terminators/行终止符</a></li><li id="_sidebar_2.1.4"><a href="#sec-Comments-"><span class="spec-secid">2.1.4</span>Comments/注释</a></li><li id="_sidebar_2.1.5"><a href="#sec-Insignificant-Commas-"><span class="spec-secid">2.1.5</span>Insignificant Commas/无语义逗号</a></li><li id="_sidebar_2.1.6"><a href="#sec-Source-Text-.Lexical-Tokens-"><span class="spec-secid">2.1.6</span>Lexical Tokens/词法记号</a></li><li id="_sidebar_2.1.7"><a href="#sec-Source-Text-.Ignored-Tokens-"><span class="spec-secid">2.1.7</span>Ignored Tokens/无语义记号</a></li><li id="_sidebar_2.1.8"><a href="#sec-Punctuators-"><span class="spec-secid">2.1.8</span>Punctuators/标点</a></li><li id="_sidebar_2.1.9"><a href="#sec-Names-"><span class="spec-secid">2.1.9</span>Names/命名</a></li></ol></li><li id="_sidebar_2.2"><a href="#sec-Language-.Query-Document-"><span class="spec-secid">2.2</span>Query Document/查询文档</a></li><li id="_sidebar_2.3"><a href="#sec-Language-.Operations-"><span class="spec-secid">2.3</span>Operations/操作</a></li><li id="_sidebar_2.4"><a href="#sec-Selection-Sets-"><span class="spec-secid">2.4</span>Selection Sets/选择集合</a></li><li id="_sidebar_2.5"><a href="#sec-Language-.Fields-"><span class="spec-secid">2.5</span>Fields/字段</a></li><li id="_sidebar_2.6"><a href="#sec-Language-.Arguments-"><span class="spec-secid">2.6</span>Arguments/参数</a></li><li id="_sidebar_2.7"><a href="#sec-Field-Alias-"><span class="spec-secid">2.7</span>Field Alias/字段别名</a></li><li id="_sidebar_2.8"><a href="#sec-Language-.Fragments-"><span class="spec-secid">2.8</span>Fragments/片段</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_2.8" /><label for="_sidebar_toggle_2.8"></label><ol><li id="_sidebar_2.8.1"><a href="#sec-Type-Conditions-"><span class="spec-secid">2.8.1</span>Type Conditions/类型条件</a></li><li id="_sidebar_2.8.2"><a href="#sec-Inline-Fragments-"><span class="spec-secid">2.8.2</span>Inline Fragments/内联片段</a></li></ol></li><li id="_sidebar_2.9"><a href="#sec-Input-Values-"><span class="spec-secid">2.9</span>Input Values/输入值</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_2.9" /><label for="_sidebar_toggle_2.9"></label><ol><li id="_sidebar_2.9.1"><a href="#sec-Int-Value-"><span class="spec-secid">2.9.1</span>Int Value/整数值</a></li><li id="_sidebar_2.9.2"><a href="#sec-Float-Value-"><span class="spec-secid">2.9.2</span>Float Value/浮点值</a></li><li id="_sidebar_2.9.3"><a href="#sec-Boolean-Value-"><span class="spec-secid">2.9.3</span>Boolean Value/布尔值</a></li><li id="_sidebar_2.9.4"><a href="#sec-String-Value-"><span class="spec-secid">2.9.4</span>String Value/字符串值</a></li><li id="_sidebar_2.9.5"><a href="#sec-Null-Value-"><span class="spec-secid">2.9.5</span>Null Value/空值</a></li><li id="_sidebar_2.9.6"><a href="#sec-Enum-Value-"><span class="spec-secid">2.9.6</span>Enum Value/枚举值</a></li><li id="_sidebar_2.9.7"><a href="#sec-List-Value-"><span class="spec-secid">2.9.7</span>List Value/列表值</a></li><li id="_sidebar_2.9.8"><a href="#sec-Input-Object-Values-"><span class="spec-secid">2.9.8</span>Input Object Values/输入型对象值</a></li></ol></li><li id="_sidebar_2.10"><a href="#sec-Language-.Variables-"><span class="spec-secid">2.10</span>Variables/变量</a></li><li id="_sidebar_2.11"><a href="#sec-Input-Types-"><span class="spec-secid">2.11</span>Input Types/输入类型</a></li><li id="_sidebar_2.12"><a href="#sec-Language-.Directives-"><span class="spec-secid">2.12</span>Directives/指令</a></li></ol></li><li id="_sidebar_3"><a href="#sec-Type-System-"><span class="spec-secid">3</span>Type System/类型系统</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_3" /><label for="_sidebar_toggle_3"></label><ol><li id="_sidebar_3.1"><a href="#sec-Types-"><span class="spec-secid">3.1</span>Types/类型</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_3.1" /><label for="_sidebar_toggle_3.1"></label><ol><li id="_sidebar_3.1.1"><a href="#sec-Scalars-"><span class="spec-secid">3.1.1</span>Scalars/标量</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_3.1.1" /><label for="_sidebar_toggle_3.1.1"></label><ol><li id="_sidebar_3.1.1.1"><a href="#sec-Int-"><span class="spec-secid">3.1.1.1</span>Int/整数型</a></li><li id="_sidebar_3.1.1.2"><a href="#sec-Float-"><span class="spec-secid">3.1.1.2</span>Float/浮点型</a></li><li id="_sidebar_3.1.1.3"><a href="#sec-String-"><span class="spec-secid">3.1.1.3</span>String/字符串型</a></li><li id="_sidebar_3.1.1.4"><a href="#sec-Boolean-"><span class="spec-secid">3.1.1.4</span>Boolean/布尔型</a></li><li id="_sidebar_3.1.1.5"><a href="#sec-ID"><span class="spec-secid">3.1.1.5</span>ID</a></li></ol></li><li id="_sidebar_3.1.2"><a href="#sec-Objects-"><span class="spec-secid">3.1.2</span>Objects/对象</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_3.1.2" /><label for="_sidebar_toggle_3.1.2"></label><ol><li id="_sidebar_3.1.2.1"><a href="#sec-Object-Field-Arguments-"><span class="spec-secid">3.1.2.1</span>Object Field Arguments/对象字段参数</a></li><li id="_sidebar_3.1.2.2"><a href="#sec-Object-Field-deprecation-"><span class="spec-secid">3.1.2.2</span>Object Field deprecation/对象字段弃用</a></li><li id="_sidebar_3.1.2.3"><a href="#sec-Object-type-validation-"><span class="spec-secid">3.1.2.3</span>Object type validation/对象类型验证</a></li></ol></li><li id="_sidebar_3.1.3"><a href="#sec-Interfaces-"><span class="spec-secid">3.1.3</span>Interfaces/接口</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_3.1.3" /><label for="_sidebar_toggle_3.1.3"></label><ol><li id="_sidebar_3.1.3.1"><a href="#sec-Interface-type-validation-"><span class="spec-secid">3.1.3.1</span>Interface type validation/接口类型验证</a></li></ol></li><li id="_sidebar_3.1.4"><a href="#sec-Unions-"><span class="spec-secid">3.1.4</span>Unions/联合</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_3.1.4" /><label for="_sidebar_toggle_3.1.4"></label><ol><li id="_sidebar_3.1.4.1"><a href="#sec-Union-type-validation-"><span class="spec-secid">3.1.4.1</span>Union type validation/联合类型验证</a></li></ol></li><li id="_sidebar_3.1.5"><a href="#sec-Enums-"><span class="spec-secid">3.1.5</span>Enums/枚举型</a></li><li id="_sidebar_3.1.6"><a href="#sec-Input-Objects-"><span class="spec-secid">3.1.6</span>Input Objects/输入对象</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_3.1.6" /><label for="_sidebar_toggle_3.1.6"></label><ol><li id="_sidebar_3.1.6.1"><a href="#sec-Input-Object-type-validation-"><span class="spec-secid">3.1.6.1</span>Input Object type validation/输入对象类型验证</a></li></ol></li><li id="_sidebar_3.1.7"><a href="#sec-Lists-"><span class="spec-secid">3.1.7</span>Lists/列表型</a></li><li id="_sidebar_3.1.8"><a href="#sec-Types-.Non-Null-"><span class="spec-secid">3.1.8</span>Non-Null/非空型</a></li></ol></li><li id="_sidebar_3.2"><a href="#sec-Type-System-.Directives-"><span class="spec-secid">3.2</span>Directives/指令</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_3.2" /><label for="_sidebar_toggle_3.2"></label><ol><li id="_sidebar_3.2.1"><a href="#sec--skip"><span class="spec-secid">3.2.1</span>@skip</a></li><li id="_sidebar_3.2.2"><a href="#sec--include"><span class="spec-secid">3.2.2</span>@include</a></li></ol></li><li id="_sidebar_3.3"><a href="#sec-Initial-types-"><span class="spec-secid">3.3</span>Initial types/初始类型</a></li></ol></li><li id="_sidebar_4"><a href="#sec-Introspection-"><span class="spec-secid">4</span>Introspection/内省</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_4" /><label for="_sidebar_toggle_4"></label><ol><li id="_sidebar_4.1"><a href="#sec-General-Principles-"><span class="spec-secid">4.1</span>General Principles/基本原则</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_4.1" /><label for="_sidebar_toggle_4.1"></label><ol><li id="_sidebar_4.1.1"><a href="#sec-Naming-conventions-"><span class="spec-secid">4.1.1</span>Naming conventions/命名约定</a></li><li id="_sidebar_4.1.2"><a href="#sec-Documentation-"><span class="spec-secid">4.1.2</span>Documentation/文档</a></li><li id="_sidebar_4.1.3"><a href="#sec-Deprecation-"><span class="spec-secid">4.1.3</span>Deprecation/弃用</a></li><li id="_sidebar_4.1.4"><a href="#sec-Type-Name-Introspection-"><span class="spec-secid">4.1.4</span>Type Name Introspection/类型命名内省</a></li></ol></li><li id="_sidebar_4.2"><a href="#sec-Schema-Introspection-Schema-"><span class="spec-secid">4.2</span>Schema Introspection/Schema内省</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_4.2" /><label for="_sidebar_toggle_4.2"></label><ol><li id="_sidebar_4.2.1"><a href="#sec-The-__Type-Type-__Type-"><span class="spec-secid">4.2.1</span>The __Type Type/__Type类型</a></li><li id="_sidebar_4.2.2"><a href="#sec-Type-Kinds-"><span class="spec-secid">4.2.2</span>Type Kinds/类型种类</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_4.2.2" /><label for="_sidebar_toggle_4.2.2"></label><ol><li id="_sidebar_4.2.2.1"><a href="#sec-Scalar-"><span class="spec-secid">4.2.2.1</span>Scalar/标量</a></li><li id="_sidebar_4.2.2.2"><a href="#sec-Object-"><span class="spec-secid">4.2.2.2</span>Object/对象</a></li><li id="_sidebar_4.2.2.3"><a href="#sec-Union-"><span class="spec-secid">4.2.2.3</span>Union/联合</a></li><li id="_sidebar_4.2.2.4"><a href="#sec-Interface-"><span class="spec-secid">4.2.2.4</span>Interface/接口</a></li><li id="_sidebar_4.2.2.5"><a href="#sec-Enum-"><span class="spec-secid">4.2.2.5</span>Enum/枚举型</a></li><li id="_sidebar_4.2.2.6"><a href="#sec-Input-Object-"><span class="spec-secid">4.2.2.6</span>Input Object/输入对象</a></li><li id="_sidebar_4.2.2.7"><a href="#sec-List-"><span class="spec-secid">4.2.2.7</span>List/列表</a></li><li id="_sidebar_4.2.2.8"><a href="#sec-Type-Kinds-.Non-Null-"><span class="spec-secid">4.2.2.8</span>Non-Null/非空</a></li><li id="_sidebar_4.2.2.9"><a href="#sec-Combining-List-and-Non-Null-"><span class="spec-secid">4.2.2.9</span>Combining List and Non-Null/列表和非空的组合</a></li></ol></li><li id="_sidebar_4.2.3"><a href="#sec-The-__Field-Type-__Field-"><span class="spec-secid">4.2.3</span>The __Field Type/__Field类型</a></li><li id="_sidebar_4.2.4"><a href="#sec-The-__InputValue-Type-__InputValue-"><span class="spec-secid">4.2.4</span>The __InputValue Type/__InputValue类型</a></li><li id="_sidebar_4.2.5"><a href="#sec-The-__EnumValue-Type-__EnumValue-"><span class="spec-secid">4.2.5</span>The __EnumValue Type/__EnumValue类型</a></li><li id="_sidebar_4.2.6"><a href="#sec-The-__Directive-Type-__Directive-"><span class="spec-secid">4.2.6</span>The __Directive Type/__Directive类型</a></li></ol></li></ol></li><li id="_sidebar_5"><a href="#sec-Validation-"><span class="spec-secid">5</span>Validation/验证</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_5" /><label for="_sidebar_toggle_5"></label><ol><li id="_sidebar_5.1"><a href="#sec-Validation-.Operations-"><span class="spec-secid">5.1</span>Operations/操作</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_5.1" /><label for="_sidebar_toggle_5.1"></label><ol><li id="_sidebar_5.1.1"><a href="#sec-Named-Operation-Definitions-"><span class="spec-secid">5.1.1</span>Named Operation Definitions/具名操作定义</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_5.1.1" /><label for="_sidebar_toggle_5.1.1"></label><ol><li id="_sidebar_5.1.1.1"><a href="#sec-Operation-Name-Uniqueness-"><span class="spec-secid">5.1.1.1</span>Operation Name Uniqueness/操作名唯一性</a></li></ol></li><li id="_sidebar_5.1.2"><a href="#sec-Anonymous-Operation-Definitions-"><span class="spec-secid">5.1.2</span>Anonymous Operation Definitions/匿名操作定义</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_5.1.2" /><label for="_sidebar_toggle_5.1.2"></label><ol><li id="_sidebar_5.1.2.1"><a href="#sec-Lone-Anonymous-Operation-"><span class="spec-secid">5.1.2.1</span>Lone Anonymous Operation/单独匿名操作</a></li></ol></li><li id="_sidebar_5.1.3"><a href="#sec-Subscription-Operation-Definitions-"><span class="spec-secid">5.1.3</span>Subscription Operation Definitions/订阅操作定义</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_5.1.3" /><label for="_sidebar_toggle_5.1.3"></label><ol><li id="_sidebar_5.1.3.1"><a href="#sec-Single-root-field-"><span class="spec-secid">5.1.3.1</span>Single root field/单个根级字段</a></li></ol></li></ol></li><li id="_sidebar_5.2"><a href="#sec-Validation-.Fields-"><span class="spec-secid">5.2</span>Fields/字段</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_5.2" /><label for="_sidebar_toggle_5.2"></label><ol><li id="_sidebar_5.2.1"><a href="#sec-Field-Selections-on-Objects-Interfaces-and-Unions-Types-"><span class="spec-secid">5.2.1</span>Field Selections on Objects, Interfaces, and Unions Types/对象、接口和联合上的字段选择</a></li><li id="_sidebar_5.2.2"><a href="#sec-Field-Selection-Merging-"><span class="spec-secid">5.2.2</span>Field Selection Merging/字段选择合并</a></li><li id="_sidebar_5.2.3"><a href="#sec-Leaf-Field-Selections-"><span class="spec-secid">5.2.3</span>Leaf Field Selections/叶子节点选择</a></li></ol></li><li id="_sidebar_5.3"><a href="#sec-Validation-.Arguments-"><span class="spec-secid">5.3</span>Arguments/参数</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_5.3" /><label for="_sidebar_toggle_5.3"></label><ol><li id="_sidebar_5.3.1"><a href="#sec-Argument-Names-"><span class="spec-secid">5.3.1</span>Argument Names/参数名</a></li><li id="_sidebar_5.3.2"><a href="#sec-Argument-Uniqueness-"><span class="spec-secid">5.3.2</span>Argument Uniqueness/参数唯一性</a></li><li id="_sidebar_5.3.3"><a href="#sec-Argument-Values-Type-Correctness-"><span class="spec-secid">5.3.3</span>Argument Values Type Correctness/参数值类型正确性</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_5.3.3" /><label for="_sidebar_toggle_5.3.3"></label><ol><li id="_sidebar_5.3.3.1"><a href="#sec-Compatible-Values-"><span class="spec-secid">5.3.3.1</span>Compatible Values/兼容值</a></li><li id="_sidebar_5.3.3.2"><a href="#sec-Required-Non-Null-Arguments-"><span class="spec-secid">5.3.3.2</span>Required Non-Null Arguments/必要非空参数</a></li></ol></li></ol></li><li id="_sidebar_5.4"><a href="#sec-Validation-.Fragments-"><span class="spec-secid">5.4</span>Fragments/片段</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_5.4" /><label for="_sidebar_toggle_5.4"></label><ol><li id="_sidebar_5.4.1"><a href="#sec-Fragment-Declarations-"><span class="spec-secid">5.4.1</span>Fragment Declarations/片段声明</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_5.4.1" /><label for="_sidebar_toggle_5.4.1"></label><ol><li id="_sidebar_5.4.1.1"><a href="#sec-Fragment-Name-Uniqueness-"><span class="spec-secid">5.4.1.1</span>Fragment Name Uniqueness/片段名唯一性</a></li><li id="_sidebar_5.4.1.2"><a href="#sec-Fragment-Spread-Type-Existence-"><span class="spec-secid">5.4.1.2</span>Fragment Spread Type Existence/片段解构类型存在性</a></li><li id="_sidebar_5.4.1.3"><a href="#sec-Fragments-On-Composite-Types-"><span class="spec-secid">5.4.1.3</span>Fragments On Composite Types/组合类型上的片段</a></li><li id="_sidebar_5.4.1.4"><a href="#sec-Fragments-Must-Be-Used-"><span class="spec-secid">5.4.1.4</span>Fragments Must Be Used/必须使用的片段</a></li></ol></li><li id="_sidebar_5.4.2"><a href="#sec-Fragment-Spreads-"><span class="spec-secid">5.4.2</span>Fragment Spreads/片段解构</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_5.4.2" /><label for="_sidebar_toggle_5.4.2"></label><ol><li id="_sidebar_5.4.2.1"><a href="#sec-Fragment-spread-target-defined-"><span class="spec-secid">5.4.2.1</span>Fragment spread target defined/片段解构目标必须预先定义</a></li><li id="_sidebar_5.4.2.2"><a href="#sec-Fragment-spreads-must-not-form-cycles-"><span class="spec-secid">5.4.2.2</span>Fragment spreads must not form cycles/片段解构不可造成循环</a></li><li id="_sidebar_5.4.2.3"><a href="#sec-Fragment-spread-is-possible-"><span class="spec-secid">5.4.2.3</span>Fragment spread is possible/片段结构必须可行</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_5.4.2.3" /><label for="_sidebar_toggle_5.4.2.3"></label><ol><li id="_sidebar_5.4.2.3.1"><a href="#sec-Object-Spreads-In-Object-Scope-"><span class="spec-secid">5.4.2.3.1</span>Object Spreads In Object Scope/对象范围内的对象解构</a></li><li id="_sidebar_5.4.2.3.2"><a href="#sec-Abstract-Spreads-in-Object-Scope-"><span class="spec-secid">5.4.2.3.2</span>Abstract Spreads in Object Scope/对象范围内的抽象解构</a></li><li id="_sidebar_5.4.2.3.3"><a href="#sec-Object-Spreads-In-Abstract-Scope-"><span class="spec-secid">5.4.2.3.3</span>Object Spreads In Abstract Scope/抽象范围内的对象解构</a></li><li id="_sidebar_5.4.2.3.4"><a href="#sec-Abstract-Spreads-in-Abstract-Scope-"><span class="spec-secid">5.4.2.3.4</span>Abstract Spreads in Abstract Scope/抽象范围内的抽象解构</a></li></ol></li></ol></li></ol></li><li id="_sidebar_5.5"><a href="#sec-Values-"><span class="spec-secid">5.5</span>Values/值</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_5.5" /><label for="_sidebar_toggle_5.5"></label><ol><li id="_sidebar_5.5.1"><a href="#sec-Input-Object-Field-Uniqueness-"><span class="spec-secid">5.5.1</span>Input Object Field Uniqueness/输入对象字段唯一性</a></li></ol></li><li id="_sidebar_5.6"><a href="#sec-Validation-.Directives-"><span class="spec-secid">5.6</span>Directives/指令</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_5.6" /><label for="_sidebar_toggle_5.6"></label><ol><li id="_sidebar_5.6.1"><a href="#sec-Directives-Are-Defined-"><span class="spec-secid">5.6.1</span>Directives Are Defined/指令必须预先定义</a></li><li id="_sidebar_5.6.2"><a href="#sec-Directives-Are-In-Valid-Locations-"><span class="spec-secid">5.6.2</span>Directives Are In Valid Locations/指令必须在有效位置</a></li><li id="_sidebar_5.6.3"><a href="#sec-Directives-Are-Unique-Per-Location-"><span class="spec-secid">5.6.3</span>Directives Are Unique Per Location/每个位置的指令都必须唯一</a></li></ol></li><li id="_sidebar_5.7"><a href="#sec-Validation-.Variables-"><span class="spec-secid">5.7</span>Variables/变量</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_5.7" /><label for="_sidebar_toggle_5.7"></label><ol><li id="_sidebar_5.7.1"><a href="#sec-Variable-Uniqueness-"><span class="spec-secid">5.7.1</span>Variable Uniqueness/变量唯一性</a></li><li id="_sidebar_5.7.2"><a href="#sec-Variable-Default-Values-Are-Correctly-Typed-"><span class="spec-secid">5.7.2</span>Variable Default Values Are Correctly Typed/变量默认值必须是正确的类型</a></li><li id="_sidebar_5.7.3"><a href="#sec-Variables-Are-Input-Types-"><span class="spec-secid">5.7.3</span>Variables Are Input Types/变量必须是输入类型</a></li><li id="_sidebar_5.7.4"><a href="#sec-All-Variable-Uses-Defined-"><span class="spec-secid">5.7.4</span>All Variable Uses Defined/所有变量的使用必须预先定义</a></li><li id="_sidebar_5.7.5"><a href="#sec-All-Variables-Used-"><span class="spec-secid">5.7.5</span>All Variables Used/所有变量都必须被使用</a></li><li id="_sidebar_5.7.6"><a href="#sec-All-Variable-Usages-are-Allowed-"><span class="spec-secid">5.7.6</span>All Variable Usages are Allowed/所有变量都允许使用</a></li></ol></li></ol></li><li id="_sidebar_6"><a href="#sec-Execution-"><span class="spec-secid">6</span>Execution/执行</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_6" /><label for="_sidebar_toggle_6"></label><ol><li id="_sidebar_6.1"><a href="#sec-Executing-Requests-"><span class="spec-secid">6.1</span>Executing Requests/执行请求</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_6.1" /><label for="_sidebar_toggle_6.1"></label><ol><li id="_sidebar_6.1.1"><a href="#sec-Validating-Requests-"><span class="spec-secid">6.1.1</span>Validating Requests/验证请求</a></li><li id="_sidebar_6.1.2"><a href="#sec-Coercing-Variable-Values-"><span class="spec-secid">6.1.2</span>Coercing Variable Values/转换变量值</a></li></ol></li><li id="_sidebar_6.2"><a href="#sec-Executing-Operations-"><span class="spec-secid">6.2</span>Executing Operations/执行操作</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_6.2" /><label for="_sidebar_toggle_6.2"></label><ol><li id="_sidebar_6.2.1"><a href="#sec-Query-"><span class="spec-secid">6.2.1</span>Query/查询</a></li><li id="_sidebar_6.2.2"><a href="#sec-Mutation-"><span class="spec-secid">6.2.2</span>Mutation/更改</a></li><li id="_sidebar_6.2.3"><a href="#sec-Subscription-"><span class="spec-secid">6.2.3</span>Subscription/订阅</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_6.2.3" /><label for="_sidebar_toggle_6.2.3"></label><ol><li id="_sidebar_6.2.3.1"><a href="#sec-Source-Stream-"><span class="spec-secid">6.2.3.1</span>Source Stream/源流</a></li><li id="_sidebar_6.2.3.2"><a href="#sec-Response-Stream-"><span class="spec-secid">6.2.3.2</span>Response Stream/响应流</a></li><li id="_sidebar_6.2.3.3"><a href="#sec-Unsubscribe-"><span class="spec-secid">6.2.3.3</span>Unsubscribe/退订</a></li></ol></li></ol></li><li id="_sidebar_6.3"><a href="#sec-Executing-Selection-Sets-"><span class="spec-secid">6.3</span>Executing Selection Sets/执行选择集</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_6.3" /><label for="_sidebar_toggle_6.3"></label><ol><li id="_sidebar_6.3.1"><a href="#sec-Normal-and-Serial-Execution-"><span class="spec-secid">6.3.1</span>Normal and Serial Execution/正常序列执行</a></li><li id="_sidebar_6.3.2"><a href="#sec-Field-Collection-"><span class="spec-secid">6.3.2</span>Field Collection/字段集合</a></li></ol></li><li id="_sidebar_6.4"><a href="#sec-Executing-Fields-"><span class="spec-secid">6.4</span>Executing Fields/执行字段</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_6.4" /><label for="_sidebar_toggle_6.4"></label><ol><li id="_sidebar_6.4.1"><a href="#sec-Coercing-Field-Arguments-"><span class="spec-secid">6.4.1</span>Coercing Field Arguments/转换字段参数</a></li><li id="_sidebar_6.4.2"><a href="#sec-Value-Resolution-"><span class="spec-secid">6.4.2</span>Value Resolution/值解析</a></li><li id="_sidebar_6.4.3"><a href="#sec-Value-Completion-"><span class="spec-secid">6.4.3</span>Value Completion/值完成</a></li><li id="_sidebar_6.4.4"><a href="#sec-Errors-and-Non-Nullability-"><span class="spec-secid">6.4.4</span>Errors and Non-Nullability/错误与非空</a></li></ol></li></ol></li><li id="_sidebar_7"><a href="#sec-Response-"><span class="spec-secid">7</span>Response/响应</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_7" /><label for="_sidebar_toggle_7"></label><ol><li id="_sidebar_7.1"><a href="#sec-Serialization-Format-"><span class="spec-secid">7.1</span>Serialization Format/序列化格式</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_7.1" /><label for="_sidebar_toggle_7.1"></label><ol><li id="_sidebar_7.1.1"><a href="#sec-JSON-Serialization-JSON-"><span class="spec-secid">7.1.1</span>JSON Serialization/JSON序列化</a></li></ol></li><li id="_sidebar_7.2"><a href="#sec-Response-Format-"><span class="spec-secid">7.2</span>Response Format/响应格式</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_7.2" /><label for="_sidebar_toggle_7.2"></label><ol><li id="_sidebar_7.2.1"><a href="#sec-Data-"><span class="spec-secid">7.2.1</span>Data/数据</a></li><li id="_sidebar_7.2.2"><a href="#sec-Errors-"><span class="spec-secid">7.2.2</span>Errors/错误</a></li></ol></li></ol></li><li id="_sidebar_A"><a href="#sec-Appendix-Notation-Conventions-A-"><span class="spec-secid">A</span>Appendix: Notation Conventions/A.附录：符号约定</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_A" /><label for="_sidebar_toggle_A"></label><ol><li id="_sidebar_A.1"><a href="#sec-Context-Free-Grammar-"><span class="spec-secid">A.1</span>Context-Free Grammar/无上下文的语法</a></li><li id="_sidebar_A.2"><a href="#sec-Lexical-and-Syntactical-Grammar-"><span class="spec-secid">A.2</span>Lexical and Syntactical Grammar/词句上的语法</a></li><li id="_sidebar_A.3"><a href="#sec-Grammar-Notation-"><span class="spec-secid">A.3</span>Grammar Notation/语法符号</a></li><li id="_sidebar_A.4"><a href="#sec-Grammar-Semantics-"><span class="spec-secid">A.4</span>Grammar Semantics/语法语义</a></li><li id="_sidebar_A.5"><a href="#sec-Algorithms-"><span class="spec-secid">A.5</span>Algorithms/算法</a></li></ol></li><li id="_sidebar_B"><a href="#sec-Appendix-Grammar-Summary-A-"><span class="spec-secid">B</span>Appendix: Grammar Summary/A.附录：语法总结</a><input hidden class="toggle" type="checkbox" id="_sidebar_toggle_B" /><label for="_sidebar_toggle_B"></label><ol><li id="_sidebar_B.1"><a href="#sec-Appendix-Grammar-Summary-A-.Ignored-Tokens-"><span class="spec-secid">B.1</span>Ignored Tokens/忽略符号</a></li><li id="_sidebar_B.2"><a href="#sec-Appendix-Grammar-Summary-A-.Lexical-Tokens-"><span class="spec-secid">B.2</span>Lexical Tokens/词法符号</a></li><li id="_sidebar_B.3"><a href="#sec-Appendix-Grammar-Summary-A-.Query-Document-"><span class="spec-secid">B.3</span>Query Document/查询文档</a></li></ol></li></ol></div><script>
(function () {
var currentSection;
var numberedSections = [];

var sections = document.getElementsByTagName('section');
for (var i = 0; i < sections.length; i++) {
  if (sections[i].getAttribute('secid')) {
    numberedSections.push(sections[i]);
  }
}

var scrollPos = window.scrollY;
var pending = false;
window.addEventListener('scroll', function (e) {
  scrollPos = window.scrollY;
  if (!pending) {
    pending = true;
    window.requestAnimationFrame(function () {
      updateSectionFocus(scrollPos);
      pending = false;
    });
  }
});

function updateSectionFocus(pos) {
  var readLine = pos + document.documentElement.clientHeight / 4;

  var focusedSection;
  for (var n = numberedSections.length - 1; n >= 0; n--) {
    if (numberedSections[n].offsetTop < readLine) {
      focusedSection = numberedSections[n];
      break;
    }
  }

  var secid = focusedSection && focusedSection.getAttribute('secid');
  if (secid !== currentSection) {
    currentSection && fold(currentSection, false);
    secid && fold(secid, true);
    currentSection = secid;
  }
}

function fold(secid, check) {
  document.getElementById('_sidebar_' + secid).className = check ? 'viewing' : '';
  var sections = secid.split('.');
  while (sections.length) {
    var toggle = document.getElementById('_sidebar_toggle_' + sections.join('.'));
    if (toggle) {
      toggle.checked = check;
    }
    sections.pop();
  }
}

updateSectionFocus(window.scrollY);
})();</script></div></body></html>